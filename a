? a
Index: AUTHORS
===================================================================
RCS file: /vws/pan/mpeg4ip/AUTHORS,v
retrieving revision 1.10
retrieving revision 1.11
diff -c -w -r1.10 -r1.11
*** AUTHORS	2002/06/14 23:12:49	1.10
--- AUTHORS	2002/07/22 17:27:31	1.11
***************
*** 29,33 ****
  the most knowledgeable person, and also benefit the community knowledge
  base.
  
! http://sourceforge.net/forums/?group_id=18676
  
--- 29,33 ----
  the most knowledgeable person, and also benefit the community knowledge
  base.
  
! http://sourceforge.net/projects/mpeg4ip/
  
Index: README
===================================================================
RCS file: /vws/pan/mpeg4ip/README,v
retrieving revision 1.62
retrieving revision 1.66
diff -c -w -r1.62 -r1.66
*** README	2002/07/15 21:26:06	1.62
--- README	2002/09/03 20:47:56	1.66
***************
*** 1,4 ****
! April 26, 2002
  
  MPEG4IP Project
  ===============
--- 1,4 ----
! August 30, 2002
  
  MPEG4IP Project
  ===============
***************
*** 91,97 ****
     make
     make install (needs root privileges).
  
! If this works for you, you can skip down to the next section on 
  Configure Script Options.  If this does not work, or you have downloaded 
  from CVS, the below applies.
  
--- 91,106 ----
     make
     make install (needs root privileges).
  
! If you don't have root privileges, but still wish to install the 
! distribution to a directory to which you do have write permission,
! then here is an example of how to do that:
! 
!    mkdir -p $HOME/local/bin $HOME/local/lib
!    ./bootstrap --prefix=$HOME/local
!    make
!    make install
! 
! If this process works for you, you can skip down to the next section on 
  Configure Script Options.  If this does not work, or you have downloaded 
  from CVS, the below applies.
  
***************
*** 589,593 ****
--- 598,620 ----
    
    You can get around this error by rebuilding your libc, after changing the
    THREAD_SCHED_USECS to 20000 (or lower) from 200000 in thread_private.h.
+ 
+ * If you're running on Linux, and trying to play a raw audio file, and 
+   notice that you get garbage, try setting the LimitAudioSdlBuffer config
+   variable to 1 in the .gmp4player_rc file.  This seems to occur on a 
+   Soundblaster Live, Red Hat 7.3 machine.
+ 
+ * As the RTP standard (or new draft) suggests, the round trip delay can
+   be approximated at the sender side by subtracting the intercepted time 
+   of a RTCP SR and the delay at the client side from the intercepted time 
+   of the corresponding RTCP RR. That is:
+          RRT = Time_RR - Time_SR - Time_delay_at_client.
+ 
+   However, as the Windows run-time library only provides up to 1 millisecond 
+   resolution (0.001 sec), such measurement on Windows machines on a LAN may 
+   be very inaccurate.
+ 
+   A typical RRT between two hosts on a LAN is around 0.5 millisecond.  
+   Measurements between Linux/Unix boxes have no such a problem. 
  
  === END OF README ===
Index: VERSION
===================================================================
RCS file: /vws/pan/mpeg4ip/VERSION,v
retrieving revision 1.45
retrieving revision 1.49
diff -c -w -r1.45 -r1.49
*** VERSION	2002/07/15 22:33:44	1.45
--- VERSION	2002/09/10 22:42:46	1.49
***************
*** 1 ****
! 0.9.5
--- 1 ----
! 0.9.5.4
Index: acconfig.h
===================================================================
RCS file: /vws/pan/mpeg4ip/acconfig.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -w -r1.7 -r1.8
*** acconfig.h	2002/05/08 20:08:43	1.7
--- acconfig.h	2002/08/14 01:04:58	1.8
***************
*** 7,12 ****
--- 7,18 ----
  
  #undef ARCH_X86
  
+ #undef ARCH_PPC
+ 
+ #undef ARCH_PPC_ALTIVEC
+ 
  #undef HAVE_IPv6
  
  #undef HAVE_ST_ADDRINFO
+ 
+ #undef HAVE_GTK_2_0
Index: bootstrap
===================================================================
RCS file: /vws/pan/mpeg4ip/bootstrap,v
retrieving revision 1.26
retrieving revision 1.27
diff -c -w -r1.26 -r1.27
*** bootstrap	2002/07/09 18:15:32	1.26
--- bootstrap	2002/07/29 17:35:01	1.27
***************
*** 24,29 ****
--- 24,36 ----
       exit 1
  fi
  
+ if (test ! -f ./configure) || (test ! -f ./lib/SDL/configure)
+ then echo "Please run cvs_bootstrap instead."
+      echo "Please note that you will need autoconf, automake and libtool"
+      echo "of the correct version as specified in the README"
+      exit 1
+ fi
+ 
  set -x
  
  # if src tree is created via cvs export to tar.gz
Index: configure.in
===================================================================
RCS file: /vws/pan/mpeg4ip/configure.in,v
retrieving revision 1.171
retrieving revision 1.182
diff -c -w -r1.171 -r1.182
*** configure.in	2002/07/15 22:33:44	1.171
--- configure.in	2002/09/10 22:42:46	1.182
***************
*** 8,14 ****
  AC_CANONICAL_TARGET
  
  
! AM_INIT_AUTOMAKE(mpeg4ip, 0.9.5)
  
  AC_CONFIG_SUBDIRS(lib/rtp)
  
--- 8,14 ----
  AC_CANONICAL_TARGET
  
  
! AM_INIT_AUTOMAKE(mpeg4ip, 0.9.5.4)
  
  AC_CONFIG_SUBDIRS(lib/rtp)
  
***************
*** 49,55 ****
  dnl Checks for header files.
  AC_HEADER_STDC
  AC_CHECK_HEADERS(fcntl.h unistd.h stdint.h inttypes.h getopt.h byteswap.h)
! AC_CHECK_HEADERS(linux/cdrom.h sys/dvdio.h glib.h)
  dnl check for Sun, BSD/OS libraries
  AC_CHECK_LIB(socket, socket)
  AC_CHECK_LIB(gnugetopt, getopt_long)
--- 49,55 ----
  dnl Checks for header files.
  AC_HEADER_STDC
  AC_CHECK_HEADERS(fcntl.h unistd.h stdint.h inttypes.h getopt.h byteswap.h)
! AC_CHECK_HEADERS(linux/cdrom.h sys/dvdio.h)
  dnl check for Sun, BSD/OS libraries
  AC_CHECK_LIB(socket, socket)
  AC_CHECK_LIB(gnugetopt, getopt_long)
***************
*** 158,178 ****
  fi
  ])
  
  dnl read out glib and gtk paths and flags.  Will need to dummy this
  dnl out for a glibless system
! AM_PATH_GLIB()
! if test "$no_glib" != yes; then
! AM_PATH_GTK()
! if test "$no_gtk" = yes; then
!    no_glib_gtk=yes
  else
!    no_glib_gtk=no
  fi
- else 
-    no_glib_gtk=yes
  fi
  
! AM_CONDITIONAL(NO_GLIB_GTK, test x$no_glib_gtk = xyes)
  
  AC_ARG_ENABLE(mmx,
                [  --enable-mmx           use MMX assembly on x86 [default=yes]],
--- 158,203 ----
  fi
  ])
  
+ case $target in
+ *powerpc*) 
+ 	AC_DEFINE(ARCH_PPC)
+ 	;;
+ esac
+ 
  dnl read out glib and gtk paths and flags.  Will need to dummy this
  dnl out for a glibless system
! glib_gtk=no
! AM_PATH_GLIB_2_0(, [haveglib20=yes], [haveglib20=no])
! if test x$haveglib20 = xyes; then 
!    AM_PATH_GTK_2_0(, [havegtk20=yes], [havegtk20=no])
!    if test x$havegtk20 = xyes; then 
!       AC_DEFINE(HAVE_GTK_2_0)
!       glib_gtk=yes
     else
!       haveglib20=no
     fi
  fi
+ if test x$haveglib20 = xno; then 
+    AM_PATH_GLIB(, [glib_gtk=yes], [glib_gtk=no])
+    if test x$glib_gtk = xyes; then
+       AM_PATH_GTK(, [glib_gtk=yes], [glib_gtk=no])
+    fi
+ fi
+ 
+ 
+ AM_CONDITIONAL(NO_GLIB_GTK, test x$glib_gtk = xno)
+ 
+ dnl If we're going to check for GLIB, we most likely need the real path
+ dnl we need to save off the CFLAGS and CPPFLAGS for the AC_CHECK_HEADER
+ dnl command 
  
! save_CFLAG=$CFLAGS
! save_CPPFLAG="$CPPFLAGS"
! CFLAGS="$CFLAGS $GLIB_CFLAGS"
! CPPFLAGS="$CPPFLAGS $GLIB_CFLAGS"
! AC_CHECK_HEADER(glib.h)
! CFLAGS="$save_CFLAG"
! CPPFLAGS="$save_CPPFLAG"
  
  AC_ARG_ENABLE(mmx,
                [  --enable-mmx           use MMX assembly on x86 [default=yes]],
***************
*** 333,338 ****
--- 358,365 ----
  	player/plugin/audio/Makefile \
  	player/plugin/audio/celp/Makefile \
  	player/plugin/audio/raw/Makefile \
+ 	player/plugin/rtp/Makefile \
+ 	player/plugin/rtp/isma_audio/Makefile \
  	player/plugin/video/Makefile \
  	player/plugin/video/mpeg3/Makefile \
  	player/plugin/video/raw/Makefile \
Index: cvs_bootstrap
===================================================================
RCS file: /vws/pan/mpeg4ip/cvs_bootstrap,v
retrieving revision 1.1
retrieving revision 1.3
diff -c -w -r1.1 -r1.3
*** cvs_bootstrap	2002/07/09 18:15:32	1.1
--- cvs_bootstrap	2002/08/14 16:33:10	1.3
***************
*** 72,79 ****
  
  cd $pwd 
  # top level - we're using autoheader, which needs to be after aclocal  
! aclocal || aclocal $ACLOCAL_FLAGS || aclocal -I util || aclocal -I util $ACLOCAL_FLAGS || exit 3
  libtoolize --force
  autoheader || exit 1
  automake --add-missing --foreign || exit 1
  autoconf || exit 1
--- 72,80 ----
  
  cd $pwd 
  # top level - we're using autoheader, which needs to be after aclocal  
! aclocal || aclocal $ACLOCAL_FLAGS || aclocal -I doc || aclocal -I util || aclocal -I util $ACLOCAL_FLAGS || exit 3
  libtoolize --force
+ grep AM_PATH_GTK_2_0 aclocal.m4 || aclocal -I doc || exit 3
  autoheader || exit 1
  automake --add-missing --foreign || exit 1
  autoconf || exit 1
Index: common/video/libmpeg32/bitstream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/bitstream.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** common/video/libmpeg32/bitstream.h	2002/06/13 22:54:06	1.4
--- common/video/libmpeg32/bitstream.h	2002/07/22 17:27:31	1.5
***************
*** 1,7 ****
  #ifndef BITSTREAM_H
  #define BITSTREAM_H
  
! #include <sys/types.h>
  
  //                                    next bit in forward direction
  //                                  next bit in reverse direction |
--- 1,7 ----
  #ifndef BITSTREAM_H
  #define BITSTREAM_H
  
! #include <systems.h>
  
  //                                    next bit in forward direction
  //                                  next bit in reverse direction |
***************
*** 13,19 ****
  
  typedef struct
  {
! 	u_int32_t bfr;  /* bfr = buffer for bits */
  	int bit_number;   /* position of pointer in bfr */
  	int bfr_size;    /* number of bits in bfr.  Should always be a multiple of 8 */
  /* If the input ptr is true, data is read from it instead of the demuxer. */
--- 13,19 ----
  
  typedef struct
  {
! 	uint32_t bfr;  /* bfr = buffer for bits */
  	int bit_number;   /* position of pointer in bfr */
  	int bfr_size;    /* number of bits in bfr.  Should always be a multiple of 8 */
  /* If the input ptr is true, data is read from it instead of the demuxer. */
Index: common/video/libmpeg32/libmpeg3.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/libmpeg3.c,v
retrieving revision 1.8
retrieving revision 1.11
diff -c -w -r1.8 -r1.11
*** common/video/libmpeg32/libmpeg3.c	2002/06/18 22:35:54	1.8
--- common/video/libmpeg32/libmpeg3.c	2002/07/26 17:59:48	1.11
***************
*** 63,69 ****
  int mpeg3_check_sig(const char *path)
  {
  	mpeg3_fs_t *fs;
! 	u_int32_t bits;
  	char *ext;
  	int result = 0;
  
--- 63,69 ----
  int mpeg3_check_sig(const char *path)
  {
  	mpeg3_fs_t *fs;
! 	uint32_t bits;
  	char *ext;
  	int result = 0;
  
***************
*** 711,717 ****
  	return 0;
  }
  
! float mpeg3_frame_rate(mpeg3_t *file,
  		int stream)
  {
  	if(file->total_vstreams)
--- 711,717 ----
  	return 0;
  }
  
! double mpeg3_frame_rate(mpeg3_t *file,
  		int stream)
  {
  	if(file->total_vstreams)
***************
*** 719,724 ****
--- 719,739 ----
  	return -1;
  }
  
+ double mpeg3_video_bitrate(mpeg3_t *file,
+ 		int stream)
+ {
+ 	if(file->total_vstreams)
+ 		return file->vtrack[stream]->bitrate;
+ 	return -1;
+ }
+ 
+ int mpeg3_video_layer (mpeg3_t *file, int stream)
+ {
+   if (file->total_vstreams) 
+     return file->vtrack[stream]->mpeg_layer;
+   return -1;
+ }
+ 
  long mpeg3_video_frames(mpeg3_t *file,
  		int stream)
  {
***************
*** 828,834 ****
  			    int stream)
  {
    int result = -1;
!   if (file->total_astreams) {
      result = mpeg3_atrack_read_frame(file->atrack[stream],
  				     output, 
  				     size,
--- 843,849 ----
  			    int stream)
  {
    int result = -1;
!   if (file->total_astreams > stream) {
      result = mpeg3_atrack_read_frame(file->atrack[stream],
  				     output, 
  				     size,
***************
*** 842,848 ****
  				 
  int mpeg3_get_audio_format (mpeg3_t *file, int stream)
  {
!   if (file->total_astreams) {
      return (file->atrack[stream]->format);
    }
    return AUDIO_UNKNOWN;
--- 857,863 ----
  				 
  int mpeg3_get_audio_format (mpeg3_t *file, int stream)
  {
!   if (file->total_astreams > stream) {
      return (file->atrack[stream]->format);
    }
    return AUDIO_UNKNOWN;
Index: common/video/libmpeg32/libmpeg3.h
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/libmpeg3.h,v
retrieving revision 1.4
retrieving revision 1.6
diff -c -w -r1.4 -r1.6
*** common/video/libmpeg32/libmpeg3.h	2002/05/21 21:01:40	1.4
--- common/video/libmpeg32/libmpeg3.h	2002/07/26 17:59:48	1.6
***************
*** 98,105 ****
  int mpeg3_total_vstreams(mpeg3_t *file);            /* Number of multiplexed video streams */
  int mpeg3_video_width(mpeg3_t *file, int stream);
  int mpeg3_video_height(mpeg3_t *file, int stream);
  float mpeg3_aspect_ratio(mpeg3_t *file, int stream); /* aspect ratio.  0 if none */
! float mpeg3_frame_rate(mpeg3_t *file, int stream);  /* Frames/sec */
  
  /* Total length.   */
  /* For DVD files, this is 1 indicating only percentage seeking is available. */
--- 98,107 ----
  int mpeg3_total_vstreams(mpeg3_t *file);            /* Number of multiplexed video streams */
  int mpeg3_video_width(mpeg3_t *file, int stream);
  int mpeg3_video_height(mpeg3_t *file, int stream);
+ int mpeg3_video_layer(mpeg3_t *file, int stream);
  float mpeg3_aspect_ratio(mpeg3_t *file, int stream); /* aspect ratio.  0 if none */
! double mpeg3_frame_rate(mpeg3_t *file, int stream);  /* Frames/sec */
!   double mpeg3_video_bitrate(mpeg3_t *file, int stream);
  
  /* Total length.   */
  /* For DVD files, this is 1 indicating only percentage seeking is available. */
Index: common/video/libmpeg32/mpeg3ifo.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/mpeg3ifo.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -w -r1.3 -r1.4
*** common/video/libmpeg32/mpeg3ifo.c	2002/05/21 21:01:40	1.3
--- common/video/libmpeg32/mpeg3ifo.c	2002/07/22 17:27:31	1.4
***************
*** 63,74 ****
  
  static u_int get4bytes(u_char *buf)
  {
! 	return B2N_32(*((u_int32_t *)buf));
  }
  
  static u_int get2bytes(u_char *buf)
  {
! 	return B2N_16(*((u_int16_t *)buf));
  }
  
  static int ifo_read(int fd, long pos, long count, unsigned char *data)
--- 63,74 ----
  
  static u_int get4bytes(u_char *buf)
  {
! 	return B2N_32(*((uint32_t *)buf));
  }
  
  static u_int get2bytes(u_char *buf)
  {
! 	return B2N_16(*((uint16_t *)buf));
  }
  
  static int ifo_read(int fd, long pos, long count, unsigned char *data)
***************
*** 118,124 ****
  	unsigned char *data;
  	unsigned long len = 0;
  	int i;
! 	u_int32_t *ptr;
  
  	if(!offset) return -1;
  
--- 118,124 ----
  	unsigned char *data;
  	unsigned long len = 0;
  	int i;
! 	uint32_t *ptr;
  
  	if(!offset) return -1;
  
***************
*** 152,158 ****
  	}
  
  	ifo->data[tbl_id] = data;
! 	ptr = (u_int32_t*)data;
  	len /= 4;
  
  	if(tbl_id == ID_TMT) 
--- 152,158 ----
  	}
  
  	ifo->data[tbl_id] = data;
! 	ptr = (uint32_t*)data;
  	len /= 4;
  
  	if(tbl_id == ID_TMT) 
Index: common/video/libmpeg32/mpeg3title.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/mpeg3title.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** common/video/libmpeg32/mpeg3title.c	2002/05/13 22:00:40	1.2
--- common/video/libmpeg32/mpeg3title.c	2002/07/22 17:27:31	1.3
***************
*** 175,181 ****
  	double next_time, prev_time, absolute_time;
  	long i;
  	mpeg3_title_t *title;
! 	u_int32_t test_header = 0;
  	mpeg3demux_timecode_t *timecode = 0;
  
  	demuxer->error_flag = 0;
--- 175,181 ----
  	double next_time, prev_time, absolute_time;
  	long i;
  	mpeg3_title_t *title;
! 	uint32_t test_header = 0;
  	mpeg3demux_timecode_t *timecode = 0;
  
  	demuxer->error_flag = 0;
Index: common/video/libmpeg32/mpeg3vtrack.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/mpeg3vtrack.c,v
retrieving revision 1.10
retrieving revision 1.15
diff -c -w -r1.10 -r1.15
*** common/video/libmpeg32/mpeg3vtrack.c	2002/07/03 21:06:54	1.10
--- common/video/libmpeg32/mpeg3vtrack.c	2002/07/29 17:14:02	1.15
***************
*** 78,84 ****
  int mpeg3vtrack_get_frame (mpeg3_vtrack_t *track)
  
  {
! 	u_int32_t code = 0;
  	int have_pict_start, done;
  	mpeg3_demuxer_t *demux = track->demuxer;
  	unsigned char *output;
--- 78,84 ----
  int mpeg3vtrack_get_frame (mpeg3_vtrack_t *track)
  
  {
! 	uint32_t code = 0;
  	int have_pict_start, done;
  	mpeg3_demuxer_t *demux = track->demuxer;
  	unsigned char *output;
***************
*** 355,361 ****
  	int number)
  {
    uint32_t h,w;
!   double frame_rate;
  
  	int result = 0;
  	mpeg3_vtrack_t *new_vtrack;
--- 355,362 ----
  	int number)
  {
    uint32_t h,w;
!   int have_mpeg2;
!   double frame_rate, bitrate;
  
  	int result = 0;
  	mpeg3_vtrack_t *new_vtrack;
***************
*** 390,398 ****
  	
  	if (MP4AV_Mpeg3ParseSeqHdr(new_vtrack->track_frame_buffer, 
  				   new_vtrack->track_frame_buffer_size, 
  				   &h,
  				   &w, 
! 				   &frame_rate) < 0) {
  	  mpeg3_delete_vtrack(file, new_vtrack);
  	  return NULL;
  	}
--- 391,401 ----
  	
  	if (MP4AV_Mpeg3ParseSeqHdr(new_vtrack->track_frame_buffer, 
  				   new_vtrack->track_frame_buffer_size, 
+ 				   &have_mpeg2,
  				   &h,
  				   &w, 
! 				   &frame_rate,
! 				   &bitrate) < 0) {
  	  mpeg3_delete_vtrack(file, new_vtrack);
  	  return NULL;
  	}
***************
*** 400,405 ****
--- 403,409 ----
  	new_vtrack->frame_rate = frame_rate;
  	new_vtrack->width = w;
  	new_vtrack->height = h;
+ 	new_vtrack->mpeg_layer = have_mpeg2 ? 2 : 1;
  	mpeg3demux_seek_start(new_vtrack->demuxer);
  	new_vtrack->track_frame_buffer_size = 0;
  
***************
*** 420,425 ****
--- 424,430 ----
  int mpeg3_delete_vtrack(mpeg3_t *file, mpeg3_vtrack_t *vtrack)
  {
  	if(vtrack->demuxer) mpeg3_delete_demuxer(vtrack->demuxer);
+ 	if(vtrack->track_frame_buffer) free(vtrack->track_frame_buffer);
  	free(vtrack);
  	return 0;
  }
***************
*** 430,436 ****
  			  long *size, 
  			  long max_size)
  {
!   u_int32_t code = 0;
  
    mpeg3_demuxer_t *demux = vtrack->demuxer;
    *size = 0;
--- 435,441 ----
  			  long *size, 
  			  long max_size)
  {
!   uint32_t code = 0;
  
    mpeg3_demuxer_t *demux = vtrack->demuxer;
    *size = 0;
Index: common/video/libmpeg32/mpeg3vtrack.h
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/mpeg3vtrack.h,v
retrieving revision 1.4
retrieving revision 1.6
diff -c -w -r1.4 -r1.6
*** common/video/libmpeg32/mpeg3vtrack.h	2002/05/21 21:01:40	1.4
--- common/video/libmpeg32/mpeg3vtrack.h	2002/07/26 17:59:48	1.6
***************
*** 9,15 ****
    void *file;
  	int width;
  	int height;
! 	float frame_rate;
  	float aspect_ratio;
  	mpeg3_demuxer_t *demuxer;
  	long current_position;  /* Number of next frame to be played */
--- 9,17 ----
    void *file;
    int width;
    int height;
!   int mpeg_layer; // 1 or 2
!   double frame_rate;
!   double bitrate;
    float aspect_ratio;
    mpeg3_demuxer_t *demuxer;
    long current_position;  /* Number of next frame to be played */
Index: common/video/libmpeg32/video/getpicture.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/video/getpicture.c,v
retrieving revision 1.4
retrieving revision 1.6
diff -c -w -r1.4 -r1.6
*** common/video/libmpeg32/video/getpicture.c	2002/07/02 23:25:00	1.4
--- common/video/libmpeg32/video/getpicture.c	2002/07/25 21:07:00	1.6
***************
*** 598,609 ****
  		slice_buffer->data[slice_buffer->buffer_size++] = 0;
  		slice_buffer->bits_size = 0;
  
! #ifndef SDL_THREADS
! 		pthread_mutex_lock(&(slice_buffer->completion_lock));
! #else
! 		SDL_LockMutex(slice_buffer->completion_lock);
! #endif
! 		fflush(stdout);
  		current_buffer++;
  		video->total_slice_buffers++;
  	}
--- 598,604 ----
  		slice_buffer->data[slice_buffer->buffer_size++] = 0;
  		slice_buffer->bits_size = 0;
  
! 		//fflush(stdout);
  		current_buffer++;
  		video->total_slice_buffers++;
  	}
***************
*** 632,668 ****
  				video->slice_decoders[i].buffer_step = 1;
  				video->slice_decoders[i].last_buffer = video->total_slice_buffers - 1;
  			}
! #ifndef SDL_THREADS
! 			pthread_mutex_unlock(&(video->slice_decoders[i].input_lock));
! #else
! 			SDL_UnlockMutex(video->slice_decoders[i].input_lock);
! #endif
  		}
  	}
  
  /* Wait for the slice buffers to finish */
  	if(video->total_slice_buffers > 0)
  	{
! 		for(i = 0; i < video->total_slice_buffers; i++)
! 		{
! #ifndef SDL_THREADS
! 			pthread_mutex_lock(&(video->slice_buffers[i].completion_lock));
! 			pthread_mutex_unlock(&(video->slice_buffers[i].completion_lock));
! #else
! 			SDL_LockMutex(video->slice_buffers[i].completion_lock);
! 			SDL_UnlockMutex(video->slice_buffers[i].completion_lock);
! #endif
  		}
! 
! /* Wait for decoders to finish so packages aren't overwritten */
! 		for(i = 0; i < video->total_slice_decoders; i++)
! 		{
! #ifndef SDL_THREADS
! 			pthread_mutex_lock(&(video->slice_decoders[i].completion_lock));
! #else
! 			SDL_LockMutex(video->slice_decoders[i].completion_lock);
! #endif
  		}
  	}
  	return 0;
  }
--- 627,652 ----
  				video->slice_decoders[i].buffer_step = 1;
  				video->slice_decoders[i].last_buffer = video->total_slice_buffers - 1;
  			}
! 			SDL_SemPost(video->slice_decoders[i].input_sem);
  		}
  	}
  
  /* Wait for the slice buffers to finish */
  	if(video->total_slice_buffers > 0)
  	{
! 	  int all_complete;
! 	  do {
! 	    SDL_SemWait(video->slice_complete_sem);
! 	    all_complete = 1;
! 	    for (i = 0; i < video->total_slice_buffers && all_complete == 1; i++) {
! 	      SDL_LockMutex(video->slice_buffers[i].buffer_completion_lock);
! 	      if (video->slice_buffers[i].done == 0) {
! 		all_complete = 0;
  	      }
! 	      SDL_UnlockMutex(video->slice_buffers[i].buffer_completion_lock);
  	    }
+ 	  } while (all_complete == 0);
+ 	  
  	}
  	return 0;
  }
Index: common/video/libmpeg32/video/mpeg3video.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/video/mpeg3video.c,v
retrieving revision 1.6
retrieving revision 1.10
diff -c -w -r1.6 -r1.10
*** common/video/libmpeg32/video/mpeg3video.c	2002/07/02 23:25:00	1.6
--- common/video/libmpeg32/video/mpeg3video.c	2002/07/25 21:07:00	1.10
***************
*** 267,277 ****
  	pthread_mutexattr_init(&mutex_attr);
  //	pthread_mutexattr_setkind_np(&mutex_attr, PTHREAD_MUTEX_FAST_NP);
  	pthread_mutex_init(&(video->test_lock), &mutex_attr);
! 	pthread_mutex_init(&(video->slice_lock), &mutex_attr);
  #else
  	video->test_lock = SDL_CreateMutex();
- 	video->slice_lock = SDL_CreateMutex();
  #endif
  	return video;
  }
  
--- 267,278 ----
  	pthread_mutexattr_init(&mutex_attr);
  //	pthread_mutexattr_setkind_np(&mutex_attr, PTHREAD_MUTEX_FAST_NP);
  	pthread_mutex_init(&(video->test_lock), &mutex_attr);
! 	//pthread_mutex_init(&(video->slice_lock), &mutex_attr);
  #else
  	video->test_lock = SDL_CreateMutex();
  #endif
+ 	video->slice_lock = SDL_CreateMutex();
+ 	video->slice_complete_sem = SDL_CreateSemaphore(0);
  	return video;
  }
  
***************
*** 281,291 ****
  	mpeg3bits_delete_stream(video->vstream);
  #ifndef SDL_THREADS
  	pthread_mutex_destroy(&(video->test_lock));
! 	pthread_mutex_destroy(&(video->slice_lock));
  #else
  	SDL_DestroyMutex(video->test_lock);
- 	SDL_DestroyMutex(video->slice_lock);
  #endif
  	if(video->x_table)
  	{
  		free(video->x_table);
--- 282,293 ----
  	mpeg3bits_delete_stream(video->vstream);
  #ifndef SDL_THREADS
  	pthread_mutex_destroy(&(video->test_lock));
! 	//pthread_mutex_destroy(&(video->slice_lock));
  #else
  	SDL_DestroyMutex(video->test_lock);
  #endif
+ 	SDL_DestroyMutex(video->slice_lock);
+ 	SDL_DestroySemaphore(video->slice_complete_sem);
  	if(video->x_table)
  	{
  		free(video->x_table);
***************
*** 299,304 ****
--- 301,310 ----
  	for(i = 0; i < video->slice_buffers_initialized; i++)
  		mpeg3_delete_slice_buffer(&(video->slice_buffers[i]));
  
+ 	if(video->decoder_initted)
+ 	{
+ 		mpeg3video_deletedecoder(video);
+ 	}
  	free(video);
  	return 0;
  }
***************
*** 407,416 ****
  
  int mpeg3video_delete(mpeg3video_t *video)
  {
- 	if(video->decoder_initted)
- 	{
- 		mpeg3video_deletedecoder(video);
- 	}
  	mpeg3video_delete_struct(video);
  	return 0;
  }
--- 413,418 ----
Index: common/video/libmpeg32/video/mpeg3video.h
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/video/mpeg3video.h,v
retrieving revision 1.6
retrieving revision 1.8
diff -c -w -r1.6 -r1.8
*** common/video/libmpeg32/video/mpeg3video.h	2002/07/02 23:25:00	1.6
--- common/video/libmpeg32/video/mpeg3video.h	2002/07/25 21:07:00	1.8
***************
*** 102,112 ****
  	mpeg3_slice_buffer_t slice_buffers[MPEG3_MAX_CPUS];   /* Buffers for holding the slice data */
  	int total_slice_buffers;         /* Total buffers in the array to be decompressed */
  	int slice_buffers_initialized;     /* Total buffers initialized in the array */
  #ifndef SDL_THREADS
- 	pthread_mutex_t slice_lock;      /* Lock slice array while getting the next buffer */
  	pthread_mutex_t test_lock;
  #else
- 	SDL_mutex *slice_lock;
  	SDL_mutex *test_lock;
  #endif
  
--- 102,112 ----
  	mpeg3_slice_buffer_t slice_buffers[MPEG3_MAX_CPUS];   /* Buffers for holding the slice data */
  	int total_slice_buffers;         /* Total buffers in the array to be decompressed */
  	int slice_buffers_initialized;     /* Total buffers initialized in the array */
+ 	SDL_mutex *slice_lock;
+   SDL_sem *slice_complete_sem;
  #ifndef SDL_THREADS
  	pthread_mutex_t test_lock;
  #else
  	SDL_mutex *test_lock;
  #endif
  
Index: common/video/libmpeg32/video/seek.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/video/seek.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** common/video/libmpeg32/video/seek.c	2002/05/02 22:12:43	1.2
--- common/video/libmpeg32/video/seek.c	2002/07/25 19:47:36	1.3
***************
*** 20,25 ****
--- 20,27 ----
  //	stream->demuxer->titles[0]->fs->current_byte, 
  //	stream->demuxer->titles[0]->fs->total_bytes);
  
+   if (mpeg3bits_eof(stream)) return 0xffffffff;
+ 
  /* Perform search */
    while(1)
      {
***************
*** 27,33 ****
  
        //printf("mpeg3bits_next_startcode 2 %lx\n", code);
        if((code >> 8) == MPEG3_PACKET_START_CODE_PREFIX) break;
!       if(mpeg3bits_eof(stream)) break;
  
  
        mpeg3bits_getbyte_noptr(stream);
--- 29,35 ----
  
        //printf("mpeg3bits_next_startcode 2 %lx\n", code);
        if((code >> 8) == MPEG3_PACKET_START_CODE_PREFIX) break;
!       if(mpeg3bits_eof(stream)) return 0xffffffff;
  
  
        mpeg3bits_getbyte_noptr(stream);
Index: common/video/libmpeg32/video/slice.c
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/video/slice.c,v
retrieving revision 1.3
retrieving revision 1.6
diff -c -w -r1.3 -r1.6
*** common/video/libmpeg32/video/slice.c	2002/07/02 23:25:00	1.3
--- common/video/libmpeg32/video/slice.c	2002/07/25 21:07:00	1.6
***************
*** 16,30 ****
  #ifndef _MSC_VER
  static unsigned long long MMX_128 = 0x80008000800080LL;
  #else
! static u_int64_t MMX_128 = 0x80008000800080;
  #endif
  
  int mpeg3_new_slice_buffer(mpeg3_slice_buffer_t *slice_buffer)
  {
- #ifndef SDL_THREADS
- 	pthread_mutexattr_t mutex_attr;
- #endif
- 
  	slice_buffer->data = malloc(1024);
  	slice_buffer->buffer_size = 0;
  	slice_buffer->buffer_allocation = 1024;
--- 16,26 ----
  #ifndef _MSC_VER
  static unsigned long long MMX_128 = 0x80008000800080LL;
  #else
! static uint64_t MMX_128 = 0x80008000800080;
  #endif
  
  int mpeg3_new_slice_buffer(mpeg3_slice_buffer_t *slice_buffer)
  {
  	slice_buffer->data = malloc(1024);
  	slice_buffer->buffer_size = 0;
  	slice_buffer->buffer_allocation = 1024;
***************
*** 32,55 ****
  	slice_buffer->bits_size = 0;
  	slice_buffer->bits = 0;
  	slice_buffer->done = 0;
! #ifndef SDL_THREADS
! 	pthread_mutexattr_init(&mutex_attr);
! //	pthread_mutexattr_setkind_np(&mutex_attr, PTHREAD_MUTEX_FAST_NP);
! 	pthread_mutex_init(&(slice_buffer->completion_lock), &mutex_attr);
! #else
! 	slice_buffer->completion_lock = SDL_CreateMutex();
! #endif
  	return 0;
  }
  
  int mpeg3_delete_slice_buffer(mpeg3_slice_buffer_t *slice_buffer)
  {
  	free(slice_buffer->data);
! #ifndef SDL_THREADS
! 	pthread_mutex_destroy(&(slice_buffer->completion_lock));
! #else
! 	SDL_DestroyMutex(slice_buffer->completion_lock);
! #endif
  	return 0;
  }
  
--- 28,42 ----
  	slice_buffer->bits_size = 0;
  	slice_buffer->bits = 0;
  	slice_buffer->done = 0;
! 	slice_buffer->buffer_completion_lock = SDL_CreateMutex();
! 
  	return 0;
  }
  
  int mpeg3_delete_slice_buffer(mpeg3_slice_buffer_t *slice_buffer)
  {
  	free(slice_buffer->data);
! 	SDL_DestroyMutex(slice_buffer->buffer_completion_lock);
  	return 0;
  }
  
***************
*** 638,661 ****
  {
  	mpeg3video_t *video = slice->video;
  	int result = 1;
  
  	while(!slice->done)
  	{
! #ifndef SDL_THREADS
! 		pthread_mutex_lock(&(slice->input_lock));
! #else
! 		SDL_LockMutex(slice->input_lock);
! #endif
! 
  		if(!slice->done)
  		{
  /* Get a buffer to decode */
  			result = 1;
- #ifndef SDL_THREADS
- 			pthread_mutex_lock(&(video->slice_lock));
- #else
  			SDL_LockMutex(video->slice_lock);
- #endif
  			if(slice->buffer_step > 0)
  			{
  				while(slice->current_buffer <= slice->last_buffer)
--- 625,644 ----
  {
    mpeg3video_t *video = slice->video;
    int result = 1;
+   int cont = 0;
  
    while(!slice->done)
      {
!       if (cont == 0) {
! 	// only wait if we're done...
! 	SDL_SemWait(slice->input_sem);
! 	cont = 1;
!       }
        if(!slice->done)
  	{
  	  /* Get a buffer to decode */
  	  result = 1;
  	  SDL_LockMutex(video->slice_lock);
  	  if(slice->buffer_step > 0)
  	    {
  	      while(slice->current_buffer <= slice->last_buffer)
***************
*** 684,725 ****
  			}
  
  /* Got one */
! 			if(!result && slice->current_buffer >= 0 && slice->current_buffer < video->total_slice_buffers)
  			{
  				slice->slice_buffer = &(video->slice_buffers[slice->current_buffer]);
  				slice->slice_buffer->done = 1;
- #ifndef SDL_THREADS
- 				pthread_mutex_unlock(&(video->slice_lock));
- 				pthread_mutex_unlock(&(slice->input_lock));
- #else
  				SDL_UnlockMutex(video->slice_lock);
- 				SDL_UnlockMutex(slice->input_lock);
- #endif
  				mpeg3_decode_slice(slice);
! #ifndef SDL_THREADS
! 				pthread_mutex_unlock(&(slice->slice_buffer->completion_lock));
! #else
! 				SDL_UnlockMutex(slice->slice_buffer->completion_lock);
! #endif
  			}
  			else
  /* Finished with all */
  			{
! #ifndef SDL_THREADS
! 				pthread_mutex_unlock(&(slice->completion_lock));
! 				pthread_mutex_unlock(&(video->slice_lock));
! #else
! 				SDL_UnlockMutex(slice->completion_lock);
  				SDL_UnlockMutex(video->slice_lock);
! #endif
  			}
  		}
  
- #ifndef SDL_THREADS
- 		pthread_mutex_unlock(&(slice->output_lock));
- #else
- 		SDL_UnlockMutex(slice->output_lock);
- #endif
  	}
  }
  
--- 667,692 ----
  	    }
  
  	  /* Got one */
! 	  if (!result && 
! 	      slice->current_buffer >= 0 && 
! 	      slice->current_buffer < video->total_slice_buffers)
  	    {
  	      slice->slice_buffer = &(video->slice_buffers[slice->current_buffer]);
+ 	      SDL_LockMutex(slice->slice_buffer->buffer_completion_lock);
  	      slice->slice_buffer->done = 1;
  	      SDL_UnlockMutex(video->slice_lock);
  	      mpeg3_decode_slice(slice);
! 	      SDL_UnlockMutex(slice->slice_buffer->buffer_completion_lock);
  	    }
  	  else
  	    /* Finished with all */
  	    {
! 	      cont = 0; // back to waiting
  	      SDL_UnlockMutex(video->slice_lock);
! 	      SDL_SemPost(video->slice_complete_sem);
  	    }
  	}
  
      }
  }
  
***************
*** 727,755 ****
  {
  #ifndef SDL_THREADS
  	pthread_attr_t  attr;
- 	pthread_mutexattr_t mutex_attr;
  #endif
  
  	slice->video = video;
  	slice->done = 0;
! #ifndef SDL_THREADS
! 	pthread_mutexattr_init(&mutex_attr);
! //	pthread_mutexattr_setkind_np(&mutex_attr, PTHREAD_MUTEX_FAST_NP);
! 	pthread_mutex_init(&(slice->input_lock), &mutex_attr);
! 	pthread_mutex_lock(&(slice->input_lock));
! 	pthread_mutex_init(&(slice->output_lock), &mutex_attr);
! 	pthread_mutex_lock(&(slice->output_lock));
! 	pthread_mutex_init(&(slice->completion_lock), &mutex_attr);
! 	pthread_mutex_lock(&(slice->completion_lock));
! #else
! 	slice->input_lock = SDL_CreateMutex();
! 	SDL_LockMutex(slice->input_lock);
! 	slice->output_lock = SDL_CreateMutex();
! 	SDL_LockMutex(slice->output_lock);
! 	slice->completion_lock = SDL_CreateMutex();
! 	SDL_LockMutex(slice->completion_lock);
! #endif
! 
  #ifndef SDL_THREADS
  	pthread_attr_init(&attr);
  	pthread_create(&(slice->tid), &attr, (void*)mpeg3_slice_loop, slice);
--- 694,704 ----
  {
  #ifndef SDL_THREADS
  	pthread_attr_t  attr;
  #endif
  
  	slice->video = video;
  	slice->done = 0;
! 	slice->input_sem = SDL_CreateSemaphore(0);
  #ifndef SDL_THREADS
  	pthread_attr_init(&attr);
  	pthread_create(&(slice->tid), &attr, (void*)mpeg3_slice_loop, slice);
***************
*** 763,779 ****
  int mpeg3_delete_slice_decoder(mpeg3_slice_t *slice)
  {
  	slice->done = 1;
  #ifndef SDL_THREADS
- 	pthread_mutex_unlock(&(slice->input_lock));
  	pthread_join(slice->tid, 0);
- 	pthread_mutex_destroy(&(slice->input_lock));
- 	pthread_mutex_destroy(&(slice->output_lock));
  #else
- 	SDL_UnlockMutex(slice->input_lock);
  	SDL_WaitThread(slice->tid, NULL);
- 	SDL_DestroyMutex(slice->input_lock);
- 	SDL_DestroyMutex(slice->output_lock);
  #endif
! 
  	return 0;
  }
--- 712,723 ----
  int mpeg3_delete_slice_decoder(mpeg3_slice_t *slice)
  {
  	slice->done = 1;
+ 	SDL_SemPost(slice->input_sem);
  #ifndef SDL_THREADS
  	pthread_join(slice->tid, 0);
  #else
  	SDL_WaitThread(slice->tid, NULL);
  #endif
! 	SDL_DestroySemaphore(slice->input_sem);
  	return 0;
  }
Index: common/video/libmpeg32/video/slice.h
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/libmpeg32/video/slice.h,v
retrieving revision 1.4
retrieving revision 1.7
diff -c -w -r1.4 -r1.7
*** common/video/libmpeg32/video/slice.h	2002/07/02 23:25:00	1.4
--- common/video/libmpeg32/video/slice.h	2002/07/25 21:07:00	1.7
***************
*** 4,13 ****
  #include <sys/types.h>
  #ifndef SDL_THREADS
  #include <pthread.h>
! #else
  #include "SDL.h"
  #include "SDL_thread.h"
! #endif
  
  /* Array of these feeds the slice decoders */
  typedef struct
--- 4,13 ----
  #include <sys/types.h>
  #ifndef SDL_THREADS
  #include <pthread.h>
! #endif
  #include "SDL.h"
  #include "SDL_thread.h"
! 
  
  /* Array of these feeds the slice decoders */
  typedef struct
***************
*** 16,28 ****
  	int buffer_size;         /* Size of buffer */
  	int buffer_allocation;   /* Space allocated for buffer  */
  	int current_position;    /* Position in buffer */
! 	u_int32_t bits;
  	int bits_size;
! #ifndef SDL_THREADS
! 	pthread_mutex_t completion_lock; /* Lock slice until completion */
! #else
! 	SDL_mutex *completion_lock;
! #endif
  	int done;           /* Signal for slice decoder to skip */
  } mpeg3_slice_buffer_t;
  
--- 16,24 ----
  	int buffer_size;         /* Size of buffer */
  	int buffer_allocation;   /* Space allocated for buffer  */
  	int current_position;    /* Position in buffer */
! 	uint32_t bits;
  	int bits_size;
! 	SDL_mutex *buffer_completion_lock;
  	int done;           /* Signal for slice decoder to skip */
  } mpeg3_slice_buffer_t;
  
***************
*** 44,54 ****
  	int sparse[12];
  #ifndef SDL_THREADS
  	pthread_t tid;   /* ID of thread */
- 	pthread_mutex_t input_lock, output_lock, completion_lock;
  #else
  	SDL_Thread *tid;   /* ID of thread */
- 	SDL_mutex *input_lock, *output_lock, *completion_lock;
  #endif
  } mpeg3_slice_t;
  
  #define mpeg3slice_fillbits(buffer, nbits) \
--- 40,49 ----
  	int sparse[12];
  #ifndef SDL_THREADS
  	pthread_t tid;   /* ID of thread */
  #else
  	SDL_Thread *tid;   /* ID of thread */
  #endif
+   SDL_sem *input_sem;
  } mpeg3_slice_t;
  
  #define mpeg3slice_fillbits(buffer, nbits) \
Index: common/video/mpeg4/sys/decoder/vopsedec.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/mpeg4/sys/decoder/vopsedec.cpp,v
retrieving revision 1.21
retrieving revision 1.22
diff -c -w -r1.21 -r1.22
*** common/video/mpeg4/sys/decoder/vopsedec.cpp	2002/03/27 21:43:11	1.21
--- common/video/mpeg4/sys/decoder/vopsedec.cpp	2002/09/10 22:41:02	1.22
***************
*** 99,104 ****
--- 99,105 ----
  
  Int CVideoObjectDecoder::h263_decode ()
  {
+ #if 0
  	static Bool first_time = TRUE;
  
  	if (!first_time) 
***************
*** 111,121 ****
  		}
  
  	
- 		m_pbitstrmIn -> getBits(22);
  		video_plane_with_short_header(); 
  	}
  	else
  		first_time = FALSE;
  
  	m_bUseGOV=FALSE; 
  	m_bLinkisBroken=FALSE;
--- 112,122 ----
  		}
  
  	
  		video_plane_with_short_header(); 
  	}
  	else
  		first_time = FALSE;
+ #endif
  
  	m_bUseGOV=FALSE; 
  	m_bLinkisBroken=FALSE;
***************
*** 207,212 ****
--- 208,215 ----
  
  Void CVideoObjectDecoder::video_plane_with_short_header()
  {
+   short_video_header = 1;
+   m_pbitstrmIn -> getBits(22);  // read header
    /* UInt uiTemporalReference = wmay */ m_pbitstrmIn -> getBits (8);
  	m_pbitstrmIn -> getBits(5);
  	UInt uiSourceFormat = m_pbitstrmIn -> getBits (3);
***************
*** 295,301 ****
  {
  	UInt uiIntraDC;
  	uiIntraDC=m_pbitstrmIn->getBits(8);
! 	if (uiIntraDC==128||uiIntraDC==0) fprintf(stderr,"IntraDC = 0 of 128, not allowed in H.263 mode\n");
  	if (uiIntraDC==255) uiIntraDC=128;
  	
  	rgiCoefQ[0]=uiIntraDC;
--- 298,304 ----
  {
  	UInt uiIntraDC;
  	uiIntraDC=m_pbitstrmIn->getBits(8);
! 	if (uiIntraDC==128||uiIntraDC==0) fprintf(stderr,"IntraDC = 0 of 128, not allowed in H.263 mode value %d\n", uiIntraDC);
  	if (uiIntraDC==255) uiIntraDC=128;
  	
  	rgiCoefQ[0]=uiIntraDC;
***************
*** 350,356 ****
  
  		fprintf(stderr, "\nBitstream with short header format detected\n"); 
  		*p_short_video_header=TRUE;  
! 		m_pbitstrmIn -> getBits(22);
  		video_plane_with_short_header();
  	}
  	else {
--- 353,359 ----
  
  		fprintf(stderr, "\nBitstream with short header format detected\n"); 
  		*p_short_video_header=TRUE;  
! 		// moved inside routine m_pbitstrmIn -> getBits(22);
  		video_plane_with_short_header();
  	}
  	else {
***************
*** 531,536 ****
--- 534,540 ----
  		m_pentrdecSet = new CEntropyDecoderSet (*m_pbitstrmIn);
  	}
  #endif
+ 	//printf("start decoding\n");
  	//sprite piece should not come here
  	assert ((m_vopmd.SpriteXmitMode == STOP) || ( m_vopmd.SpriteXmitMode == PAUSE));
  
Index: common/video/mpeg4/tools/entropy/bitstrm.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/mpeg4/tools/entropy/bitstrm.cpp,v
retrieving revision 1.14
retrieving revision 1.15
diff -c -w -r1.14 -r1.15
*** common/video/mpeg4/tools/entropy/bitstrm.cpp	2002/03/07 23:04:01	1.14
--- common/video/mpeg4/tools/entropy/bitstrm.cpp	2002/09/10 22:41:30	1.15
***************
*** 455,460 ****
--- 455,461 ----
  CInBitStream::CInBitStream (void) 
  {
    m_pistrm = -1;
+   m_output_stuff = 0;
    init();
  }
  
Index: common/video/mpeg4/tools/entropy/inbits.h
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/mpeg4/tools/entropy/inbits.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** common/video/mpeg4/tools/entropy/inbits.h	2002/03/07 23:04:01	1.4
--- common/video/mpeg4/tools/entropy/inbits.h	2002/09/10 22:41:30	1.5
***************
*** 36,55 ****
    void set_buffer(unsigned char *bptr, uint32_t blen);
  
    int get_used_bytes(void) { return m_framebits / 8; };
!   
    uint32_t getBits(uint32_t numBits);
! 
    INLINE uint32_t peekBits(uint32_t numBits)
      {
!       int rbit;
        uint32_t b;
    
        check_buffer(numBits);
    
        rbit = 32 - m_bitcnt;
- #define _SWAP(a) ((a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3])
        b = _SWAP(m_rdptr);
!       return ((b & bit_msk[rbit]) >> (rbit-numBits));
      };
  
    int peekOneBit(uint32_t numBits);
--- 36,66 ----
    void set_buffer(unsigned char *bptr, uint32_t blen);
  
    int get_used_bytes(void) { return m_framebits / 8; };
!   int get_used_bits(void) { return m_framebits; } ;
    uint32_t getBits(uint32_t numBits);
!   void start_dump(void) { m_output_stuff = 1; };
!   void stop_dump(void) { m_output_stuff = 0; };
! #define _SWAP(a) ((a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3])
    INLINE uint32_t peekBits(uint32_t numBits)
      {
!       uint32_t rbit;
        uint32_t b;
+       uint32_t ret_value;
    
        check_buffer(numBits);
    
        rbit = 32 - m_bitcnt;
        b = _SWAP(m_rdptr);
!       if (rbit < numBits) {
! 	b <<= m_bitcnt;
! 	b |= m_rdptr[4] >> (8 - m_bitcnt);
! 	ret_value = (b >> (32 - numBits)) & bit_msk[numBits];
!       } else 
! 	ret_value = ((b & bit_msk[rbit]) >> (rbit-numBits));
!       if (m_output_stuff != 0) {
! 	printf("peek %d %x\n", numBits, ret_value);
!       }
!       return ret_value;
      };
  
    int peekOneBit(uint32_t numBits);
***************
*** 87,93 ****
    int m_framebits_max;
    uint32_t m_orig_buflen;
    int m_bookmark;
! 
    INLINE void check_buffer (int n) {
      int cmp;
        
--- 98,104 ----
    int m_framebits_max;
    uint32_t m_orig_buflen;
    int m_bookmark;
!   int m_output_stuff;
    INLINE void check_buffer (int n) {
      int cmp;
        
***************
*** 111,116 ****
--- 122,130 ----
        }
  
        m_framebits += n;
+       if (m_output_stuff != 0) {
+ 	printf("Used %d\n", n);
+       }
      };
    void read_ifstream_buffer(void);
  };
Index: common/video/mpeg4/type/vop.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/common/video/mpeg4/type/vop.cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** common/video/mpeg4/type/vop.cpp	2001/04/19 18:32:09	1.2
--- common/video/mpeg4/type/vop.cpp	2002/08/08 16:42:18	1.3
***************
*** 71,77 ****
  
  	// allocate pixels and initialize
  	if (m_rc.empty()) return;
! 	m_ppxl = new CPixel [m_rc.area ()];
  	for (UInt i = 0; i < m_rc.area (); i++)
  		m_ppxl [i] = pxl;
  //	memset (m_ppxl, pxl, m_rc.area () * sizeof (CPixel));
--- 71,78 ----
  
  	// allocate pixels and initialize
  	if (m_rc.empty()) return;
! 	UInt area = m_rc.area();
! 	m_ppxl = new CPixel [area];
  	for (UInt i = 0; i < m_rc.area (); i++)
  		m_ppxl [i] = pxl;
  //	memset (m_ppxl, pxl, m_rc.area () * sizeof (CPixel));
Index: include/mpeg4ip_byteswap.h
===================================================================
RCS file: /vws/pan/mpeg4ip/include/mpeg4ip_byteswap.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** include/mpeg4ip_byteswap.h	2002/06/18 22:36:15	1.2
--- include/mpeg4ip_byteswap.h	2002/07/22 17:27:31	1.3
***************
*** 26,34 ****
  
  #if defined(WORDS_BIGENDIAN)
  /* All bigendian systems are fine, just ignore the swaps. */  
! #define B2N_16(x) (void)(x)
! #define B2N_32(x) (void)(x)
! #define B2N_64(x) (void)(x)
  
  #else 
  
--- 26,34 ----
  
  #if defined(WORDS_BIGENDIAN)
  /* All bigendian systems are fine, just ignore the swaps. */  
! #define B2N_16(x) (x)
! #define B2N_32(x) (x)
! #define B2N_64(x) (x)
  
  #else 
  
Index: include/systems.h
===================================================================
RCS file: /vws/pan/mpeg4ip/include/systems.h,v
retrieving revision 1.41
retrieving revision 1.43
diff -c -w -r1.41 -r1.43
*** include/systems.h	2002/06/05 18:46:35	1.41
--- include/systems.h	2002/07/30 00:00:59	1.43
***************
*** 197,203 ****
  #ifdef sun
  #include <limits.h>
  #define u_int8_t uint8_t
! #define u_int16_t uint8_t
  #define u_int32_t uint32_t
  #define u_int64_t uint64_t
  #define __STRING(expr) #expr
--- 197,203 ----
  #ifdef sun
  #include <limits.h>
  #define u_int8_t uint8_t
! #define u_int16_t uint16_t
  #define u_int32_t uint32_t
  #define u_int64_t uint64_t
  #define __STRING(expr) #expr
***************
*** 227,232 ****
--- 227,233 ----
  
  #define MALLOC_STRUCTURE(a) ((a *)malloc(sizeof(a)))
  
+ #define CHECK_AND_FREE(a) if ((a) != NULL) { free((a)); (a) = NULL;}
  #ifndef HAVE_GLIB_H
  typedef char gchar;
  typedef unsigned char guchar;
Index: include/win32_ver.h
===================================================================
RCS file: /vws/pan/mpeg4ip/include/win32_ver.h,v
retrieving revision 1.45
retrieving revision 1.49
diff -c -w -r1.45 -r1.49
*** include/win32_ver.h	2002/07/15 22:33:44	1.45
--- include/win32_ver.h	2002/09/10 22:42:46	1.49
***************
*** 1,2 ****
  #define PACKAGE "mpeg4ip"
! #define VERSION "0.9.5"
--- 1,2 ----
  #define PACKAGE "mpeg4ip"
! #define VERSION "0.9.5.4"
Index: lib/Makefile.am
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/Makefile.am,v
retrieving revision 1.14
retrieving revision 1.16
diff -c -w -r1.14 -r1.16
Index: lib/SDL/src/video/XFree86/Xv/Xv.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/SDL/src/video/XFree86/Xv/Xv.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
*** lib/SDL/src/video/XFree86/Xv/Xv.c	2002/04/22 21:38:03	1.1
--- lib/SDL/src/video/XFree86/Xv/Xv.c	2002/07/29 19:56:02	1.2
***************
*** 269,274 ****
--- 269,275 ----
  
    UnlockDisplay(dpy);
    SyncHandle();
+   Xfree(buffer);
  
    return (Success);
  }
Index: lib/SDL/src/video/x11/SDL_x11yuv.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/SDL/src/video/x11/SDL_x11yuv.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** lib/SDL/src/video/x11/SDL_x11yuv.c	2002/04/22 21:38:06	1.4
--- lib/SDL/src/video/x11/SDL_x11yuv.c	2002/07/29 19:56:02	1.5
***************
*** 36,42 ****
  #include <sys/shm.h>
  #include <X11/extensions/XShm.h>
  #include <XFree86/extensions/Xvlib.h>
! 
  #include "SDL_error.h"
  #include "SDL_video.h"
  #include "SDL_x11yuv_c.h"
--- 36,42 ----
  #include <sys/shm.h>
  #include <X11/extensions/XShm.h>
  #include <XFree86/extensions/Xvlib.h>
! #include <X11/Xlibint.h>
  #include "SDL_error.h"
  #include "SDL_video.h"
  #include "SDL_x11yuv_c.h"
***************
*** 123,131 ****
--- 123,138 ----
  						}
  					}
  				}
+ 				Xfree(formats);
+ 			}
  		}
  	}
+ 		
+ 	for ( i=0; i < adaptors; ++i ) {
+ 	  if (ainfo[i].name != NULL) Xfree(ainfo[i].name);
+ 	  if (ainfo[i].formats != NULL) Xfree(ainfo[i].formats);
  	}
+ 	Xfree(ainfo);
  	if ( xv_port == -1 ) {
  		SDL_SetError("No available video ports for requested format");
  		return(NULL);
Index: lib/config_file/config_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/config_file/config_file.cpp,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -w -r1.7 -r1.8
*** lib/config_file/config_file.cpp	2002/02/27 00:28:07	1.7
--- lib/config_file/config_file.cpp	2002/08/13 23:41:39	1.8
***************
*** 165,171 ****
      len = strlen(m_config_var[ix].config_name);
      if (strncasecmp(ptr, 
  		    m_config_var[ix].config_name, 
! 		    len) == 0) {
        ptr += len;
        return (ptr);
      }
--- 165,173 ----
      len = strlen(m_config_var[ix].config_name);
      if (strncasecmp(ptr, 
  		    m_config_var[ix].config_name, 
! 		    len) == 0 &&
! 	(isspace(*(ptr + len)) ||
! 	 *(ptr + len) == '=')) {
        ptr += len;
        return (ptr);
      }
Index: lib/mp4av/adts.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/adts.cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** lib/mp4av/adts.cpp	2002/07/09 22:12:04	1.2
--- lib/mp4av/adts.cpp	2002/09/09 21:53:28	1.3
***************
*** 252,263 ****
  		adts.PutBits(channels, 3);		// channel_configuration
  		adts.PutBits(0, 1);				// original
  		adts.PutBits(0, 1);				// home
  		adts.PutBits(0, 2);				// emphasis
  		adts.PutBits(0, 1);				// copyright_id
  		adts.PutBits(0, 1);				// copyright_id_start
  		adts.PutBits(*pAdtsDataLength, 13);	// aac_frame_length
  		adts.PutBits(0x7FF, 11);		// adts_buffer_fullness
! 		adts.PutBits(1, 2);				// num_raw_data_blocks
  
  		// copy audio frame data
  		adts.PutBytes(pData, dataLength);
--- 252,265 ----
  		adts.PutBits(channels, 3);		// channel_configuration
  		adts.PutBits(0, 1);				// original
  		adts.PutBits(0, 1);				// home
+ 		if (!isMpeg2) {
  			adts.PutBits(0, 2);				// emphasis
+ 		}
  		adts.PutBits(0, 1);				// copyright_id
  		adts.PutBits(0, 1);				// copyright_id_start
  		adts.PutBits(*pAdtsDataLength, 13);	// aac_frame_length
  		adts.PutBits(0x7FF, 11);		// adts_buffer_fullness
! 		adts.PutBits(0, 2);				// num_raw_data_blocks
  
  		// copy audio frame data
  		adts.PutBytes(pData, dataLength);
Index: lib/mp4av/audio_hinters.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/audio_hinters.cpp,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -w -r1.3 -r1.4
*** lib/mp4av/audio_hinters.cpp	2002/03/06 00:10:41	1.3
--- lib/mp4av/audio_hinters.cpp	2002/09/10 22:15:03	1.4
***************
*** 172,174 ****
--- 172,201 ----
  	return true;
  }
  
+ MP4Duration MP4AV_GetAudioSampleDuration(
+ 	MP4FileHandle mp4File, 
+ 	MP4TrackId mediaTrackId)
+ {
+ 	MP4SampleId sampleId = 1;
+ 	MP4SampleId numSamples = 
+ 		MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
+ 
+ 	// find first non-zero size sample
+ 	// we need to search in case an empty audio sample has been added
+ 	// at the beginning of the track to achieve sync with video
+ 	for (; sampleId <= numSamples; sampleId++) {
+ 		if (MP4GetSampleSize(mp4File, mediaTrackId, sampleId) > 0) {
+ 			break;
+ 		}
+ 	}
+ 	if (sampleId >= numSamples) {
+ 		return MP4_INVALID_DURATION;
+ 	}
+ 
+ 	// get sample duration
+ 	return MP4GetSampleDuration(mp4File, mediaTrackId, sampleId);
+ 
+ 	// OPTION may want to scan all non-zero sized samples
+ 	// and check that sample durations are +/-1 the same value
+ }
+ 
Index: lib/mp4av/audio_hinters.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/audio_hinters.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** lib/mp4av/audio_hinters.h	2002/03/06 00:10:42	1.2
--- lib/mp4av/audio_hinters.h	2002/09/10 22:15:03	1.3
***************
*** 70,74 ****
--- 70,78 ----
  	u_int16_t maxPayloadSize,
  	MP4AV_AudioConcatenator pConcatenator);
  
+ MP4Duration MP4AV_GetAudioSampleDuration(
+ 	MP4FileHandle mp4File, 
+ 	MP4TrackId mediaTrackId);
+ 
  #endif /* __AUDIO_HINTERS_INCLUDED__ */ 
  
Index: lib/mp4av/mp3.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/mp3.cpp,v
retrieving revision 1.10
retrieving revision 1.11
diff -c -w -r1.10 -r1.11
*** lib/mp4av/mp3.cpp	2002/07/01 20:07:16	1.10
--- lib/mp4av/mp3.cpp	2002/07/25 17:05:23	1.11
***************
*** 203,208 ****
--- 203,229 ----
  	return 576;
  }
  
+ extern "C" u_int16_t MP4AV_Mp3GetBitRate (MP4AV_Mp3Header hdr)
+ {
+   u_int8_t version = MP4AV_Mp3GetHdrVersion(hdr);
+   u_int8_t layer = MP4AV_Mp3GetHdrLayer(hdr);
+   u_int8_t bitRateIndex1;
+   u_int8_t bitRateIndex2 = (hdr >> 12) & 0xF;
+ 
+   if (version == 3) {
+     /* MPEG-1 */
+     bitRateIndex1 = layer - 1;
+   } else {
+     /* MPEG-2 or MPEG-2.5 */
+     if (layer == 3) {
+       /* Layer I */
+       bitRateIndex1 = 4;
+     } else {
+       bitRateIndex1 = 3;
+     }
+   }
+   return Mp3BitRates[bitRateIndex1][bitRateIndex2-1];
+ }
  /*
   * compute MP3 frame size
   */
Index: lib/mp4av/mp4av_mp3.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/mp4av_mp3.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -w -r1.7 -r1.8
*** lib/mp4av/mp4av_mp3.h	2002/06/20 20:36:47	1.7
--- lib/mp4av/mp4av_mp3.h	2002/07/25 17:05:23	1.8
***************
*** 50,55 ****
--- 50,57 ----
  
  u_int16_t MP4AV_Mp3GetSamplingWindow(u_int16_t samplingRate);
  
+ u_int16_t MP4AV_Mp3GetBitRate(MP4AV_Mp3Header hdr);
+ 
  u_int16_t MP4AV_Mp3GetFrameSize(MP4AV_Mp3Header hdr);
  
  u_int16_t MP4AV_Mp3GetAduOffset(const u_int8_t* pFrame, u_int32_t frameSize);
Index: lib/mp4av/mp4av_mpeg3.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/mp4av_mpeg3.h,v
retrieving revision 1.3
retrieving revision 1.5
diff -c -w -r1.3 -r1.5
*** lib/mp4av/mp4av_mpeg3.h	2002/06/18 22:36:47	1.3
--- lib/mp4av/mp4av_mpeg3.h	2002/07/25 23:46:48	1.5
***************
*** 26,33 ****
  #endif
  
    int MP4AV_Mpeg3ParseSeqHdr(uint8_t *pbuffer, uint32_t buflen, 
  			      uint32_t *height, uint32_t *width, 
! 			      double *frame_rate);
  
    int MP4AV_Mpeg3PictHdrType(uint8_t *pbuffer);
  
--- 26,34 ----
  #endif
  
    int MP4AV_Mpeg3ParseSeqHdr(uint8_t *pbuffer, uint32_t buflen, 
+ 			     int *have_mpeg2,
  			      uint32_t *height, uint32_t *width, 
! 			      double *frame_rate, double *bitrate);
  
    int MP4AV_Mpeg3PictHdrType(uint8_t *pbuffer);
  
Index: lib/mp4av/mpeg3.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/mpeg3.cpp,v
retrieving revision 1.3
retrieving revision 1.6
diff -c -w -r1.3 -r1.6
*** lib/mp4av/mpeg3.cpp	2002/06/18 22:36:47	1.3
--- lib/mp4av/mpeg3.cpp	2002/07/25 23:46:48	1.6
***************
*** 46,76 ****
  #define MPEG3_SEQUENCE_START_CODE        0x000001b3
  #define MPEG3_PICTURE_START_CODE         0x00000100
  #define MPEG3_GOP_START_CODE             0x000001b8
  
  extern "C" int MP4AV_Mpeg3ParseSeqHdr (uint8_t *pbuffer,
  				       uint32_t buflen,
  				       uint32_t *height,
  				       uint32_t *width,
! 				       double *frame_rate)
  {
    uint32_t framerate_code;
  #if 1
!   uint32_t value, ix;
    buflen -= 6;
    for (ix = 0; ix < buflen; ix++, pbuffer++) {
!     value = (pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) | 
        pbuffer[3];
  
!     if (value == MPEG3_SEQUENCE_START_CODE) {
        pbuffer += sizeof(uint32_t);
!       *height = (pbuffer[0] << 4) | ((pbuffer[1] >> 4) &0xf);
!       *width = ((pbuffer[1] & 0xf) << 4) | pbuffer[2];
        framerate_code = pbuffer[3] & 0xf;
        *frame_rate = mpeg3_frame_rate_table[framerate_code];
!       return 0;
      }
    }
!   return -1;
  
  #else
    // if you want to do the whole frame
--- 46,122 ----
  #define MPEG3_SEQUENCE_START_CODE        0x000001b3
  #define MPEG3_PICTURE_START_CODE         0x00000100
  #define MPEG3_GOP_START_CODE             0x000001b8
+ #define MPEG3_EXT_START_CODE             0x000001b5
  
+ #define SEQ_ID 1
  extern "C" int MP4AV_Mpeg3ParseSeqHdr (uint8_t *pbuffer,
  				       uint32_t buflen,
+ 				       int *have_mpeg2,
  				       uint32_t *height,
  				       uint32_t *width,
! 				       double *frame_rate,
! 				       double *bitrate)
  {
    uint32_t framerate_code;
+   uint32_t bitrate_int;
+   uint32_t bitrate_ext;
  #if 1
!   uint32_t scode, ix;
!   int found = -1;
!   *have_mpeg2 = 0;
    buflen -= 6;
+   bitrate_int = 0;
    for (ix = 0; ix < buflen; ix++, pbuffer++) {
!     scode = (pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) | 
        pbuffer[3];
  
!     if (scode == MPEG3_SEQUENCE_START_CODE) {
        pbuffer += sizeof(uint32_t);
!       *width = (pbuffer[0]);
!       *width <<= 4;
!       *width |= ((pbuffer[1] >> 4) &0xf);
!       *height = (pbuffer[1] & 0xf);
!       *height <<= 8;
!       *height |= pbuffer[2];
        framerate_code = pbuffer[3] & 0xf;
        *frame_rate = mpeg3_frame_rate_table[framerate_code];
!       // 18 bits
!       bitrate_int = (pbuffer[4] << 10) | 
! 	(pbuffer[5] << 2) | 
! 	((pbuffer[6] >> 6) & 0x3);
!       *bitrate = bitrate_int;
!       *bitrate *= 400.0;
!       ix += sizeof(uint32_t) + 7;
!       pbuffer += 7;
!       found = 0;
!     } else if (found == 0) {
!       if (scode == MPEG3_EXT_START_CODE) {
! 	pbuffer += sizeof(uint32_t);
! 	ix += sizeof(uint32_t);
! 	switch ((pbuffer[0] >> 4) & 0xf) {
! 	case SEQ_ID:
! 	  *have_mpeg2 = 1;
! 	  *height = ((pbuffer[1] & 0x1) << 13) | 
! 	    ((pbuffer[2] & 0x80) << 5) |
! 	    (*height & 0x0fff);
! 	  *width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);
! 	  bitrate_ext = (pbuffer[2] & 0x1f) << 7;
! 	  bitrate_ext |= (pbuffer[3] >> 1) & 0x7f;
! 	  bitrate_int |= (bitrate_ext << 18);
! 	  *bitrate = bitrate_int;
! 	  *bitrate *= 400.0;
! 	  break;
! 	default:
! 	  break;
! 	}
! 	pbuffer++;
! 	ix++;
!       } else if (scode == MPEG3_PICTURE_START_CODE) {
! 	return found;
!       }
      }
    }
!   return found;
  
  #else
    // if you want to do the whole frame
Index: lib/mp4av/mpeg4.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/mpeg4.cpp,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -w -r1.7 -r1.8
*** lib/mp4av/mpeg4.cpp	2002/07/09 22:12:04	1.7
--- lib/mp4av/mpeg4.cpp	2002/09/03 20:50:13	1.8
***************
*** 363,368 ****
--- 363,393 ----
  	return true;
  }
  
+ static bool Mpeg4ParseShortHeaderVop(
+ 	u_int8_t* pVopBuf, 
+ 	u_int32_t vopSize,
+ 	u_char* pVopType)
+ {
+ 	CMemoryBitstream vop;
+ 
+ 	vop.SetBytes(pVopBuf, vopSize);
+ 
+ 	try {
+ 		// skip start code, temporal ref, and into type
+ 		vop.SkipBits(22 + 8 + 5 + 3);	
+ 		if (vop.GetBits(1) == 0) {
+ 			*pVopType = 'I';
+ 		} else {
+ 			*pVopType = 'P';
+ 		}
+ 	}
+ 	catch (int e) {
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
  extern "C" bool MP4AV_Mpeg4ParseVop(
  	u_int8_t* pVopBuf, 
  	u_int32_t vopSize,
***************
*** 526,537 ****
  
  extern "C" u_char MP4AV_Mpeg4GetVopType(u_int8_t* pVopBuf, u_int32_t vopSize)
  {
! 	u_char vopType;
  
! 	if (MP4AV_Mpeg4ParseVop(pVopBuf, vopSize, &vopType, 0, 0, NULL)) {
  		return vopType;
  	}
  
! 	return 0;
  }
  
--- 551,572 ----
  
  extern "C" u_char MP4AV_Mpeg4GetVopType(u_int8_t* pVopBuf, u_int32_t vopSize)
  {
! 	u_char vopType = 0;
  
! 	if (vopSize <= 4) {
  		return vopType;
  	}
  
! 	if (pVopBuf[0] == 0 && pVopBuf[1] == 0 
! 	  && (pVopBuf[2] & 0xFC) == 0x08 && (pVopBuf[3] & 0x03) == 0x02) {
! 		// H.263, (MPEG-4 short header mode)
! 		Mpeg4ParseShortHeaderVop(pVopBuf, vopSize, &vopType);
! 		
! 	} else {
! 		// MPEG-4 (normal mode)
! 		MP4AV_Mpeg4ParseVop(pVopBuf, vopSize, &vopType, 0, 0, NULL);
! 	}
! 
! 	return vopType;
  }
  
Index: lib/mp4av/rfc2250.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/rfc2250.cpp,v
retrieving revision 1.6
retrieving revision 1.8
diff -c -w -r1.6 -r1.8
*** lib/mp4av/rfc2250.cpp	2002/07/01 20:07:16	1.6
--- lib/mp4av/rfc2250.cpp	2002/09/10 22:15:03	1.8
***************
*** 37,60 ****
  		return false;
  	}
  
! 	MP4TrackId hintTrackId =
! 		MP4AddHintTrack(mp4File, mediaTrackId);
  
! 	if (hintTrackId == MP4_INVALID_TRACK_ID) {
  		return false;
  	}
  
! 	u_int32_t numSamples =
! 		MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
  
! 	if (numSamples == 0) {
  		return false;
  	}
  
  	MP4Duration sampleDuration = 
! 		MP4GetTrackFixedSampleDuration(mp4File, mediaTrackId);
  
  	if (sampleDuration == MP4_INVALID_DURATION) {
  		return false;
  	}
  
--- 37,67 ----
  		return false;
  	}
  
! 	u_int32_t numSamples =
! 		MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
  
! 	if (numSamples == 0) {
  		return false;
  	}
  
! 	u_int8_t audioType =
! 		MP4GetTrackAudioType(mp4File, mediaTrackId);
  
! 	if (!MP4_IS_MP3_AUDIO_TYPE(audioType)) {
  		return false;
  	}
  
  	MP4Duration sampleDuration = 
! 		MP4AV_GetAudioSampleDuration(mp4File, mediaTrackId);
  
  	if (sampleDuration == MP4_INVALID_DURATION) {
+ 		return false;
+ 	}
+ 
+ 	MP4TrackId hintTrackId =
+ 		MP4AddHintTrack(mp4File, mediaTrackId);
+ 
+ 	if (hintTrackId == MP4_INVALID_TRACK_ID) {
  		return false;
  	}
  
Index: lib/mp4av/rfc3016.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/rfc3016.cpp,v
retrieving revision 1.7
retrieving revision 1.9
diff -c -w -r1.7 -r1.9
*** lib/mp4av/rfc3016.cpp	2002/07/01 20:07:16	1.7
--- lib/mp4av/rfc3016.cpp	2002/08/27 23:02:04	1.9
***************
*** 32,37 ****
--- 32,44 ----
  	MP4TrackId mediaTrackId, 
  	u_int16_t maxPayloadSize)
  {
+ 	u_int32_t numSamples = MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
+ 	u_int32_t maxSampleSize = MP4GetTrackMaxSampleSize(mp4File, mediaTrackId);
+ 	
+ 	if (numSamples == 0 || maxSampleSize == 0) {
+ 		return false;
+ 	}
+ 
  	MP4TrackId hintTrackId =
  		MP4AddHintTrack(mp4File, mediaTrackId);
  
***************
*** 72,77 ****
--- 79,85 ----
  		/* convert it into ASCII form */
  		char* sConfig = MP4BinaryToBase16(pConfig, configSize);
  		if (sConfig == NULL) {
+ 			MP4DeleteTrack(mp4File, hintTrackId);
  			return false;
  		}
  
***************
*** 92,106 ****
  
  	}
  
- 	u_int32_t numSamples = MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
- 	u_int32_t maxSampleSize = MP4GetTrackMaxSampleSize(mp4File, mediaTrackId);
- 	
- 	if (numSamples == 0 || maxSampleSize == 0) {
- 		return false;
- 	}
- 
  	u_int8_t* pSampleBuffer = (u_int8_t*)malloc(maxSampleSize);
  	if (pSampleBuffer == NULL) {
  		return false;
  	}
  
--- 100,108 ----
  
  	}
  
  	u_int8_t* pSampleBuffer = (u_int8_t*)malloc(maxSampleSize);
  	if (pSampleBuffer == NULL) {
+ 		MP4DeleteTrack(mp4File, hintTrackId);
  		return false;
  	}
  
***************
*** 118,123 ****
--- 120,126 ----
  			&renderingOffset, &isSyncSample);
  
  		if (!rc) {
+ 			MP4DeleteTrack(mp4File, hintTrackId);
  			return false;
  		}
  
***************
*** 132,137 ****
--- 135,143 ----
  
  		u_int32_t offset = 0;
  		u_int32_t remaining = sampleSize;
+ 
+ 		// TBD should scan for resync markers (if enabled in ES config)
+ 		// and packetize on those boundaries
  
  		while (remaining) {
  			bool isLastPacket = false;
Index: lib/mp4av/rfc3119.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/rfc3119.cpp,v
retrieving revision 1.8
retrieving revision 1.10
diff -c -w -r1.8 -r1.10
*** lib/mp4av/rfc3119.cpp	2002/07/09 22:12:04	1.8
--- lib/mp4av/rfc3119.cpp	2002/09/10 22:15:03	1.10
***************
*** 409,435 ****
  {
  	int rc;
  
! 	MP4TrackId hintTrackId =
! 		MP4AddHintTrack(mp4File, mediaTrackId);
  
! 	if (hintTrackId == MP4_INVALID_TRACK_ID) {
  		return false;
  	}
  
! 	u_int32_t numSamples =
! 		MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
  
! 	if (numSamples == 0) {
  		return false;
  	}
  
  	MP4Duration sampleDuration = 
! 		MP4GetSampleDuration(mp4File, mediaTrackId, 1);
  
  	if (sampleDuration == MP4_INVALID_DURATION) {
  		return false;
  	}
  
  	doInterleave = interleave;
  
  	u_int8_t payloadNumber = 0;
--- 409,449 ----
  {
  	int rc;
  
! 	u_int32_t numSamples =
! 		MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
  
! 	if (numSamples == 0) {
  		return false;
  	}
  
! 	u_int8_t audioType =
! 		MP4GetTrackAudioType(mp4File, mediaTrackId);
  
! 	if (!MP4_IS_MP3_AUDIO_TYPE(audioType)) {
  		return false;
  	}
  
  	MP4Duration sampleDuration = 
! 		MP4AV_GetAudioSampleDuration(mp4File, mediaTrackId);
  
  	if (sampleDuration == MP4_INVALID_DURATION) {
  		return false;
  	}
  
+ 	// choose 500 ms max latency
+ 	MP4Duration maxLatency = 
+ 		MP4GetTrackTimeScale(mp4File, mediaTrackId) / 2;
+ 	if (maxLatency == 0) {
+ 		return false;
+ 	}
+ 
+ 	MP4TrackId hintTrackId =
+ 		MP4AddHintTrack(mp4File, mediaTrackId);
+ 
+ 	if (hintTrackId == MP4_INVALID_TRACK_ID) {
+ 		return false;
+ 	}
+ 
  	doInterleave = interleave;
  
  	u_int8_t payloadNumber = 0;
***************
*** 437,449 ****
  	MP4SetHintTrackRtpPayload(mp4File, hintTrackId, 
  		"mpa-robust", &payloadNumber, 0);
  
- 	// choose 500 ms max latency
- 	MP4Duration maxLatency = 
- 		MP4GetTrackTimeScale(mp4File, hintTrackId) / 2;
- 	if (maxLatency == 0) {
- 		return false;
- 	}
- 
  	// load mp3 frame information into memory
  	rc = GetFrameInfo(
  		mp4File, 
--- 451,456 ----
***************
*** 452,457 ****
--- 459,465 ----
  		&pAduOffsets);
  
  	if (!rc) {
+ 		MP4DeleteTrack(mp4File, hintTrackId);
  		return false;
  	}
   
***************
*** 477,483 ****
  		// and then recompute samples per group to deal with rounding
  		samplesPerGroup = stride * samplesPerPacket;
  
! 		MP4AV_AudioInterleaveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
--- 485,491 ----
  		// and then recompute samples per group to deal with rounding
  		samplesPerGroup = stride * samplesPerPacket;
  
! 		rc = MP4AV_AudioInterleaveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
***************
*** 488,494 ****
  			MP4AV_Rfc3119Concatenator);
  
  	} else {
! 		MP4AV_AudioConsecutiveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
--- 496,502 ----
  			MP4AV_Rfc3119Concatenator);
  
  	} else {
! 		rc = MP4AV_AudioConsecutiveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
***************
*** 507,512 ****
--- 515,525 ----
  	pFrameHeaders = NULL;
  	free(pAduOffsets);
  	pAduOffsets = NULL;
+ 
+ 	if (!rc) {
+ 		MP4DeleteTrack(mp4File, hintTrackId);
+ 		return false;
+ 	}
  
  	return true;
  }
Index: lib/mp4av/rfcisma.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4av/rfcisma.cpp,v
retrieving revision 1.8
retrieving revision 1.10
diff -c -w -r1.8 -r1.10
*** lib/mp4av/rfcisma.cpp	2002/06/21 19:48:38	1.8
--- lib/mp4av/rfcisma.cpp	2002/09/10 22:15:03	1.10
***************
*** 168,180 ****
  {
  	// gather information, and check for validity
  
- 	MP4TrackId hintTrackId =
- 		MP4AddHintTrack(mp4File, mediaTrackId);
- 
- 	if (hintTrackId == MP4_INVALID_TRACK_ID) {
- 		return false;
- 	}
- 
  	u_int32_t numSamples =
  		MP4GetTrackNumberOfSamples(mp4File, mediaTrackId);
  
--- 168,173 ----
***************
*** 183,201 ****
  	}
  
  	u_int32_t timeScale =
! 		MP4GetTrackTimeScale(mp4File, hintTrackId);
  
  	if (timeScale == 0) {
  		return false;
  	}
  
- 	MP4Duration sampleDuration = 
- 		MP4GetSampleDuration(mp4File, mediaTrackId, 1);
- 
- 	if (sampleDuration == MP4_INVALID_DURATION) {
- 		return false;
- 	}
- 
  	u_int8_t audioType =
  		MP4GetTrackAudioType(mp4File, mediaTrackId);
  
--- 176,187 ----
  	}
  
  	u_int32_t timeScale =
! 		MP4GetTrackTimeScale(mp4File, mediaTrackId);
  
  	if (timeScale == 0) {
  		return false;
  	}
  
  	u_int8_t audioType =
  		MP4GetTrackAudioType(mp4File, mediaTrackId);
  
***************
*** 215,220 ****
--- 201,213 ----
  		}
  	}
  
+ 	MP4Duration sampleDuration = 
+ 		MP4AV_GetAudioSampleDuration(mp4File, mediaTrackId);
+ 
+ 	if (sampleDuration == MP4_INVALID_DURATION) {
+ 		return false;
+ 	}
+ 
  	/* get the ES configuration */
  	u_int8_t* pConfig = NULL;
  	u_int32_t configSize;
***************
*** 246,251 ****
--- 239,253 ----
  
  
  	// now add the hint track
+ 	MP4TrackId hintTrackId =
+ 		MP4AddHintTrack(mp4File, mediaTrackId);
+ 
+ 	if (hintTrackId == MP4_INVALID_TRACK_ID) {
+ 		free(sConfig);
+ 		free(sdpBuf);
+ 		return false;
+ 	}
+ 
  	u_int8_t payloadNumber = 0;
  
  	MP4SetHintTrackRtpPayload(mp4File, hintTrackId, 
***************
*** 300,309 ****
  		}
  	}
  
  	if (interleave) {
  		u_int32_t samplesPerGroup = maxLatency / sampleDuration;
  
! 		MP4AV_AudioInterleaveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
--- 302,313 ----
  		}
  	}
  
+ 	bool rc;
+ 
  	if (interleave) {
  		u_int32_t samplesPerGroup = maxLatency / sampleDuration;
  
! 		rc = MP4AV_AudioInterleaveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
***************
*** 314,320 ****
  			MP4AV_RfcIsmaConcatenator);
  
  	} else {
! 		MP4AV_AudioConsecutiveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
--- 318,324 ----
  			MP4AV_RfcIsmaConcatenator);
  
  	} else {
! 		rc = MP4AV_AudioConsecutiveHinter(
  			mp4File, 
  			mediaTrackId, 
  			hintTrackId,
***************
*** 326,331 ****
--- 330,340 ----
  			MP4GetSampleSize,
  			MP4AV_RfcIsmaConcatenator,
  			MP4AV_RfcIsmaFragmenter);
+ 	}
+ 
+ 	if (!rc) {
+ 		MP4DeleteTrack(mp4File, hintTrackId);
+ 		return false;
  	}
  
  	return true;
Index: lib/mp4v2/INTERNALS
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/INTERNALS,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -w -r1.6 -r1.7
*** lib/mp4v2/INTERNALS	2002/01/07 21:56:14	1.6
--- lib/mp4v2/INTERNALS	2002/09/04 20:42:53	1.7
***************
*** 3,9 ****
  MP4V2 LIBRARY INTERNALS
  =======================
  
! This document provides an overview of the interals of the mp4v2 library 
  to aid those who wish to modify and extend it. Before reading this document,
  I recommend familiarizing yourself with the MP4 (or Quicktime) file format 
  standard and the mp4v2 library API. The API is described in a set of man pages
--- 3,9 ----
  MP4V2 LIBRARY INTERNALS
  =======================
  
! This document provides an overview of the internals of the mp4v2 library 
  to aid those who wish to modify and extend it. Before reading this document,
  I recommend familiarizing yourself with the MP4 (or Quicktime) file format 
  standard and the mp4v2 library API. The API is described in a set of man pages
Index: lib/mp4v2/TODO
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/TODO,v
retrieving revision 1.31
retrieving revision 1.32
diff -c -w -r1.31 -r1.32
*** lib/mp4v2/TODO	2002/05/28 19:26:32	1.31
--- lib/mp4v2/TODO	2002/07/19 21:44:41	1.32
***************
*** 1,11 ****
  
! Extended format (v2) support
  
! Means to dump all possible atoms/properties with types
  
! Wrap printf's for verbosity - see example is player/lib/http/http_util.c
  
! Distinguish cases of no ES Config and error parsing esds
! 
! Improve error recovery when length of atom/descriptor is larger than parent/file, resync on parent.
  
--- 1,9 ----
  
! Add ability to create samples referenced in multiple tracks
  
! Add ability to create atoms/properties via set or add operations
  
! Exploit extended format (ISO v2)
  
! List all possible atoms/properties with types
  
Index: lib/mp4v2/atoms.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/atoms.h,v
retrieving revision 1.15
retrieving revision 1.16
diff -c -w -r1.15 -r1.16
*** lib/mp4v2/atoms.h	2001/10/13 07:02:43	1.15
--- lib/mp4v2/atoms.h	2002/07/19 21:44:41	1.16
***************
*** 22,27 ****
--- 22,34 ----
  #ifndef __MP4_ATOMS_INCLUDED__
  #define __MP4_ATOMS_INCLUDED__
  
+ // declare all the atom subclasses
+ // i.e. spare us atom_xxxx.h for all the atoms
+ //
+ // The majority of atoms just need their own constructor declared
+ // Some atoms have a few special needs
+ // A small minority of atoms need lots of special handling
+ 
  class MP4RootAtom : public MP4Atom {
  public:
  	MP4RootAtom();
Index: lib/mp4v2/mp4.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/mp4.h,v
retrieving revision 1.57
retrieving revision 1.59
diff -c -w -r1.57 -r1.59
*** lib/mp4v2/mp4.h	2002/07/15 18:00:18	1.57
--- lib/mp4v2/mp4.h	2002/08/20 15:32:27	1.59
***************
*** 136,141 ****
--- 136,144 ----
  #define MP4_PCM16_AUDIO_TYPE			0xE0	/* a private definition */
  #define MP4_VORBIS_AUDIO_TYPE			0xE1	/* a private definition */
  #define MP4_AC3_AUDIO_TYPE				0xE2	/* a private definition */
+ #define MP4_ALAW_AUDIO_TYPE				0xE3	/* a private definition */
+ #define MP4_ULAW_AUDIO_TYPE				0xE4	/* a private definition */
+ #define MP4_G723_AUDIO_TYPE                             0xE5    /* a private definition */
  
  /* MP4 MPEG-4 Audio types from 14496-3 Table 1.5.1 */
  #define MP4_MPEG4_INVALID_AUDIO_TYPE		0
***************
*** 183,190 ****
  #define MP4_JPEG_VIDEO_TYPE				0x6C
  #define MP4_PRIVATE_VIDEO_TYPE			0xD0
  #define MP4_YUV12_VIDEO_TYPE			0xF0	/* a private definition */
! #define MP4_H26L_VIDEO_TYPE				0xF1	/* a private definition */
  #define MP4_H263_VIDEO_TYPE				0xF2	/* a private definition */
  
  /* MP4 Video type utilities */
  #define MP4_IS_MPEG1_VIDEO_TYPE(type) \
--- 186,194 ----
  #define MP4_JPEG_VIDEO_TYPE				0x6C
  #define MP4_PRIVATE_VIDEO_TYPE			0xD0
  #define MP4_YUV12_VIDEO_TYPE			0xF0	/* a private definition */
! #define MP4_H264_VIDEO_TYPE				0xF1	/* a private definition */
  #define MP4_H263_VIDEO_TYPE				0xF2	/* a private definition */
+ #define MP4_H261_VIDEO_TYPE				0xF3	/* a private definition */
  
  /* MP4 Video type utilities */
  #define MP4_IS_MPEG1_VIDEO_TYPE(type) \
Index: lib/mp4v2/mp4common.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/mp4common.h,v
retrieving revision 1.11
retrieving revision 1.12
diff -c -w -r1.11 -r1.12
*** lib/mp4v2/mp4common.h	2001/09/26 23:53:06	1.11
--- lib/mp4v2/mp4common.h	2002/07/19 21:44:41	1.12
***************
*** 22,27 ****
--- 22,31 ----
  #ifndef __MP4_COMMON_INCLUDED__
  #define __MP4_COMMON_INCLUDED__
  
+ // common includes for everything 
+ // with an internal view of the library
+ // i.e. all the .cpp's just #include "mp4common.h"
+ 
  #include "mpeg4ip.h"
  
  #include "mp4.h"
Index: lib/mp4v2/mp4info.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/mp4info.cpp,v
retrieving revision 1.3
retrieving revision 1.5
diff -c -w -r1.3 -r1.5
*** lib/mp4v2/mp4info.cpp	2002/07/08 19:42:16	1.3
--- lib/mp4v2/mp4info.cpp	2002/08/21 22:11:21	1.5
***************
*** 51,56 ****
--- 51,59 ----
  		MP4_MPEG1_AUDIO_TYPE,			// 0x6B
  		MP4_PCM16_AUDIO_TYPE,
  		MP4_VORBIS_AUDIO_TYPE,
+ 		MP4_ALAW_AUDIO_TYPE,
+ 		MP4_ULAW_AUDIO_TYPE,
+ 		MP4_G723_AUDIO_TYPE,
  	};
  	static const char* mpegAudioNames[] = {
  		"MPEG-2 AAC Main",
***************
*** 60,65 ****
--- 63,71 ----
  		"MPEG-1 (MP3)",
  		"PCM16",
  		"OGG VORBIS",
+ 		"G.711 aLaw",
+ 		"G.711 uLaw",
+ 		"G.723.1",
  	};
  	static u_int8_t numMpegAudioTypes = 
  		sizeof(mpegAudioTypes) / sizeof(u_int8_t);
***************
*** 148,154 ****
  		MP4_MPEG1_VIDEO_TYPE,			// 0x6A
  		MP4_JPEG_VIDEO_TYPE,			// 0x6C
  		MP4_YUV12_VIDEO_TYPE,			
! 		MP4_H26L_VIDEO_TYPE			
  	};
  	static const char* mpegVideoNames[] = {
  		"MPEG-2 Simple",
--- 154,162 ----
  		MP4_MPEG1_VIDEO_TYPE,			// 0x6A
  		MP4_JPEG_VIDEO_TYPE,			// 0x6C
  		MP4_YUV12_VIDEO_TYPE,			
! 		MP4_H264_VIDEO_TYPE,
! 		MP4_H263_VIDEO_TYPE,		
! 		MP4_H261_VIDEO_TYPE,
  	};
  	static const char* mpegVideoNames[] = {
  		"MPEG-2 Simple",
***************
*** 160,166 ****
  		"MPEG-1",
  		"JPEG",
  		"YUV12",
! 		"H26L"
  	};
  	static u_int8_t numMpegVideoTypes = 
  		sizeof(mpegVideoTypes) / sizeof(u_int8_t);
--- 168,176 ----
  		"MPEG-1",
  		"JPEG",
  		"YUV12",
! 		"H.264",
! 		"H.263",
! 		"H.261",
  	};
  	static u_int8_t numMpegVideoTypes = 
  		sizeof(mpegVideoTypes) / sizeof(u_int8_t);
Index: lib/mp4v2/mp4property.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/mp4property.cpp,v
retrieving revision 1.37
retrieving revision 1.38
diff -c -w -r1.37 -r1.38
*** lib/mp4v2/mp4property.cpp	2002/07/03 00:09:38	1.37
--- lib/mp4v2/mp4property.cpp	2002/08/16 23:50:10	1.38
***************
*** 195,201 ****
  	}
  	Indent(pFile, indent);
  	fprintf(pFile, 
! #ifdef WIN32
  		"%s = "LLU" (0x%016I64x)\n", 
  #else
  		"%s = "LLU" (0x%016llx)\n", 
--- 195,201 ----
  	}
  	Indent(pFile, indent);
  	fprintf(pFile, 
! #ifdef _WIN32
  		"%s = "LLU" (0x%016I64x)\n", 
  #else
  		"%s = "LLU" (0x%016llx)\n", 
***************
*** 234,240 ****
  		hexWidth++;
  	}
  	fprintf(pFile, 
! #ifdef WIN32
  		"%s = "LLU" (0x%0*I64x) <%u bits>\n", 
  #else
  		"%s = "LLU" (0x%0*llx) <%u bits>\n", 
--- 234,240 ----
  		hexWidth++;
  	}
  	fprintf(pFile, 
! #ifdef _WIN32
  		"%s = "LLU" (0x%0*I64x) <%u bits>\n", 
  #else
  		"%s = "LLU" (0x%0*llx) <%u bits>\n", 
Index: lib/mp4v2/mp4track.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/mp4track.cpp,v
retrieving revision 1.51
retrieving revision 1.52
diff -c -w -r1.51 -r1.52
*** lib/mp4v2/mp4track.cpp	2002/07/09 20:43:50	1.51
--- lib/mp4v2/mp4track.cpp	2002/08/08 19:51:17	1.52
***************
*** 514,521 ****
--- 514,528 ----
  {
  	// for first sample
  	if (sampleId == 1) {
+ 		if (numBytes > 0) {
  			// presume sample size is fixed
  			m_pStszFixedSampleSizeProperty->SetValue(numBytes); 
+ 		} else {
+ 			// special case of first sample is zero bytes in length
+ 			// leave m_pStszFixedSampleSizeProperty at 0
+ 			// start recording variable sample sizes
+ 			m_pStszSampleSizeProperty->AddValue(0);
+ 		}
  
  	} else { // sampleId > 1
  		u_int32_t fixedSampleSize = 
Index: lib/mp4v2/util/mp4extract.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mp4v2/util/mp4extract.cpp,v
retrieving revision 1.16
retrieving revision 1.17
diff -c -w -r1.16 -r1.17
*** lib/mp4v2/util/mp4extract.cpp	2002/07/08 19:27:38	1.16
--- lib/mp4v2/util/mp4extract.cpp	2002/08/16 23:49:14	1.17
***************
*** 187,193 ****
--- 187,198 ----
  {
  	char outFileName[PATH_MAX];
  	int outFd = -1;
+ 	int openFlags = O_WRONLY | O_CREAT | O_TRUNC;
  
+ #ifdef _WIN32
+ 	openFlags |= O_BINARY;
+ #endif
+ 
  	if (!sampleMode) {
  		if (dstFileName == NULL) {
  			snprintf(outFileName, sizeof(outFileName), 
***************
*** 197,204 ****
  				"%s", dstFileName);
  		}
  
! 		outFd = open(outFileName, 
! 			O_WRONLY | O_CREAT | O_TRUNC, 0644);
  		if (outFd == -1) {
  			fprintf(stderr, "%s: can't open %s: %s\n",
  				ProgName, outFileName, strerror(errno));
--- 202,208 ----
  				"%s", dstFileName);
  		}
  
! 		outFd = open(outFileName, openFlags, 0644);
  		if (outFd == -1) {
  			fprintf(stderr, "%s: can't open %s: %s\n",
  				ProgName, outFileName, strerror(errno));
***************
*** 236,243 ****
  			snprintf(outFileName, sizeof(outFileName), "%s.t%u.s%u",
  				Mp4FileName, trackId, sampleId);
  
! 			outFd = open(outFileName, 
! 				O_WRONLY | O_CREAT | O_TRUNC, 0644);
  
  			if (outFd == -1) {
  				fprintf(stderr, "%s: can't open %s: %s\n",
--- 240,246 ----
  			snprintf(outFileName, sizeof(outFileName), "%s.t%u.s%u",
  				Mp4FileName, trackId, sampleId);
  
! 			outFd = open(outFileName, openFlags, 0644);
  
  			if (outFd == -1) {
  				fprintf(stderr, "%s: can't open %s: %s\n",
Index: lib/mpeg2t/Makefile.am
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/Makefile.am,v
retrieving revision 1.4
retrieving revision 1.6
diff -c -w -r1.4 -r1.6
*** lib/mpeg2t/Makefile.am	2002/06/28 22:31:26	1.4
--- lib/mpeg2t/Makefile.am	2002/08/13 16:21:23	1.6
***************
*** 8,14 ****
  	mpeg2t_video.c \
  	mpeg2t_util.c 
  
! INCLUDES = -I$(top_builddir)/include -I$(top_builddir)/lib -I$(top_builddir)/lib/mp4av -I$(top_builddir)/lib/mp4v2
  AM_CFLAGS = -DIPTV_COMPATIBLE -D_REENTRANT @BILLS_CWARNINGS@
  AM_CXXFLAGS = -D_REENTRANT @BILLS_CPPWARNINGS@
  
--- 8,14 ----
  	mpeg2t_video.c \
  	mpeg2t_util.c 
  
! INCLUDES = -I$(top_builddir)/include -I$(top_builddir)/lib -I$(top_builddir)/lib/mp4av -I$(top_builddir)/lib/mp4v2 -I$(top_builddir)/lib/SDL/include
  AM_CFLAGS = -DIPTV_COMPATIBLE -D_REENTRANT @BILLS_CWARNINGS@
  AM_CXXFLAGS = -D_REENTRANT @BILLS_CPPWARNINGS@
  
***************
*** 17,20 ****
  mpeg2t_test_SOURCES = test.cpp
  mpeg2t_test_LDADD = libmpeg2_transport.la \
  	$(top_builddir)/lib/mp4av/libmp4av.la \
! 	$(top_builddir)/lib/mp4v2/libmp4v2.la
--- 17,21 ----
  mpeg2t_test_SOURCES = test.cpp
  mpeg2t_test_LDADD = libmpeg2_transport.la \
  	$(top_builddir)/lib/mp4av/libmp4av.la \
! 	$(top_builddir)/lib/mp4v2/libmp4v2.la \
! 	@SDL_LIBS@
Index: lib/mpeg2t/mpeg2_transport.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/mpeg2_transport.c,v
retrieving revision 1.7
retrieving revision 1.14
diff -c -w -r1.7 -r1.14
*** lib/mpeg2t/mpeg2_transport.c	2002/07/05 22:03:53	1.7
--- lib/mpeg2t/mpeg2_transport.c	2002/07/31 22:43:21	1.14
***************
*** 1,8 ****
--- 1,31 ----
+ /*
+  * The contents of this file are subject to the Mozilla Public
+  * License Version 1.1 (the "License"); you may not use this file
+  * except in compliance with the License. You may obtain a copy of
+  * the License at http://www.mozilla.org/MPL/
+  * 
+  * Software distributed under the License is distributed on an "AS
+  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+  * implied. See the License for the specific language governing
+  * rights and limitations under the License.
+  * 
+  * The Original Code is MPEG4IP.
+  * 
+  * The Initial Developer of the Original Code is Cisco Systems Inc.
+  * Portions created by Cisco Systems Inc. are
+  * Copyright (C) Cisco Systems Inc. 2002.  All Rights Reserved.
+  * 
+  * Contributor(s): 
+  *		Bill May (wmay@cisco.com)
+  */
+ /* mpeg2_transport.c - mpeg2 transport stream decoding */
  
  #include "mpeg4ip.h"
  #include "mpeg2_transport.h"
  #include <assert.h>
  #include "mpeg2t_private.h"
+ 
+ //#define DUMP_ADAPTION_CONTOL 1
  #define DEBUG 1
  #ifdef DEBUG
  #define CHECK_MP2T_HEADER assert(*pHdr == MPEG2T_SYNC_BYTE)
***************
*** 10,15 ****
--- 33,41 ----
  #define CHECK_MP2T_HEADER 
  #endif
  
+ /*
+  * mpeg2 transport layer header routines.
+  */
  uint32_t mpeg2t_find_sync_byte (const uint8_t *buffer, uint32_t buflen)
  {
    uint32_t offset;
***************
*** 65,74 ****
--- 91,107 ----
    return (pHdr[3] & 0xf);
  }
  
+ /*
+  * mpeg2t_transport_payload_start
+  * find the start of the payload data, skipping any adaptation data
+  */
  const uint8_t *mpeg2t_transport_payload_start (const uint8_t *pHdr,
  					       uint32_t *payload_len)
  {
    uint32_t adaption_control;
+ #if DUMP_ADAPTION_CONTROL
+   int ix;
+ #endif
    CHECK_MP2T_HEADER;
  
    if (mpeg2t_transport_error_indicator(pHdr) != 0) {
***************
*** 88,93 ****
--- 121,138 ----
        return NULL;
      }
      *payload_len = 183 - pHdr[4];
+ #if DUMP_ADAPTION_CONTROL
+     mpeg2t_message(LOG_DEBUG, "adaptation control - len %d", pHdr[4]);
+     for (ix = 0; ix < pHdr[4]; ix += 4) {
+       mpeg2t_message(LOG_DEBUG, "%d - %02x %02x %02x %02x", 
+ 		     ix, 
+ 		     pHdr[4 + ix],
+ 		     pHdr[5 + ix],
+ 		     pHdr[6 + ix],
+ 		     pHdr[7 + ix]);
+     }
+ #endif
+     
      return pHdr + 5 + pHdr[4];
    }
  
***************
*** 95,100 ****
--- 140,151 ----
    return NULL;
  }
  
+ /*
+  * mpeg2t_start_join_pak - this handles PMAP or PAS that are more
+  * than 1 transport stream packet. It should also handle any other
+  * type packet.
+  * Elementary streams use their own processing routines.
+  */
  static void mpeg2t_start_join_pak (mpeg2t_pid_t *pidptr,
  				   const uint8_t *bufstart,
  				   uint32_t buflen,
***************
*** 124,129 ****
--- 175,183 ----
    pidptr->lastcc = cc;
  }
  
+ /*
+  * mpeg2t_join_pak - add data to a started pak from above
+  */
  static int mpeg2t_join_pak (mpeg2t_pid_t *pidptr,
  			    const uint8_t *bufstart,
  			    uint32_t buflen,
***************
*** 172,198 ****
    return 1;
  }
  
! static mpeg2t_pid_t *mpeg2t_lookup_pid (mpeg2t_t *ptr,
  					uint16_t pid)
  {
!   mpeg2t_pid_t *pidptr = &ptr->pas.pid;
  
    while (pidptr != NULL && pidptr->pid != pid) {
      pidptr = pidptr->next_pid;
    }
    return pidptr;
  }
  
  static void add_to_pidQ (mpeg2t_t *ptr, mpeg2t_pid_t *pidptr)
  {
    mpeg2t_pid_t *p = &ptr->pas.pid;
  
    while (p->next_pid != NULL) {
      p = p->next_pid;
    }
    p->next_pid = pidptr;
  }
  
  static void create_pmap (mpeg2t_t *ptr, uint16_t prog_num, uint16_t pid)
  {
    mpeg2t_pmap_t *pmap;
--- 226,270 ----
    return 1;
  }
  
! /*
!  * mpeg2t_lookup_pid - search through the list for the pid pointer 
!  */
! mpeg2t_pid_t *mpeg2t_lookup_pid (mpeg2t_t *ptr,
  				 uint16_t pid)
  {
!   mpeg2t_pid_t *pidptr;
! 
!   SDL_LockMutex(ptr->pid_mutex);
!   pidptr = &ptr->pas.pid;
  
    while (pidptr != NULL && pidptr->pid != pid) {
      pidptr = pidptr->next_pid;
    }
+   SDL_UnlockMutex(ptr->pid_mutex);
    return pidptr;
  }
  
+ /*
+  * add_to_pidQ - add a PID to the queue
+  */
  static void add_to_pidQ (mpeg2t_t *ptr, mpeg2t_pid_t *pidptr)
  {
    mpeg2t_pid_t *p = &ptr->pas.pid;
  
+   SDL_LockMutex(ptr->pid_mutex);
    while (p->next_pid != NULL) {
      p = p->next_pid;
    }
    p->next_pid = pidptr;
+   SDL_UnlockMutex(ptr->pid_mutex);
  }
  
+ /*
+  * create_pmap - create a program map.  This is called while processing
+  * PAS statements.  From here, we should get a PMAP packet for this
+  * particular PID.  That will give us the elementary streams that are
+  * part of the PMAP  (PMAP = program map)
+  */
  static void create_pmap (mpeg2t_t *ptr, uint16_t prog_num, uint16_t pid)
  {
    mpeg2t_pmap_t *pmap;
***************
*** 205,212 ****
--- 277,289 ----
    pmap->pid.pid = pid;
    pmap->program_number = prog_num;
    add_to_pidQ(ptr, &pmap->pid);
+   ptr->program_count++;
  }
  
+ /*
+  * create_es - create elementary stream pid.  This is called while
+  * processing PMAPs.
+  */
  static void create_es (mpeg2t_t *ptr, 
  		       uint16_t pid, 
  		       uint8_t stream_type,
***************
*** 220,225 ****
--- 297,308 ----
    es = MALLOC_STRUCTURE(mpeg2t_es_t);
    if (es == NULL) return;
    memset(es, 0, sizeof(*es));
+   es->list_mutex = SDL_CreateMutex();
+   if (es->list_mutex == NULL) {
+     mpeg2t_message(LOG_ERR, "Can't malloc mutex");
+     free(es);
+     return;
+   }
    es->pid.pak_type = MPEG2T_ES_PAK;
    es->pid.pid = pid;
    es->stream_type = stream_type;
***************
*** 234,239 ****
--- 317,326 ----
    add_to_pidQ(ptr, &es->pid);
  }
    
+ /*
+  * mpeg2t_process_pas - process the PAS.  The PAS is a list of PMAP
+  * pids.
+  */
  static int mpeg2t_process_pas (mpeg2t_t *ptr, const uint8_t *buffer)
  {
    uint32_t buflen;
***************
*** 287,292 ****
--- 374,383 ----
    ptr->pas.version_number = (pasptr[2] >> 1) & 0x1f;
    mapptr = &pasptr[5];
    section_len -= 5 + 4; // remove CRC and stuff before map list
+   /*
+    * Now, we have a list of PMAPs - for each one, see if we've
+    * already created a PIDPTR for it - if not, do so
+    */
    for (len = 0; len < section_len; len += 4, mapptr += 4) {
      prog_num = (mapptr[0] << 8) | mapptr[1];
      if (prog_num != 0) {
***************
*** 299,304 ****
--- 390,399 ----
    return 1;
  }
  
+ /*
+  * mpeg2t_process_pmap - process a PMAP, creating the elementary
+  * stream PIDs
+  */
  static int mpeg2t_process_pmap (mpeg2t_t *ptr, 
  				mpeg2t_pid_t *ifptr,
  				const uint8_t *buffer)
***************
*** 370,375 ****
--- 465,471 ----
    pmapptr += 2;
    section_len -= 2;
    if (len != 0) {
+     // This is the prog info - we don't do anything with it yet.
      if (len > section_len) return 0;
  
      if (len == pmap_pid->prog_info_len) {
***************
*** 381,386 ****
--- 477,485 ----
    }
    section_len -= 4; // remove CRC
    len = 0;
+   /*
+    * Now, add all elementary streams for this PMAP
+    */
    while (len < section_len) {
      stream_type = pmapptr[0];
      e_pid = ((pmapptr[1] << 8) | pmapptr[2]) & 0x1fff;
***************
*** 389,394 ****
--- 488,494 ----
      if (mpeg2t_lookup_pid(ptr, e_pid) == NULL) {
        mpeg2t_message(LOG_INFO, "Creating es pid %x", e_pid);
        create_es(ptr, e_pid, stream_type, &pmapptr[5], es_len);
+       ptr->program_maps_recvd++;
      }
      // create_es
      len += 5 + es_len;
***************
*** 397,404 ****
--- 497,511 ----
    return 1;
  }
  
+ /*
+  * clean_es_data
+  * clean all data needed for processing the stream.  This 
+  * should really be broken out into other files, like the
+  * frame processing.
+  */
  static void clean_es_data (mpeg2t_es_t *es_pid) 
  {
+   es_pid->have_ps_ts = 0;
    switch (es_pid->stream_type) {
    case 1:
    case 2:
***************
*** 424,429 ****
--- 531,540 ----
    }
  }  
  
+ /*
+  * mpeg2t_malloc_es_work - create or clean a mpeg2t_frame_t for an
+  * elementary stream.
+  */
  void mpeg2t_malloc_es_work (mpeg2t_es_t *es_pid, uint32_t frame_len)
  {
    uint8_t *frameptr;
***************
*** 443,455 ****
    es_pid->work->have_ps_ts = es_pid->have_ps_ts;
    es_pid->work->ps_ts = es_pid->ps_ts;
    es_pid->have_ps_ts = 0;
-   es_pid->work_loaded = 0;
  }
  
  void mpeg2t_finished_es_work (mpeg2t_es_t *es_pid,
  			      uint32_t frame_len)
  {
    mpeg2t_frame_t *p;
    es_pid->work->frame_len = frame_len;
    if (es_pid->list == NULL) {
      es_pid->list = es_pid->work;
--- 554,573 ----
    es_pid->work->have_ps_ts = es_pid->have_ps_ts;
    es_pid->work->ps_ts = es_pid->ps_ts;
    es_pid->have_ps_ts = 0;
  }
  
+ /*
+  * mpeg2t_finished_es_work - when we have a frame, this is 
+  * called to save the frame on the list (if so configured)
+  */
  void mpeg2t_finished_es_work (mpeg2t_es_t *es_pid,
  			      uint32_t frame_len)
  {
    mpeg2t_frame_t *p;
+   SDL_LockMutex(es_pid->list_mutex);
+   if (es_pid->save_frames == 0) {
+     mpeg2t_malloc_es_work(es_pid, es_pid->work->frame_len);
+   } else {
      es_pid->work->frame_len = frame_len;
      if (es_pid->list == NULL) {
        es_pid->list = es_pid->work;
***************
*** 458,468 ****
--- 576,609 ----
        while (p->next_frame != NULL) p = p->next_frame;
        p->next_frame = es_pid->work;
      }
+     es_pid->frames_in_list++;
      es_pid->work = NULL;
+   }
    es_pid->work_loaded = 0;
+   SDL_UnlockMutex(es_pid->list_mutex);
  }
  
+ /*
+  * mpeg2t_get_es_list_head - get the first frame on the list
+  */
+ mpeg2t_frame_t *mpeg2t_get_es_list_head (mpeg2t_es_t *es_pid)
+ {
+   mpeg2t_frame_t *p;
+   SDL_LockMutex(es_pid->list_mutex);
+   p = es_pid->list;
+   if (p != NULL) {
+     es_pid->list = p->next_frame;
+     p->next_frame = NULL;
+     es_pid->frames_in_list--;
+   }
+   SDL_UnlockMutex(es_pid->list_mutex);
+   return p;
+ }
    
+ /*
+  * mpeg2t_process_es - process a transport stream pak for an
+  * elementary stream
+  */
  static int mpeg2t_process_es (mpeg2t_t *ptr, 
  			      mpeg2t_pid_t *ifptr,
  			      const uint8_t *buffer)
***************
*** 475,485 ****
--- 616,636 ----
    uint8_t stream_id;
    uint32_t nextcc, pakcc;
    int ret;
+   int ac;
  
+   ac = mpeg2t_adaptation_control(buffer);
+   // Note to self - if ac is 0x3, we may have to check
+   // the discontinuity indicator in the adapation control - this
+   // can cause a cc to be non-sequential, as well.
+   // ASDF - not implemented yet
    nextcc = ifptr->lastcc;
+   if (!(ac == 0 || ac == 2)) {
+     // don't add to continuity counter if adaptation counter is 0 or 2
      nextcc = (nextcc + 1) & 0xf;
+   }
    pakcc = mpeg2t_continuity_counter(buffer);
    if (nextcc != pakcc) {
+     // Note - this message will occur for the first packet
      mpeg2t_message(LOG_ERR, "cc error in PES %x should be %d is %d", 
  	   ifptr->pid, nextcc, pakcc);
      clean_es_data(es_pid);
***************
*** 491,497 ****
    esptr = mpeg2t_transport_payload_start(buffer, &buflen);
    if (esptr == NULL) return -1;
  
-   
    if (mpeg2t_payload_unit_start_indicator(buffer) != 0) {
      // start of PES packet
      if ((esptr[0] != 0) ||
--- 642,647 ----
***************
*** 507,512 ****
--- 657,664 ----
      esptr += 6;
      buflen -= 6;
  
+     mpeg2t_message(LOG_DEBUG, 
+ 		   "PES start stream id %02x len %d", stream_id, pes_len);
      read_pes_options = 0;
      // do we have header extensions
      switch ((stream_id & 0x70) >> 4) {
***************
*** 530,535 ****
--- 682,688 ----
        break;
      }
  
+     es_pid->have_ps_ts = 0;
      if (read_pes_options) {
        if (esptr[2] + 3 > buflen) {
  	return 0;
***************
*** 561,567 ****
  	pts <<= 7;
  	pts |= ((esptr[7] >> 1) & 0x7f);
  	es_pid->have_ps_ts = 1;
! 	es_pid->ps_ts = pts;
        }
        buflen -= esptr[2] + 3;
        esptr += esptr[2] + 3;
--- 714,722 ----
  	pts <<= 7;
  	pts |= ((esptr[7] >> 1) & 0x7f);
  	es_pid->have_ps_ts = 1;
! 	es_pid->ps_ts = (pts * M_LLU) / (90 * M_LLU); // give msec
! 	mpeg2t_message(LOG_DEBUG, "pid %x psts "LLU, 
! 		       es_pid->pid.pid, es_pid->ps_ts);
        }
        buflen -= esptr[2] + 3;
        esptr += esptr[2] + 3;
***************
*** 585,602 ****
      break;
    case 3:
    case 4:
!     // mpeg1/mpeg2 audio (mp3 codec
      ret = process_mpeg2t_mpeg_audio(es_pid, esptr, buflen);
    break;
    case 0xf:
      // aac
      break;
    }
!   es_pid->have_ps_ts = 0;
    return ret;
  }
- 			    
        
  mpeg2t_pid_t *mpeg2t_process_buffer (mpeg2t_t *ptr, 
  				     const uint8_t *buffer, 
  				     uint32_t buflen,
--- 740,760 ----
      break;
    case 3:
    case 4:
!     // mpeg1/mpeg2 audio (mp3 codec)
      ret = process_mpeg2t_mpeg_audio(es_pid, esptr, buflen);
    break;
    case 0xf:
      // aac
      break;
    }
!   //es_pid->have_ps_ts = 0;
    return ret;
  }
  			    
+ /*
+  * mpeg2t_process_buffer - API routine that allows us to
+  * process a buffer filled with transport streams
+  */      
  mpeg2t_pid_t *mpeg2t_process_buffer (mpeg2t_t *ptr, 
  				     const uint8_t *buffer, 
  				     uint32_t buflen,
***************
*** 611,616 ****
--- 769,775 ----
  
    used = 0;
    remaining = buflen;
+   mpeg2t_message(LOG_DEBUG, "start processing buffer - len %d", buflen);
    while (used < buflen) {
      offset = mpeg2t_find_sync_byte(buffer, remaining);
      if (offset >= remaining) {
***************
*** 673,687 ****
    return NULL;
  }
    
  mpeg2t_t *create_mpeg2_transport (void)
  {
    mpeg2t_t *ptr;
  
    ptr = MALLOC_STRUCTURE(mpeg2t_t);
!   memset(ptr, 0, sizeof(ptr));
    ptr->pas.pid.pak_type = MPEG2T_PAS_PAK;
    ptr->pas.pid.next_pid = NULL;
    ptr->pas.pid.pid = 0;
    ptr->pas.pid.collect_pes = 1;
    return (ptr);
  }
--- 832,953 ----
    return NULL;
  }
  
+ /*
+  * create_mpeg2_tranport - create the basic structure - we always
+  * need a PAS, so we create one (PAS has a pid of 0).
+  */  
  mpeg2t_t *create_mpeg2_transport (void)
  {
    mpeg2t_t *ptr;
  
    ptr = MALLOC_STRUCTURE(mpeg2t_t);
!   memset(ptr, 0, sizeof(mpeg2t_t));
    ptr->pas.pid.pak_type = MPEG2T_PAS_PAK;
    ptr->pas.pid.next_pid = NULL;
    ptr->pas.pid.pid = 0;
    ptr->pas.pid.collect_pes = 1;
+   ptr->program_count = 0;
+   ptr->program_maps_recvd = 0;
+   ptr->pid_mutex = SDL_CreateMutex();
    return (ptr);
+ }
+ 
+ static void clean_pid (mpeg2t_pid_t *pidptr)
+ {
+   CHECK_AND_FREE(pidptr->data);
+ }
+ 
+ static void clean_es_pid (mpeg2t_es_t *es_pid)
+ {
+   mpeg2t_frame_t *p;
+   clean_es_data(es_pid);
+   
+   do {
+     p = mpeg2t_get_es_list_head(es_pid);
+     if (p != NULL)
+       free(p);
+   } while (p != NULL);
+ 
+   CHECK_AND_FREE(es_pid->work);
+   CHECK_AND_FREE(es_pid->es_data);
+   SDL_DestroyMutex(es_pid->list_mutex);
+ }
+ 
+ 
+   
+ void delete_mpeg2t_transport (mpeg2t_t *ptr)
+ {
+   mpeg2t_pid_t *pidptr, *p;
+   mpeg2t_pmap_t *pmap;
+ 
+   pidptr = ptr->pas.pid.next_pid;
+ 
+   while (pidptr != NULL) {
+     switch (pidptr->pak_type) {
+     case MPEG2T_ES_PAK:
+       clean_es_pid((mpeg2t_es_t *)pidptr);
+       break;
+     case MPEG2T_PROG_MAP_PAK:
+       pmap = (mpeg2t_pmap_t *)pidptr;
+       CHECK_AND_FREE(pmap->prog_info);
+       clean_pid(pidptr);
+       break;
+     case MPEG2T_PAS_PAK:
+       clean_pid(pidptr);
+       break;
+     }
+     p = pidptr;
+     pidptr = pidptr->next_pid;
+     free(p);
+   }
+   clean_pid(&ptr->pas.pid);
+   SDL_DestroyMutex(ptr->pid_mutex);
+   free(ptr);
+ }
+ 
+ /*
+  * Other API routines
+  */
+ void *mpeg2t_es_get_userdata (mpeg2t_es_t *es_pid)
+ {
+   return es_pid->es_userdata;
+ }
+ 
+ void mpeg2t_es_set_userdata (mpeg2t_es_t *es_pid, void *ud)
+ {
+   es_pid->es_userdata = ud;
+ }
+ 
+ void mpeg2t_start_saving_frames (mpeg2t_es_t *es_pid)
+ {
+   es_pid->save_frames = 1;
+ }
+ 
+ void mpeg2t_stop_saving_frames (mpeg2t_es_t *es_pid)
+ {
+   es_pid->save_frames = 0;
+ }
+ 
+ int mpeg2t_write_stream_info (mpeg2t_es_t *es_pid, 
+ 			      char *buffer,
+ 			      size_t buflen)
+ {
+   int ret = -1;
+   switch (es_pid->stream_type) {
+   case 1:
+   case 2:
+     // mpeg1 or mpeg2 video
+     //ret = process_mpeg2t_mpeg_video(es_pid, esptr, buflen);
+     ret = mpeg2t_mpeg_video_info(es_pid, buffer, buflen);
+     break;
+   case 3:
+   case 4:
+     // mpeg1/mpeg2 audio (mp3 codec)
+     ret = mpeg2t_mpeg_audio_info(es_pid, buffer, buflen);
+   break;
+   case 0xf:
+     // aac
+     break;
+   }
+   return ret;
  }
Index: lib/mpeg2t/mpeg2_transport.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/mpeg2_transport.h,v
retrieving revision 1.6
retrieving revision 1.14
diff -c -w -r1.6 -r1.14
*** lib/mpeg2t/mpeg2_transport.h	2002/07/05 22:03:53	1.6
--- lib/mpeg2t/mpeg2_transport.h	2002/07/25 23:46:48	1.14
***************
*** 1,19 ****
  
  
- 
  #ifndef __MPEG2_TRANSPORT_H__
  #define __MPEG2_TRANSPORT_H__
  
  #define MPEG2T_SYNC_BYTE 0x47
  
  typedef struct mpeg2t_frame_t {
    struct mpeg2t_frame_t *next_frame;
!   int have_ps_ts;
    uint64_t ps_ts;
!   uint8_t *frame;
!   uint32_t frame_len;
  } mpeg2t_frame_t;
  
  typedef enum mpeg2t_pak_type {
    MPEG2T_PAS_PAK,
    MPEG2T_PROG_MAP_PAK,
--- 1,50 ----
+ /*
+  * The contents of this file are subject to the Mozilla Public
+  * License Version 1.1 (the "License"); you may not use this file
+  * except in compliance with the License. You may obtain a copy of
+  * the License at http://www.mozilla.org/MPL/
+  * 
+  * Software distributed under the License is distributed on an "AS
+  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+  * implied. See the License for the specific language governing
+  * rights and limitations under the License.
+  * 
+  * The Original Code is MPEG4IP.
+  * 
+  * The Initial Developer of the Original Code is Cisco Systems Inc.
+  * Portions created by Cisco Systems Inc. are
+  * Copyright (C) Cisco Systems Inc. 2002.  All Rights Reserved.
+  * 
+  * Contributor(s): 
+  *		Bill May (wmay@cisco.com)
+  */
  
+ /* mpeg2_transport.h - API for transport stream decoding */
  
  #ifndef __MPEG2_TRANSPORT_H__
  #define __MPEG2_TRANSPORT_H__
  
+ #include <SDL.h>
+ #include <SDL_thread.h>
+ 
  #define MPEG2T_SYNC_BYTE 0x47
  
+ /*
+  * mpeg2t_frame_t - how we'll pass frames back when we've stored them
+  */
  typedef struct mpeg2t_frame_t {
    struct mpeg2t_frame_t *next_frame;
!   int have_ps_ts; // 0 if we don't have presentation timestamp, 1 if we do
    uint64_t ps_ts; 
!   int frame_type; // for video
!   uint8_t *frame; // frame data
!   uint32_t frame_len; // length of frame
  } mpeg2t_frame_t;
  
+ /*
+  * PID list contains basic structure (mpeg2t_pid_t), with a type
+  * field indicating which type to cast to
+  */
  typedef enum mpeg2t_pak_type {
    MPEG2T_PAS_PAK,
    MPEG2T_PROG_MAP_PAK,
***************
*** 49,54 ****
--- 80,101 ----
    uint32_t prog_info_len;
  } mpeg2t_pmap_t;
  
+ #define MPEG2T_ST_11172_VIDEO 1
+ #define MPEG2T_ST_MPEG_VIDEO  2
+ #define MPEG2T_ST_11172_AUDIO  3
+ #define MPEG2T_ST_MPEG_AUDIO  4
+ #define MPEG2T_ST_MPEG_AUDIO_6_A 0xa
+ #define MPEG2T_ST_MPEG_AUDIO_6_B 0xb
+ #define MPEG2T_ST_MPEG_AUDIO_6_C 0xc
+ #define MPEG2T_ST_MPEG_AUDIO_6_D 0xd
+ #define MPEG2T_ST_MPEG2_AAC 0xf
+ #define MPEG2T_ST_MPEG4_VIDEO 0x10
+ 
+ /*
+  * Elementary stream type PID.  Contains enough data for 
+  * audio and video frame-izing (breaking transport stream up
+  * into decodable frames)
+  */
  typedef struct mpeg2t_es_t {
    mpeg2t_pid_t pid;
    uint8_t stream_type;
***************
*** 68,82 ****
--- 115,147 ----
    int have_seq_header;
    uint32_t seq_header_offset;
    uint32_t pict_header_offset;
+   SDL_mutex *list_mutex;
+   int info_loaded;           // 1 if video info or audio info is valid
+   int h, w;                  // video info
+   double frame_rate;         // video info
+   int mpeg_layer;
+   double bitrate;
+   uint16_t sample_freq;      // audio info
+   uint16_t sample_per_frame; // audio info
+   int audio_chans;           // audio info
+   int save_frames;           // set this to save frames
+   void *es_userdata;
+   int frames_in_list;
  } mpeg2t_es_t;
  
  typedef struct mpeg2t_t {
    mpeg2t_pas_t pas;
+   int program_count;
+   int program_maps_recvd;
+   SDL_mutex *pid_mutex;
  } mpeg2t_t;
  
  #ifdef __cplusplus 
  extern "C" {
  #endif
+ /*
+  * These functions will give transport packet header information
+  */
  uint32_t mpeg2t_find_sync_byte(const uint8_t *buffer, uint32_t buflen);
  uint32_t mpeg2t_transport_error_indicator(const uint8_t *pHdr);
  uint32_t mpeg2t_payload_unit_start_indicator(const uint8_t *pHdr);
***************
*** 87,102 ****
  const uint8_t *mpeg2t_transport_payload_start(const uint8_t *pHdr, 
  					      uint32_t *payload_len);
  
  mpeg2t_t *create_mpeg2_transport(void);
  mpeg2t_pid_t *mpeg2t_process_buffer(mpeg2t_t *ptr, 
  				   const uint8_t *buffer, 
  				   uint32_t buflen,
  				   uint32_t *buflen_used);
  
    void mpeg2t_set_loglevel(int loglevel);
- 
    void mpeg2t_set_error_func(error_msg_func_t func);
  #ifdef __cplusplus
  }
  #endif
  #endif
--- 152,215 ----
  const uint8_t *mpeg2t_transport_payload_start(const uint8_t *pHdr, 
  					      uint32_t *payload_len);
  
+ /*
+  * create_mpeg2_transport - create the frame-izing client structure
+  * This structure stores the pid list
+  */
  mpeg2t_t *create_mpeg2_transport(void);
+ 
+ void delete_mpeg2t_transport(mpeg2t_t *ptr);
+ /*
+  * mpeg2t_process_buffer - process a received buffer of len buflen
+  * It will return a pid that we've completed processing on a packet
+  * or frame.  For instance, when we've read a PMAP, or read an audio
+  * frame.  Buflen_used might be less than buflen - need to loop
+  * accordingly.
+  */
  mpeg2t_pid_t *mpeg2t_process_buffer(mpeg2t_t *ptr, 
  				    const uint8_t *buffer, 
  				    uint32_t buflen,
  				    uint32_t *buflen_used);
  
+ /*
+  * mpeg2t_get_es_list_head - read the first frame off the given
+  * es pid pointer
+  */
+ mpeg2t_frame_t *mpeg2t_get_es_list_head(mpeg2t_es_t *es_pid);
+ 
+ /*
+  * mpeg2t_set_loglevel, mpeg2t_set_error_func - set the log level
+  * and the error function
+  */
  void mpeg2t_set_loglevel(int loglevel);
  void mpeg2t_set_error_func(error_msg_func_t func);
+ 
+ /*
+  * mpeg2t_lookup_pid - get the pid pointer for the given PID
+  */
+ mpeg2t_pid_t *mpeg2t_lookup_pid(mpeg2t_t *ptr,uint16_t pid);
+ /*
+  * mpeg2t_es_[set | get]_userdata - set/get a userdata value for 
+  * the elementary stream.
+  */
+ void mpeg2t_es_set_userdata(mpeg2t_es_t *es_pid, void *data);
+ void *mpeg2t_es_get_userdata(mpeg2t_es_t *es_pid);
+ 
+ /*
+  * mpeg2t_[start | stop]_saving_frames - start or stop saving
+  * frames for an elementary stream.  Most streams will still be
+  * processed and the data for each frame saved; however, only
+  * streams that indicate that they are to be saved will save the
+  * data so it can be retrieved using mpeg2t_get_es_list_head().
+  */
+ void mpeg2t_start_saving_frames(mpeg2t_es_t *es_pid);
+ void mpeg2t_stop_saving_frames(mpeg2t_es_t *es_pid);
+ 
+ int mpeg2t_write_stream_info(mpeg2t_es_t *es_pid, 
+ 			     char *buffer,
+ 			     size_t buflen);
  #ifdef __cplusplus
  }
  #endif
  #endif
+ /* end file mpeg2_transport.h */
Index: lib/mpeg2t/mpeg2t_mp3.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/mpeg2t_mp3.c,v
retrieving revision 1.2
retrieving revision 1.8
diff -c -w -r1.2 -r1.8
*** lib/mpeg2t/mpeg2t_mp3.c	2002/06/28 22:31:26	1.2
--- lib/mpeg2t/mpeg2t_mp3.c	2002/07/25 23:46:48	1.8
***************
*** 1,3 ****
--- 1,24 ----
+ /*
+  * The contents of this file are subject to the Mozilla Public
+  * License Version 1.1 (the "License"); you may not use this file
+  * except in compliance with the License. You may obtain a copy of
+  * the License at http://www.mozilla.org/MPL/
+  * 
+  * Software distributed under the License is distributed on an "AS
+  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+  * implied. See the License for the specific language governing
+  * rights and limitations under the License.
+  * 
+  * The Original Code is MPEG4IP.
+  * 
+  * The Initial Developer of the Original Code is Cisco Systems Inc.
+  * Portions created by Cisco Systems Inc. are
+  * Copyright (C) Cisco Systems Inc. 2002.  All Rights Reserved.
+  * 
+  * Contributor(s): 
+  *		Bill May (wmay@cisco.com)
+  */
+ /* mpeg2t_mp3.c - process mpeg audio frames */
  
  #include "mpeg4ip.h"
  #include "mpeg2_transport.h"
***************
*** 5,10 ****
--- 26,35 ----
  #include "mp4av.h"
  #include "mpeg2t_private.h"
  
+ /*
+  * mpeg2t_find_mp3_frame_start - look through the buffer and find
+  * the mpeg audio header
+  */
  static uint32_t mpeg2t_find_mp3_frame_start (mpeg2t_es_t *es_pid, 
  					     const uint8_t *esptr, 
  					     uint32_t buflen)
***************
*** 16,21 ****
--- 41,48 ----
    uint32_t framesize;
  
    if (es_pid->left != 0) {
+     // Indicates that we have up to 3 bytes left from previous frame
+     // copy so we have 4 bytes in the buffer, then see if it matches.
      memcpy(es_pid->left_buff + es_pid->left,
  	   esptr, 
  	   3);
***************
*** 32,37 ****
--- 59,65 ----
    }
  
    if (found == 0) {
+     // Not found with leftover bytes - see if it's in the buffer
      found = MP4AV_Mp3GetNextFrame(esptr, buflen, &fptr, &framesize, 
  				  FALSE, TRUE);
      if (found == 0) {
***************
*** 45,54 ****
--- 73,100 ----
    }
  
    if (found) {
+     // We've found the header - load up the info if we haven't already
+     if (es_pid->info_loaded == 0) {
+       MP4AV_Mp3Header hdr;
+       hdr = MP4AV_Mp3HeaderFromBytes(fptr);
+       es_pid->audio_chans = MP4AV_Mp3GetChannels(hdr);
+       es_pid->sample_freq = MP4AV_Mp3GetHdrSamplingRate(hdr);
+       es_pid->sample_per_frame = MP4AV_Mp3GetHdrSamplingWindow(hdr);
+       es_pid->bitrate = MP4AV_Mp3GetBitRate(hdr) * 1000.0;
+       es_pid->mpeg_layer = MP4AV_Mp3GetHdrLayer(hdr);
+       mpeg2t_message(LOG_INFO, "MP3 - chans %d freq %d spf %d", 
+ 		     es_pid->audio_chans, 
+ 		     es_pid->sample_freq,
+ 		     es_pid->sample_per_frame);
+       es_pid->info_loaded = 1;
+     }
+     // We know how big the frame will be, so malloc it
      mpeg2t_malloc_es_work(es_pid, framesize);
      if (es_pid->work == NULL) return buflen;
        
      offset = 0;
+ 
+     // Copy all the data we can to the buffer
      if (es_pid->left) {
        offset = es_pid->left - dropped;
        memcpy(es_pid->work->frame, es_pid->left_buff + dropped, offset);
***************
*** 88,93 ****
--- 134,140 ----
    ret = 0;
    while (buflen > 0) {
      if (es_pid->work == NULL) {
+       // we haven't found the header - look for it.
        if (buflen < 4) {
  	memcpy(es_pid->left_buff, esptr, buflen);
  	es_pid->left = buflen;
***************
*** 99,104 ****
--- 146,152 ----
        esptr += buflen;
        buflen -= used;
      } else {
+       // We've got the header - keep going until we've got the frame loaded
        tocopy = MIN(buflen, (es_pid->work->frame_len - es_pid->work_loaded));
        memcpy(es_pid->work->frame + es_pid->work_loaded, esptr, tocopy);
        buflen -= tocopy;
***************
*** 118,120 ****
--- 166,180 ----
    return ret;
  }
  
+ int mpeg2t_mpeg_audio_info (mpeg2t_es_t *es_pid, char *buffer, size_t len)
+ {
+   int rate;
+   if (es_pid->info_loaded == 0) return -1;
+   rate = es_pid->bitrate / 1000;
+   snprintf(buffer, len, "MPEG Audio layer %d, %d kbps, %d %s", 
+ 	   es_pid->mpeg_layer, rate, es_pid->sample_freq, 
+ 	   es_pid->audio_chans == 1 ? "mono" : "stereo");
+   return 0;
+ }
+ 	   
+ /* mpeg2t_mp3.c */
Index: lib/mpeg2t/mpeg2t_private.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/mpeg2t_private.h,v
retrieving revision 1.2
retrieving revision 1.4
diff -c -w -r1.2 -r1.4
*** lib/mpeg2t/mpeg2t_private.h	2002/06/28 22:31:26	1.2
--- lib/mpeg2t/mpeg2t_private.h	2002/07/25 23:46:48	1.4
***************
*** 1,3 ****
--- 1,23 ----
+ /*
+  * The contents of this file are subject to the Mozilla Public
+  * License Version 1.1 (the "License"); you may not use this file
+  * except in compliance with the License. You may obtain a copy of
+  * the License at http://www.mozilla.org/MPL/
+  * 
+  * Software distributed under the License is distributed on an "AS
+  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+  * implied. See the License for the specific language governing
+  * rights and limitations under the License.
+  * 
+  * The Original Code is MPEG4IP.
+  * 
+  * The Initial Developer of the Original Code is Cisco Systems Inc.
+  * Portions created by Cisco Systems Inc. are
+  * Copyright (C) Cisco Systems Inc. 2002.  All Rights Reserved.
+  * 
+  * Contributor(s): 
+  *		Bill May (wmay@cisco.com)
+  */
  #ifndef __MPEG2T_PRIVATE_H__
  #define __MPEG2T_PRIVATE_H__ 1
  
***************
*** 7,16 ****
--- 27,38 ----
  // mpeg2t_mp3.c
  int process_mpeg2t_mpeg_audio(mpeg2t_es_t *es_pid, const uint8_t *esptr,
  			      uint32_t buflen);
+ int mpeg2t_mpeg_audio_info(mpeg2t_es_t *es_pid, char *buffer, size_t buflen);
  // mpeg2_video.c
  int process_mpeg2t_mpeg_video(mpeg2t_es_t *es_pid, 
  			      const uint8_t *esptr, 
  			      uint32_t buflen);
+ int mpeg2t_mpeg_video_info(mpeg2t_es_t *es_pid, char *buffer, size_t buflen);
  
  void mpeg2t_malloc_es_work(mpeg2t_es_t *es_pid, uint32_t frame_len);
  void mpeg2t_finished_es_work(mpeg2t_es_t *es_pid, uint32_t frame_len);
Index: lib/mpeg2t/mpeg2t_util.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/mpeg2t_util.c,v
retrieving revision 1.1
retrieving revision 1.3
diff -c -w -r1.1 -r1.3
*** lib/mpeg2t/mpeg2t_util.c	2002/06/28 22:31:26	1.1
--- lib/mpeg2t/mpeg2t_util.c	2002/07/24 21:59:51	1.3
***************
*** 1,3 ****
--- 1,25 ----
+ /*
+  * The contents of this file are subject to the Mozilla Public
+  * License Version 1.1 (the "License"); you may not use this file
+  * except in compliance with the License. You may obtain a copy of
+  * the License at http://www.mozilla.org/MPL/
+  * 
+  * Software distributed under the License is distributed on an "AS
+  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+  * implied. See the License for the specific language governing
+  * rights and limitations under the License.
+  * 
+  * The Original Code is MPEG4IP.
+  * 
+  * The Initial Developer of the Original Code is Cisco Systems Inc.
+  * Portions created by Cisco Systems Inc. are
+  * Copyright (C) Cisco Systems Inc. 2002.  All Rights Reserved.
+  * 
+  * Contributor(s): 
+  *		Bill May (wmay@cisco.com)
+  */
+ /* mpeg2t_util.h - mpeg2 transport stream utilities */
+ 
  #include <mpeg4ip.h>
  #include <time.h>
  #include "mpeg2t_private.h"
***************
*** 21,27 ****
    if (loglevel <= mpeg2t_debug_level) {
      va_start(ap, fmt);
      if (mpeg2t_error_msg != NULL) {
!       (mpeg2t_error_msg)(loglevel, "mpeg2t", fmt, ap);
      } else {
   #if _WIN32 && _DEBUG
  	  char msg[1024];
--- 43,49 ----
    if (loglevel <= mpeg2t_debug_level) {
      va_start(ap, fmt);
      if (mpeg2t_error_msg != NULL) {
!       (mpeg2t_error_msg)(loglevel, "libmpeg2t", fmt, ap);
      } else {
   #if _WIN32 && _DEBUG
  	  char msg[1024];
***************
*** 38,44 ****
        // To add date, add %a %b %d to strftime
        secs = thistime.tv_sec;
        strftime(buffer, sizeof(buffer), "%X", localtime(&secs));
!       printf("%s.%03ld-mpeg2t-%d: ",
  	     buffer, (unsigned long)thistime.tv_usec / 1000, loglevel);
        vprintf(fmt, ap);
        printf("\n");
--- 60,66 ----
        // To add date, add %a %b %d to strftime
        secs = thistime.tv_sec;
        strftime(buffer, sizeof(buffer), "%X", localtime(&secs));
!       printf("%s.%03ld-libmpeg2t-%d: ",
  	     buffer, (unsigned long)thistime.tv_usec / 1000, loglevel);
        vprintf(fmt, ap);
        printf("\n");
Index: lib/mpeg2t/mpeg2t_video.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/mpeg2t_video.c,v
retrieving revision 1.3
retrieving revision 1.12
diff -c -w -r1.3 -r1.12
*** lib/mpeg2t/mpeg2t_video.c	2002/06/28 22:31:26	1.3
--- lib/mpeg2t/mpeg2t_video.c	2002/07/29 17:14:02	1.12
***************
*** 1,3 ****
--- 1,26 ----
+ /*
+  * The contents of this file are subject to the Mozilla Public
+  * License Version 1.1 (the "License"); you may not use this file
+  * except in compliance with the License. You may obtain a copy of
+  * the License at http://www.mozilla.org/MPL/
+  * 
+  * Software distributed under the License is distributed on an "AS
+  * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+  * implied. See the License for the specific language governing
+  * rights and limitations under the License.
+  * 
+  * The Original Code is MPEG4IP.
+  * 
+  * The Initial Developer of the Original Code is Cisco Systems Inc.
+  * Portions created by Cisco Systems Inc. are
+  * Copyright (C) Cisco Systems Inc. 2002.  All Rights Reserved.
+  * 
+  * Contributor(s): 
+  *		Bill May (wmay@cisco.com)
+  */
+ 
+ /* mpeg2t_video.c - parse ES stream for MPEG1/MPEG2 video */
+ 
  #include "mpeg4ip.h"
  #include "mpeg2_transport.h"
  #include "mpeg2t_private.h"
***************
*** 38,48 ****
--- 61,74 ----
  	  mpeg2t_malloc_es_work(es_pid, es_pid->work_max_size);
  	  if (es_pid->work == NULL) return framesfinished;
  	}
+ 	// Store header
  	es_pid->work->frame[0] = 0;
  	es_pid->work->frame[1] = 0;
  	es_pid->work->frame[2] = 1;
  	es_pid->work->frame[3] = *esptr;
  	es_pid->work_loaded = 4;
+ 	// If we have a PICTURE_START - go to work state 2
+ 	// Otherwise, we're looking for the 1st PICTURE_START
  	if (es_pid->header == MPEG3_PICTURE_START_CODE) {
  	  es_pid->work_state = 2;
  	  es_pid->pict_header_offset = 0;
***************
*** 60,66 ****
         * All other work states - load the current byte into the
         * buffer - reallocate buffer if needed
         */
!       if (es_pid->work_loaded >= es_pid->work_max_size - 1) {
  	uint8_t *frameptr;
  	es_pid->work_max_size += 1024;
  	frameptr = 
--- 86,92 ----
         * All other work states - load the current byte into the
         * buffer - reallocate buffer if needed
         */
!       if (es_pid->work_loaded >= es_pid->work_max_size - 5) {
  	uint8_t *frameptr;
  	es_pid->work_max_size += 1024;
  	frameptr = 
***************
*** 101,136 ****
        } else {
  	/*
  	 * Work state 2 - have picture start code in buffer - looking for
! 	 * next picture start code
  	 */
  	// Might want to enhance this to stop at GOP, also
  	if (es_pid->header == MPEG3_PICTURE_START_CODE ||
  	    es_pid->header == MPEG3_SEQUENCE_START_CODE ||
  	    es_pid->header == MPEG3_GOP_START_CODE ||
  	    es_pid->header == MPEG3_SEQUENCE_END_CODE) {
  	  framesfinished = 1;
! 	  if (es_pid->have_seq_header) {
  	    uint32_t h, w;
! 	    double frame_rate;
  
  	    if (MP4AV_Mpeg3ParseSeqHdr(es_pid->work->frame + es_pid->seq_header_offset,
  				       es_pid->work_loaded - es_pid->seq_header_offset,
  				       &h, 
  				       &w, 
! 				       &frame_rate) >= 0) {
! 	      mpeg2t_message(LOG_DEBUG, "Found seq header - h %d w %d fr %g", 
! 			     h, w, frame_rate);
  	    }
  	  }
- 
- 	  mpeg2t_message(LOG_CRIT, "Video seq type is %d", 
- 			 MP4AV_Mpeg3PictHdrType(es_pid->work->frame + es_pid->pict_header_offset));
  
  	  mpeg2t_finished_es_work(es_pid, es_pid->work_loaded);
  
  	  es_pid->have_seq_header = 0;
  	  mpeg2t_malloc_es_work(es_pid, es_pid->work_max_size);
  	  if (es_pid->work != NULL) {
  	    es_pid->work->frame[0] = 0;
  	    es_pid->work->frame[1] = 0;
  	    es_pid->work->frame[2] = 1;
--- 127,179 ----
        } else {
  	/*
  	 * Work state 2 - have picture start code in buffer - looking for
! 	 * next picture start code, or one of SEQUENCE or GOP_START.
! 	 * If SEQUENCE or GOP START, make sure the header at the end
! 	 * is a PICTURE_START header.
  	 */
  	// Might want to enhance this to stop at GOP, also
  	if (es_pid->header == MPEG3_PICTURE_START_CODE ||
  	    es_pid->header == MPEG3_SEQUENCE_START_CODE ||
  	    es_pid->header == MPEG3_GOP_START_CODE ||
  	    es_pid->header == MPEG3_SEQUENCE_END_CODE) {
+ 	  // last frame code should be 0 to finish off picture code.
+ 	  es_pid->work->frame[es_pid->work_loaded - 1] = 0;
  	  framesfinished = 1;
! 	  if (es_pid->info_loaded == 0 && es_pid->have_seq_header) {
  	    uint32_t h, w;
! 	    double frame_rate, bitrate;
! 	    int have_mpeg2;
  
  	    if (MP4AV_Mpeg3ParseSeqHdr(es_pid->work->frame + es_pid->seq_header_offset,
  				       es_pid->work_loaded - es_pid->seq_header_offset,
+ 				       &have_mpeg2,
  				       &h, 
  				       &w, 
! 				       &frame_rate,
! 				       &bitrate) >= 0) {
! 	      mpeg2t_message(LOG_NOTICE, "Found seq header - h %d w %d fr %g offset %d len %d", 
! 			     h, w, frame_rate, es_pid->seq_header_offset,
! 			     es_pid->work_loaded);
! 	      es_pid->info_loaded = 1;
! 	      es_pid->h = h;
! 	      es_pid->w = w;
! 	      es_pid->bitrate = bitrate;
! 	      es_pid->frame_rate = frame_rate;
! 	      es_pid->mpeg_layer = have_mpeg2 ? 2 : 1;
  	    }
  	  }
  
+ 	  // store the frame type so we can figure out the timestamps
+ 	  es_pid->work->frame_type = 
+ 	    MP4AV_Mpeg3PictHdrType(es_pid->work->frame + 
+ 				   es_pid->pict_header_offset);
  	  mpeg2t_finished_es_work(es_pid, es_pid->work_loaded);
  
  	  es_pid->have_seq_header = 0;
  	  mpeg2t_malloc_es_work(es_pid, es_pid->work_max_size);
  	  if (es_pid->work != NULL) {
+ 	    // Put the header we just found at the start of the frame,
+ 	    // then set the work state accordingly.
  	    es_pid->work->frame[0] = 0;
  	    es_pid->work->frame[1] = 0;
  	    es_pid->work->frame[2] = 1;
***************
*** 159,162 ****
--- 202,218 ----
      }
    }
    return framesfinished;
+ }
+ 
+ int mpeg2t_mpeg_video_info (mpeg2t_es_t *es_pid, char *buffer, size_t len)
+ {
+   int rate, offset;
+   if (es_pid->info_loaded == 0) return -1;
+   offset = snprintf(buffer, len, "MPEG-%d Video, %d x %d, %g",
+ 		    es_pid->mpeg_layer, es_pid->w, es_pid->h, es_pid->frame_rate);
+   if (es_pid->bitrate > 0.0) {
+     rate = es_pid->bitrate / 1000;
+     snprintf(buffer + offset, len - offset, ", %d kbps", rate);
+   }
+   return 0;
  }
Index: lib/mpeg2t/test.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/mpeg2t/test.cpp,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** lib/mpeg2t/test.cpp	2002/06/28 22:31:26	1.4
--- lib/mpeg2t/test.cpp	2002/08/13 16:21:23	1.5
***************
*** 10,15 ****
--- 10,17 ----
    int done_with_buf;
    mpeg2t_t *mpeg2t;
    mpeg2t_es_t *es_pid;
+   mpeg2t_pid_t *pidptr;
+ 
    //  int lastcc, ccset;
  
    mpeg2t_set_loglevel(LOG_DEBUG);
***************
*** 30,43 ****
      done_with_buf = 0;
  
      while (done_with_buf == 0) {
!       es_pid = mpeg2t_process_buffer(mpeg2t, ptr, buflen, &offset);
        ptr += offset;
        buflen -= offset;
        if (buflen < 188) {
  	done_with_buf = 1;
        }
!       if (es_pid != NULL) {
  	mpeg2t_frame_t *mp3, *p;
  	mp3 = es_pid->list;
  	es_pid->list = NULL;
  	while (mp3 != NULL) {
--- 32,46 ----
      done_with_buf = 0;
  
      while (done_with_buf == 0) {
!       pidptr = mpeg2t_process_buffer(mpeg2t, ptr, buflen, &offset);
        ptr += offset;
        buflen -= offset;
        if (buflen < 188) {
  	done_with_buf = 1;
        }
!       if (pidptr != NULL && pidptr->pak_type == MPEG2T_ES_PAK) {
  	mpeg2t_frame_t *mp3, *p;
+ 	es_pid = (mpeg2t_es_t *)pidptr;
  	mp3 = es_pid->list;
  	es_pid->list = NULL;
  	while (mp3 != NULL) {
Index: lib/msg_queue/msg_queue.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/msg_queue/msg_queue.cpp,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -w -r1.3 -r1.4
*** lib/msg_queue/msg_queue.cpp	2002/01/25 18:13:44	1.3
--- lib/msg_queue/msg_queue.cpp	2002/07/25 19:47:37	1.4
***************
*** 80,91 ****
  CMsgQueue::~CMsgQueue (void) 
  {
    CMsg *p;
!   SDL_mutexP(m_msg_queue_mutex);
    while (m_msg_queue != NULL) {
      p = m_msg_queue->get_next();
      delete m_msg_queue;
      m_msg_queue = p;
    }
    SDL_DestroyMutex(m_msg_queue_mutex);
    m_msg_queue_mutex = NULL;
  }
--- 80,92 ----
  CMsgQueue::~CMsgQueue (void) 
  {
    CMsg *p;
!   SDL_LockMutex(m_msg_queue_mutex);
    while (m_msg_queue != NULL) {
      p = m_msg_queue->get_next();
      delete m_msg_queue;
      m_msg_queue = p;
    }
+   SDL_UnlockMutex(m_msg_queue_mutex);
    SDL_DestroyMutex(m_msg_queue_mutex);
    m_msg_queue_mutex = NULL;
  }
***************
*** 114,120 ****
  int CMsgQueue::send_message(CMsg *newmsg, SDL_sem *sem)
  {
  
!   SDL_mutexP(m_msg_queue_mutex);
    if (m_msg_queue == NULL) {
      m_msg_queue = newmsg;
    } else {
--- 115,121 ----
  int CMsgQueue::send_message(CMsg *newmsg, SDL_sem *sem)
  {
  
!   SDL_LockMutex(m_msg_queue_mutex);
    if (m_msg_queue == NULL) {
      m_msg_queue = newmsg;
    } else {
***************
*** 122,128 ****
      while (p->get_next() != NULL) p = p->get_next();
      p->set_next(newmsg);
    }
!   SDL_mutexV(m_msg_queue_mutex);
    if (sem != NULL) {
      SDL_SemPost(sem);
    }
--- 123,129 ----
      while (p->get_next() != NULL) p = p->get_next();
      p->set_next(newmsg);
    }
!   SDL_UnlockMutex(m_msg_queue_mutex);
    if (sem != NULL) {
      SDL_SemPost(sem);
    }
***************
*** 136,149 ****
    if (m_msg_queue == NULL) 
      return(NULL);
  
!   SDL_mutexP(m_msg_queue_mutex);
    if (m_msg_queue == NULL) 
      ret = NULL;
    else {
      ret = m_msg_queue;
      m_msg_queue = ret->get_next();
    }
!   SDL_mutexV(m_msg_queue_mutex);
    if (ret) {
      ret->set_next(NULL);
    }
--- 137,150 ----
    if (m_msg_queue == NULL) 
      return(NULL);
  
!   SDL_LockMutex(m_msg_queue_mutex);
    if (m_msg_queue == NULL) 
      ret = NULL;
    else {
      ret = m_msg_queue;
      m_msg_queue = ret->get_next();
    }
!   SDL_UnlockMutex(m_msg_queue_mutex);
    if (ret) {
      ret->set_next(NULL);
    }
Index: lib/sdp/sdp_encode.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/sdp/sdp_encode.c,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -w -r1.6 -r1.7
*** lib/sdp/sdp_encode.c	2002/04/15 15:50:35	1.6
--- lib/sdp/sdp_encode.c	2002/08/20 15:32:48	1.7
***************
*** 46,57 ****
    return (0);
  }
  
! static int add_string_to_encode (sdp_encode_t *sptr, const char *buf)
  {
    uint32_t len;
    char *temp;
    
!   if (buf == NULL) return (EINVAL);
    len = strlen(buf);
    if (len == 0) return (0);
    
--- 46,61 ----
    return (0);
  }
  
! static int add_string_to_encode (sdp_encode_t *sptr, const char *buf,
! 				 int line)
  {
    uint32_t len;
    char *temp;
    
!   if (buf == NULL) {
!     sdp_debug(LOG_CRIT, "Can't add NULL string to SDP - line %d", line);
!     return (EINVAL);
!   }
    len = strlen(buf);
    if (len == 0) return (0);
    
***************
*** 68,74 ****
  }
  
  #define ADD_STR_TO_ENCODE_WITH_RETURN(se, string) \
!  { int ret; ret = add_string_to_encode(se, string); if (ret != 0) return(ret);}
  
  #define CHECK_RETURN(a) {int ret; ret = (a); if (ret != 0) return (ret); }
  static int encode_a_ints (int recvonly,
--- 72,78 ----
  }
  
  #define ADD_STR_TO_ENCODE_WITH_RETURN(se, string) \
!  { int ret; ret = add_string_to_encode(se, string, __LINE__); if (ret != 0) return(ret);}
  
  #define CHECK_RETURN(a) {int ret; ret = (a); if (ret != 0) return (ret); }
  static int encode_a_ints (int recvonly,
***************
*** 570,575 ****
--- 574,580 ----
    CHECK_RETURN(sdp_encode(sptr, &sdp));
    ofile = fopen(filename, append ? "a" : "w");
    if (ofile == NULL) {
+     sdp_debug(LOG_CRIT, "Cannot open file %s", filename);
      free(sdp.buffer);
      return (-1);
    }
Index: lib/sdp/sdp_util.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/sdp/sdp_util.c,v
retrieving revision 1.5
retrieving revision 1.7
diff -c -w -r1.5 -r1.7
*** lib/sdp/sdp_util.c	2002/06/18 22:37:10	1.5
--- lib/sdp/sdp_util.c	2002/08/26 20:19:45	1.7
***************
*** 273,278 ****
--- 273,285 ----
        va_start(ap, fmt);
        (error_msg_func)(loglevel, "libsdp", fmt, ap);
        va_end(ap);
+     } else {
+       va_list ap;
+       printf("libsdp-%d:", loglevel);
+       va_start(ap, fmt);
+       vprintf(fmt, ap);
+       va_end(ap);
+       printf("\n");
      }
    }
  }
Index: lib/xvid/decoder.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/decoder.c,v
retrieving revision 1.3
retrieving revision 1.8
diff -c -w -r1.3 -r1.8
*** lib/xvid/decoder.c	2002/06/14 18:45:11	1.3
--- lib/xvid/decoder.c	2002/09/09 22:57:35	1.8
***************
*** 72,77 ****
--- 72,80 ----
  int decoder_alloc(XVID_DEC_PARAM * param)
  {
    param->handle = xvid_malloc(sizeof(DECODER), CACHE_LINE);
+ #ifdef MPEG4IP
+   memset(param->handle, 0, sizeof(DECODER));
+ #endif
    if (param->handle == NULL) 
      return XVID_ERR_MEMORY;
    return XVID_ERR_OK;
***************
*** 179,184 ****
--- 182,193 ----
  		int16_t predictors[8];
  		int start_coeff;
  
+ #ifdef MPEG4IP_H263_DC
+ 		if (dec->have_short_header) {
+ 			iDcScaler = 16;
+ 		}
+ #endif
+ 
  		start_timer();
  		predict_acdc(dec->mbs, x_pos, y_pos, dec->mb_width, i, &block[i*64], iQuant, iDcScaler, predictors);
  		if (!acpred_flag)
***************
*** 187,192 ****
--- 196,211 ----
  		}
  		stop_prediction_timer();
  
+ #ifdef MPEG4IP_H263_DC
+ 		if (dec->have_short_header) {
+ 			uint16_t dcq = BitstreamGetBits(bs, 8);
+ 			if (dcq == 255) {
+ 				dcq = 128;
+ 			}
+ 			block[i*64 + 0] = dcq - 129;
+ 			start_coeff = 1;
+ 		} else {
+ #endif
  		if (quant < intra_dc_threshold)
  		{
  			int dc_size;
***************
*** 207,212 ****
--- 226,234 ----
  		{
  			start_coeff = 0;
  		}
+ #ifdef MPEG4IP_H263_DC
+ 		}
+ #endif
  
  		start_timer();
  		if (cbp & (1 << (5-i)))			// coded
***************
*** 387,393 ****
--- 409,423 ----
  			mb->mode = mcbpc & 7;
  			cbpc = (mcbpc >> 4);
  
+ #ifdef MPEG4IP_H263_NOACPRED
+ 			if (dec->have_short_header) {
+ 				acpred_flag = 0;
+ 			} else {
+ 				acpred_flag = BitstreamGetBit(bs);
+ 			}
+ #else
  			acpred_flag = BitstreamGetBit(bs);
+ #endif
  
  			if (mb->mode == MODE_STUFFING)
  			{
***************
*** 510,516 ****
--- 540,552 ----
  				
  				if (intra)
  				{
+ #ifdef MPEG4IP_H263_NOACPRED
+ 					if (!dec->have_short_header) {
+ 						acpred_flag = BitstreamGetBit(bs);
+ 					}
+ #else
  					acpred_flag = BitstreamGetBit(bs);
+ #endif
  				}
  
  				if (mb->mode == MODE_STUFFING)
***************
*** 529,535 ****
  					{
  						quant = 31;
  					}
! 					else if (mb->quant < 1)
  					{
  						quant = 1;
  					}
--- 565,571 ----
  					{
  						quant = 31;
  					}
! 					else if (quant < 1)
  					{
  						quant = 1;
  					}
***************
*** 677,682 ****
--- 713,719 ----
  
  }
  
+ // entire function added for mpeg4ip
  int decoder_find_vol (DECODER * dec, 
  		      XVID_DEC_FRAME * frame, 
  		      XVID_DEC_PARAM * param)
***************
*** 687,697 ****
  	uint32_t fcode;
  	uint32_t intra_dc_threshold;
  	int ret;
  
  	BitstreamInit(&bs, frame->bitstream, frame->length);
  
  	ret = BitstreamReadHeaders(&bs, dec, &rounding, &quant, &fcode, &intra_dc_threshold, 1);
! 	frame->length = BitstreamPos(&bs) / 8;
  
  	if (ret > 0) {
  	  param->width = dec->width;
--- 724,739 ----
  	uint32_t fcode;
  	uint32_t intra_dc_threshold;
  	int ret;
+ 	int len = frame->length;
  
  	BitstreamInit(&bs, frame->bitstream, frame->length);
  
  	ret = BitstreamReadHeaders(&bs, dec, &rounding, &quant, &fcode, &intra_dc_threshold, 1);
! 	if (dec->have_short_header) {
! 	  frame->length = len;
! 	} else {
! 	  frame->length = len - (BitstreamPos(&bs) / 8);
! 	}
  
  	if (ret > 0) {
  	  param->width = dec->width;
***************
*** 702,704 ****
--- 744,747 ----
  	if (ret < 0) return XVID_ERR_FORMAT;
  	return XVID_ERR_FAIL;
  }
+ 
Index: lib/xvid/decoder.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/decoder.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** lib/xvid/decoder.h	2002/04/29 20:43:49	1.2
--- lib/xvid/decoder.h	2002/08/02 20:18:19	1.3
***************
*** 22,27 ****
--- 22,30 ----
  	uint32_t top_field_first;
  	uint32_t alternate_vertical_scan;
  
+ #ifdef MPEG4IP
+   int have_short_header;
+ #endif
  	// image
  
  	uint32_t width;
Index: lib/xvid/divx4.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/divx4.c,v
retrieving revision 1.5
retrieving revision 1.6
diff -c -w -r1.5 -r1.6
*** lib/xvid/divx4.c	2002/06/03 19:49:02	1.5
--- lib/xvid/divx4.c	2002/08/02 20:18:19	1.6
***************
*** 379,384 ****
--- 379,389 ----
  			xframe.length = eframe->length;
  
  			xframe.general = XVID_HALFPEL | XVID_H263QUANT;
+ #ifdef MPEG4IP
+ 			if (eframe->general & DEC_SHORT_HEADERS) {
+ 			  xframe.general |= XVID_SHORT_HEADERS;
+ 			}
+ #endif
  
  			if(quality > 3)
  				xframe.general |= XVID_INTER4V;
Index: lib/xvid/divx4.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/divx4.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
*** lib/xvid/divx4.h	2002/04/26 18:28:43	1.1
--- lib/xvid/divx4.h	2002/08/02 20:18:19	1.2
***************
*** 179,187 ****
--- 179,193 ----
      int quant;		// quantizer for this frame; only used in VBR modes
      int intra;		// force this frame to be intra/inter; only used in VBR 2-pass
      void *mvs;		// optional pointer to array of motion vectors
+ #ifdef MPEG4IP
+   int general;
+ #endif
  }
  ENC_FRAME;
  
+ #ifdef MPEG4IP
+ #define DEC_SHORT_HEADERS 1
+ #endif
  /**
      Structure passed as a second optional argument when encoding a frame.
      On successful return its members are filled with parameters of encoded
Index: lib/xvid/encoder.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/encoder.c,v
retrieving revision 1.8
retrieving revision 1.9
diff -c -w -r1.8 -r1.9
*** lib/xvid/encoder.c	2002/06/18 00:06:02	1.8
--- lib/xvid/encoder.c	2002/08/02 20:18:19	1.9
***************
*** 341,347 ****
  	}
  
  #ifdef MPEG4IP
! 	if (pEnc->iFrameNum == 0) {
  		BitstreamWriteVoshHeader(&bs);
  		write_vol_header = 1;
  	}
--- 341,347 ----
  	}
  
  #ifdef MPEG4IP
! 	if (pEnc->iFrameNum == 0 && (pEnc->mbParam.global_flags & XVID_SHORT_HEADERS) == 0) {
  		BitstreamWriteVoshHeader(&bs);
  		write_vol_header = 1;
  	}
***************
*** 656,661 ****
--- 656,662 ----
  	pEnc->mbParam.coding_type = I_VOP;
  
  #ifdef MPEG4IP
+ 	if ((pEnc->mbParam.global_flags & XVID_SHORT_HEADERS) == 0) {
  	  if (vol_header) {
  	    BitstreamWriteVolHeader(bs, &pEnc->mbParam);
  	  }
***************
*** 663,668 ****
--- 664,674 ----
  	  BitstreamWriteVolHeader(bs, &pEnc->mbParam);
  #endif
  	  BitstreamWriteVopHeader(bs, &pEnc->mbParam);
+ #ifdef MPEG4IP
+ 	} else {
+ 	  BitstreamWriteShortVopHeader(bs, &pEnc->mbParam);
+ 	}
+ #endif
  
  	*pBits = BitstreamPos(bs);
  
***************
*** 770,779 ****
--- 776,793 ----
  
  	pEnc->mbParam.coding_type = P_VOP;
  
+ #ifdef MPEG4IP
+ 	if ((pEnc->mbParam.global_flags & XVID_SHORT_HEADERS) == 0) {
+ #endif
  	  if(vol_header)
  	    BitstreamWriteVolHeader(bs, &pEnc->mbParam);
  
  	  BitstreamWriteVopHeader(bs, &pEnc->mbParam);
+ #ifdef MPEG4IP
+ 	} else {
+ 	  BitstreamWriteShortVopHeader(bs, &pEnc->mbParam);
+ 	}
+ #endif
  
  	*pBits = BitstreamPos(bs);
  
Index: lib/xvid/libxvid.dsp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/libxvid.dsp,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** lib/xvid/libxvid.dsp	2002/05/02 17:52:19	1.2
--- lib/xvid/libxvid.dsp	2002/08/19 18:22:34	1.3
***************
*** 41,47 ****
  # PROP Intermediate_Dir "Release"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
! # ADD CPP /nologo /MD /W3 /GX /O2 /Ob2 /D "NDEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /YX /FD /c
  # ADD BASE RSC /l 0xc09 /d "NDEBUG"
  # ADD RSC /l 0xc09 /d "NDEBUG"
  BSC32=bscmake.exe
--- 41,47 ----
  # PROP Intermediate_Dir "Release"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
! # ADD CPP /nologo /MD /W3 /GX /O2 /Ob2 /D "NDEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /D "MPEG4IP" /YX /FD /c
  # ADD BASE RSC /l 0xc09 /d "NDEBUG"
  # ADD RSC /l 0xc09 /d "NDEBUG"
  BSC32=bscmake.exe
***************
*** 64,70 ****
  # PROP Intermediate_Dir "Debug"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
! # ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\.." /I "..\..\include" /D "_DEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /YX /FD /GZ /c
  # ADD BASE RSC /l 0xc09 /d "_DEBUG"
  # ADD RSC /l 0xc09 /d "_DEBUG"
  BSC32=bscmake.exe
--- 64,70 ----
  # PROP Intermediate_Dir "Debug"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
! # ADD CPP /nologo /MDd /W3 /Gm /GX /ZI /Od /I "..\.." /I "..\..\include" /D "_DEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /D "MPEG4IP" /YX /FD /GZ /c
  # ADD BASE RSC /l 0xc09 /d "_DEBUG"
  # ADD RSC /l 0xc09 /d "_DEBUG"
  BSC32=bscmake.exe
Index: lib/xvid/xvid.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/xvid.h,v
retrieving revision 1.6
retrieving revision 1.8
diff -c -w -r1.6 -r1.8
*** lib/xvid/xvid.h	2002/06/03 18:44:03	1.6
--- lib/xvid/xvid.h	2002/09/09 21:11:43	1.8
***************
*** 9,14 ****
--- 9,20 ----
  extern "C" {
  #endif 
  
+ #ifdef MPEG4IP
+ // for debugging
+ #define MPEG4IP_H263_NOACPRED
+ #define MPEG4IP_H263_DC
+ #endif
+ 
  // ==========================================
  //	global
  // ==========================================
***************
*** 126,131 ****
--- 132,140 ----
  #define XVID_ME_FULLSEARCH		0x00040000
  #define XVID_ME_PMVFAST			0x00080000
  #define XVID_ME_EPZS			0x00100000
+ #ifdef MPEG4IP
+ #define XVID_SHORT_HEADERS              0x00200000
+ #endif
  
  #define PMV_HALFPELDIAMOND16 	0x00010000
  #define PMV_HALFPELREFINE16 	0x00020000
Index: lib/xvid/xvid_st.dsp
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/xvid_st.dsp,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** lib/xvid/xvid_st.dsp	2002/05/02 17:52:19	1.2
--- lib/xvid/xvid_st.dsp	2002/08/19 18:22:34	1.3
***************
*** 41,47 ****
  # PROP Intermediate_Dir "Release_st"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
! # ADD CPP /nologo /W3 /GX /O2 /Ob2 /D "NDEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /YX /FD /c
  # ADD BASE RSC /l 0xc09 /d "NDEBUG"
  # ADD RSC /l 0xc09 /d "NDEBUG"
  BSC32=bscmake.exe
--- 41,47 ----
  # PROP Intermediate_Dir "Release_st"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
! # ADD CPP /nologo /W3 /GX /O2 /Ob2 /D "NDEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /D "MPEG4IP" /YX /FD /c
  # ADD BASE RSC /l 0xc09 /d "NDEBUG"
  # ADD RSC /l 0xc09 /d "NDEBUG"
  BSC32=bscmake.exe
***************
*** 64,70 ****
  # PROP Intermediate_Dir "Debug_st"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
! # ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\.." /I "..\..\include" /D "_DEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /YX /FD /GZ /c
  # ADD BASE RSC /l 0xc09 /d "_DEBUG"
  # ADD RSC /l 0xc09 /d "_DEBUG"
  BSC32=bscmake.exe
--- 64,70 ----
  # PROP Intermediate_Dir "Debug_st"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
! # ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\.." /I "..\..\include" /D "_DEBUG" /D "ARCH_X86" /D "WIN32" /D "_MBCS" /D "_LIB" /D "_WIN32" /D "MPEG4IP" /YX /FD /GZ /c
  # ADD BASE RSC /l 0xc09 /d "_DEBUG"
  # ADD RSC /l 0xc09 /d "_DEBUG"
  BSC32=bscmake.exe
Index: lib/xvid/bitstream/bitstream.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/bitstream/bitstream.c,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** lib/xvid/bitstream/bitstream.c	2002/06/18 00:06:02	1.4
--- lib/xvid/bitstream/bitstream.c	2002/08/02 20:18:19	1.5
***************
*** 112,117 ****
--- 112,120 ----
  	uint32_t time_inc_resolution;
  	uint32_t coding_type;
  	uint32_t start_code;
+ #ifdef MPEG4IP
+ 	uint32_t width, height;
+ #endif
  	
  	do
  	{
***************
*** 556,561 ****
--- 559,632 ----
  			// DEBUG("user_data");
  			BitstreamSkip(bs, 32);		// user_data_start_code
  		}
+ #ifdef MPEG4IP
+ 		else if ((start_code & 0xfffffc03) == 0x00008002) {
+ 		  // Short video header.  Skip short_video_start_marker,
+ 		  // temporal reference, marker and zero bit
+ 		  uint8_t source_format;
+ 		  dec->have_short_header = 1;
+ 		  dec->shape = VIDOBJLAY_SHAPE_RECTANGULAR;
+ 		  dec->interlacing = 0;
+ 		  dec->quant_bits = 5;
+ 		  dec->quant_type = 0;
+ 		  dec->quarterpel = 0;
+ 		  *intra_dc_threshold = intra_dc_threshold_table[0];
+ 		  *rounding = 0;
+ 		  *fcode = 1;
+ 		  BitstreamSkip(bs, 22);
+ 		  BitstreamSkip(bs, 8 + 5);
+ 		  source_format = BitstreamGetBits(bs, 3);
+ 		  switch (source_format) {
+ 		  case 1: // sub-QCIF
+ 		    width = 128;
+ 		    height = 96;
+ 		    break;
+ 		  case 2: // QCIF
+ 		    width = 176;
+ 		    height = 144;
+ 		    break;
+ 		  case 3: // CIF
+ 		    width = 352;
+ 		    height = 288;
+ 		    break;
+ 		  case 4: // 4CIF
+ 		    width = 704;
+ 		    height = 576;
+ 		    break;
+ 		  case 5:
+ 		    width = 1408;
+ 		    height = 1152;
+ 		    break;
+ 		  default:
+ 		    DEBUG1("FATAL: illegal code in short video header", source_format);
+ 		    return -1;
+ 		  }
+ 		  if (findvol == 0) {
+ 		    if (width != dec->width || height != dec->height)
+ 		      {
+ 			DEBUG("FATAL: video dimension discrepancy ***");
+ 			DEBUG2("bitstream width/height", width, height);
+ 			DEBUG2("param width/height", dec->width, dec->height);
+ 			return -1;
+ 		      }
+ 		  } else {
+ 		    dec->width = width;
+ 		    dec->height = height;
+ 		    return 1;
+ 		  }
+ 		  if (BitstreamGetBit(bs)) {
+ 		    // P frame
+ 		    coding_type = P_VOP;
+ 		  } else {
+ 		    coding_type = I_VOP;
+ 		  }
+ 		  BitstreamSkip(bs, 4); // skip 4 reserved 0 bits
+ 		  *quant = BitstreamGetBits(bs, 5);
+ 		  BitstreamSkip(bs, 1);
+ 		  while (BitstreamGetBit(bs) == 1) BitstreamSkip(bs, 8); // pei and psupp
+ 		  return coding_type;
+ 		}
+ #endif
  		else  // start_code == ?
  		{
  			if (BitstreamShowBits(bs, 24) == 0x000001)
***************
*** 766,768 ****
--- 837,862 ----
  	if (pParam->coding_type != I_VOP)
  		BitstreamPutBits(bs, pParam->fixed_code, 3);		// fixed_code = [1,4]
  }
+ 
+ #ifdef MPEG4IP
+ void BitstreamWriteShortVopHeader(Bitstream * const bs,
+ 						const MBParam * pParam)
+ {
+   int sfmat;
+     BitstreamPad(bs);
+     BitstreamPutBits(bs, 0x20, 22); // short_video_start_marker
+     BitstreamPutBits(bs, pParam->fincr, 8);
+     BitstreamPutBits(bs, 0x10, 5);
+     sfmat = 0;
+     if (pParam->width == 128) sfmat = 1;
+     else if (pParam->width == 176) sfmat = 2;
+     else if (pParam->width == 352) sfmat = 3;
+     else if (pParam->width == 704) sfmat = 4;
+     else if (pParam->width == 1408) sfmat = 5;
+     BitstreamPutBits(bs, sfmat, 3);
+     BitstreamPutBits(bs, pParam->coding_type == I_VOP ? 0 : 1, 1);
+     BitstreamPutBits(bs, 0, 4);
+     BitstreamPutBits(bs, pParam->quant, 5);
+     BitstreamPutBits(bs, 0, 2); // zero bit and pei
+ }
+ #endif
Index: lib/xvid/bitstream/bitstream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/bitstream/bitstream.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** lib/xvid/bitstream/bitstream.h	2002/06/18 21:29:29	1.4
--- lib/xvid/bitstream/bitstream.h	2002/08/02 20:18:19	1.5
***************
*** 126,131 ****
--- 126,135 ----
  
  void BitstreamWriteVopHeader(Bitstream * const bs,
  						const MBParam * pParam);
+ #ifdef MPEG4IP
+ void BitstreamWriteShortVopHeader(Bitstream * const bs, 
+ 				  const MBParam *pParam);
+ #endif
  
  
  /* initialise bitstream structure */
Index: lib/xvid/bitstream/mbcoding.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/bitstream/mbcoding.c,v
retrieving revision 1.1
retrieving revision 1.6
diff -c -w -r1.1 -r1.6
*** lib/xvid/bitstream/mbcoding.c	2002/04/26 18:31:18	1.1
--- lib/xvid/bitstream/mbcoding.c	2002/09/09 22:57:35	1.6
***************
*** 251,261 ****
--- 251,267 ----
  		BitstreamPutBits(bs, mcbpc_inter_tab[mcbpc].code, mcbpc_inter_tab[mcbpc].len);
  	}
  
+ #ifdef MPEG4IP_H263_NOACPRED
+ 	if ((pParam->global_flags & XVID_SHORT_HEADERS) == 0) {
+ #endif
  		// ac prediction flag
  		if(pMB->acpred_directions[0])
  			BitstreamPutBits(bs, 1, 1);
  		else
  			BitstreamPutBits(bs, 0, 1);
+ #ifdef MPEG4IP_H263_NOACPRED
+ 	}
+ #endif
  
  	// write cbpy
  	BitstreamPutBits (bs, cbpy_tab[cbpy].code, cbpy_tab[cbpy].len);
***************
*** 273,302 ****
  	// code block coeffs
  	for(i = 0; i < 6; i++)
  	{
! 		if(i < 4)
  			BitstreamPutBits(bs,
  					 dcy_tab[qcoeff[i*64 + 0] + 255].code,
  					 dcy_tab[qcoeff[i*64 + 0] + 255].len);
! 		else
  			BitstreamPutBits(bs,
  					 dcc_tab[qcoeff[i*64 + 0] + 255].code,
  			                 dcc_tab[qcoeff[i*64 + 0] + 255].len);
  		
! 		if(pMB->cbp & (1 << (5 - i)))
! 		{
  			bits = BitstreamPos(bs);
  
  			CodeCoeff(bs,
  				  &qcoeff[i*64],
  				  intra_table,
  				  scan_tables[pMB->acpred_directions[i]],
  				  1);
  
! 			bits = BitstreamPos(bs) - bits;
! 			pStat->iTextBits += bits;
  		}
  	}
  
  }
  
  
--- 279,352 ----
  	// code block coeffs
  	for(i = 0; i < 6; i++)
  	{
! #ifdef MPEG4IP
! 		if ((pParam->global_flags & XVID_SHORT_HEADERS) != 0) {
! 			// H.263
! #ifdef MPEG4IP_H263_DC
! 			uint16_t dcq = qcoeff[i*64] + 129;
! 			if (dcq < 1) {
! 				dcq = 1;
! 			} else if (dcq == 128) {
! 				dcq = 255;	/* gets remapped */
! 			} else if (dcq > 254) {
! 				dcq = 254;	/* need to clamp value */
! 			} 
! 			BitstreamPutBits(bs, dcq, 8);
! #else
! 			if (i < 4) {
  				BitstreamPutBits(bs,
  						 dcy_tab[qcoeff[i*64 + 0] + 255].code,
  						 dcy_tab[qcoeff[i*64 + 0] + 255].len);
! 			} else {
  				BitstreamPutBits(bs,
  						 dcc_tab[qcoeff[i*64 + 0] + 255].code,
  						 dcc_tab[qcoeff[i*64 + 0] + 255].len);
+ 			}
+ #endif
  
! 			if (pMB->cbp & (1 << (5 - i))) {
  				bits = BitstreamPos(bs);
  
  				CodeCoeff(bs,
  					  &qcoeff[i*64],
  					  intra_table,
+ #ifdef MPEG4IP_H263_NOACPRED
+ 					  scan_tables[0],
+ #else
  					  scan_tables[pMB->acpred_directions[i]],
+ #endif
  					  1);
  
! 				pStat->iTextBits += BitstreamPos(bs) - bits;
  			}
+ 		} else { 
+ #endif
+ 			// MPEG-4
+ 			if (i < 4) {
+ 				BitstreamPutBits(bs,
+ 						 dcy_tab[qcoeff[i*64 + 0] + 255].code,
+ 						 dcy_tab[qcoeff[i*64 + 0] + 255].len);
+ 			} else {
+ 				BitstreamPutBits(bs,
+ 						 dcc_tab[qcoeff[i*64 + 0] + 255].code,
+ 						 dcc_tab[qcoeff[i*64 + 0] + 255].len);
  			}
  
+ 			if (pMB->cbp & (1 << (5 - i))) {
+ 				bits = BitstreamPos(bs);
+ 
+ 				CodeCoeff(bs,
+ 					  &qcoeff[i*64],
+ 					  intra_table,
+ 					  scan_tables[pMB->acpred_directions[i]],
+ 					  1);
+ 
+ 				pStat->iTextBits += BitstreamPos(bs) - bits;
+ 			}
+ #ifdef MPEG4IP
+ 		}
+ #endif
+ 	}
  }
  
  
Index: lib/xvid/prediction/mbprediction.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/prediction/mbprediction.c,v
retrieving revision 1.1
retrieving revision 1.3
diff -c -w -r1.1 -r1.3
*** lib/xvid/prediction/mbprediction.c	2002/04/26 18:31:19	1.1
--- lib/xvid/prediction/mbprediction.c	2002/09/09 21:11:43	1.3
***************
*** 383,389 ****
--- 383,397 ----
  		
  		for(j = 0; j < 6; j++) 
  		{
+ #ifdef MPEG4IP_H263_DC
+ 			if ((pParam->global_flags & XVID_SHORT_HEADERS) != 0) {
+ 				iDcScaler = 16;
+ 			} else {
  				iDcScaler = get_dc_scaler(iQuant, (j < 4) ? 1 : 0);
+ 			}
+ #else
+ 			iDcScaler = get_dc_scaler(iQuant, (j < 4) ? 1 : 0);
+ #endif
  
  			predict_acdc(mbs,
  				     x,
***************
*** 403,409 ****
--- 411,421 ----
  
  		}
  
+ #ifdef MPEG4IP_H263_NOACPRED
+ 		if (S < 0 || (pParam->global_flags & XVID_SHORT_HEADERS) != 0)
+ #else
  		if (S < 0)		// dont predict
+ #endif
  		{			
  			for(j = 0; j < 6; j++) 
  			{
Index: lib/xvid/utils/mbtransquant.c
===================================================================
RCS file: /vws/pan/mpeg4ip/lib/xvid/utils/mbtransquant.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
*** lib/xvid/utils/mbtransquant.c	2002/04/26 18:31:19	1.1
--- lib/xvid/utils/mbtransquant.c	2002/09/09 21:11:43	1.2
***************
*** 120,125 ****
--- 120,130 ----
  
  		if (pParam->quant_type == H263_QUANT)
  		{
+ #ifdef MPEG4IP_H263_DC
+ 			if ((pParam->global_flags & XVID_SHORT_HEADERS) != 0) {
+ 				iDcScaler = 16;
+ 			}
+ #endif
  			start_timer();
  			quant_intra(&qcoeff[i*64], &data[i*64], iQuant, iDcScaler);
  			stop_quant_timer();
Index: player/lib/rtsp/rtsp.c
===================================================================
RCS file: /vws/pan/mpeg4ip/player/lib/rtsp/rtsp.c,v
retrieving revision 1.11
retrieving revision 1.12
diff -c -w -r1.11 -r1.12
*** player/lib/rtsp/rtsp.c	2002/06/18 22:37:43	1.11
--- player/lib/rtsp/rtsp.c	2002/07/16 22:52:25	1.12
***************
*** 38,47 ****
      SDL_DestroyMutex(rptr->msg_mutex);
      rptr->msg_mutex = NULL;
    }
!   CHECK_AND_FREE(rptr, orig_url);
!   CHECK_AND_FREE(rptr, url);
!   CHECK_AND_FREE(rptr, server_name);
!   CHECK_AND_FREE(rptr, cookie);
    free_decode_response(rptr->decode_response);
    rptr->decode_response = NULL;
    free(rptr);
--- 38,47 ----
      SDL_DestroyMutex(rptr->msg_mutex);
      rptr->msg_mutex = NULL;
    }
!   CHECK_AND_FREE(rptr->orig_url);
!   CHECK_AND_FREE(rptr->url);
!   CHECK_AND_FREE(rptr->server_name);
!   CHECK_AND_FREE(rptr->cookie);
    free_decode_response(rptr->decode_response);
    rptr->decode_response = NULL;
    free(rptr);
Index: player/lib/rtsp/rtsp_comm.c
===================================================================
RCS file: /vws/pan/mpeg4ip/player/lib/rtsp/rtsp_comm.c,v
retrieving revision 1.25
retrieving revision 1.26
diff -c -w -r1.25 -r1.26
*** player/lib/rtsp/rtsp_comm.c	2002/05/13 16:58:09	1.25
--- player/lib/rtsp/rtsp_comm.c	2002/07/16 22:52:25	1.26
***************
*** 271,276 ****
      closesocket(info->server_socket);
    info->server_socket = -1;
  #ifdef HAVE_ST_ADDRINFO
!   CHECK_AND_FREE(info,addr_info);
  #endif
  }
--- 271,276 ----
      closesocket(info->server_socket);
    info->server_socket = -1;
  #ifdef HAVE_ST_ADDRINFO
!   CHECK_AND_FREE(info->addr_info);
  #endif
  }
Index: player/lib/rtsp/rtsp_private.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/lib/rtsp/rtsp_private.h,v
retrieving revision 1.22
retrieving revision 1.23
diff -c -w -r1.22 -r1.23
*** player/lib/rtsp/rtsp_private.h	2002/05/08 20:08:43	1.22
--- player/lib/rtsp/rtsp_private.h	2002/07/16 22:52:26	1.23
***************
*** 33,39 ****
   * Some useful macros.
   */
  #define ADV_SPACE(a) {while (isspace(*(a)) && (*(a) != '\0'))(a)++;}
- #define CHECK_AND_FREE(a, b) { if (a->b != NULL) { free(a->b); a->b = NULL;}}
  
  /*
   * Session structure.
--- 33,38 ----
Index: player/lib/rtsp/rtsp_util.c
===================================================================
RCS file: /vws/pan/mpeg4ip/player/lib/rtsp/rtsp_util.c,v
retrieving revision 1.20
retrieving revision 1.21
diff -c -w -r1.20 -r1.21
*** player/lib/rtsp/rtsp_util.c	2002/05/13 16:58:09	1.20
--- player/lib/rtsp/rtsp_util.c	2002/07/16 22:52:26	1.21
***************
*** 62,69 ****
  
  void free_session_info (rtsp_session_t *session)
  {
!   CHECK_AND_FREE(session, session);
!   CHECK_AND_FREE(session, url);
    free(session);
  }
  
--- 62,69 ----
  
  void free_session_info (rtsp_session_t *session)
  {
!   CHECK_AND_FREE(session->session);
!   CHECK_AND_FREE(session->url);
    free(session);
  }
  
***************
*** 73,116 ****
   */
  void clear_decode_response (rtsp_decode_t *resp)
  {
!   CHECK_AND_FREE(resp, retresp);
!   CHECK_AND_FREE(resp, body);
!   CHECK_AND_FREE(resp, accept);
!   CHECK_AND_FREE(resp, accept_encoding);
!   CHECK_AND_FREE(resp, accept_language);
!   CHECK_AND_FREE(resp, allow_public);
!   CHECK_AND_FREE(resp, authorization);
!   CHECK_AND_FREE(resp, bandwidth);
!   CHECK_AND_FREE(resp, blocksize);
!   CHECK_AND_FREE(resp, cache_control);
!   CHECK_AND_FREE(resp, content_base);
!   CHECK_AND_FREE(resp, content_encoding);
!   CHECK_AND_FREE(resp, content_language);
!   CHECK_AND_FREE(resp, content_location);
!   CHECK_AND_FREE(resp, content_type);
!   CHECK_AND_FREE(resp, cookie);
!   CHECK_AND_FREE(resp, date);
!   CHECK_AND_FREE(resp, expires);
!   CHECK_AND_FREE(resp, from);
!   CHECK_AND_FREE(resp, if_modified_since);
!   CHECK_AND_FREE(resp, last_modified);
!   CHECK_AND_FREE(resp, location);
!   CHECK_AND_FREE(resp, proxy_authenticate);
!   CHECK_AND_FREE(resp, proxy_require);
!   CHECK_AND_FREE(resp, range);
!   CHECK_AND_FREE(resp, referer);
!   CHECK_AND_FREE(resp, require);
!   CHECK_AND_FREE(resp, retry_after);
!   CHECK_AND_FREE(resp, rtp_info);
!   CHECK_AND_FREE(resp, scale);
!   CHECK_AND_FREE(resp, server);
!   CHECK_AND_FREE(resp, session);
!   CHECK_AND_FREE(resp, speed);
!   CHECK_AND_FREE(resp, transport);
!   CHECK_AND_FREE(resp, unsupported);
!   CHECK_AND_FREE(resp, user_agent);
!   CHECK_AND_FREE(resp, via);
!   CHECK_AND_FREE(resp, www_authenticate);
    resp->content_length = 0;
    resp->cseq = 0;
    resp->close_connection = FALSE;
--- 73,116 ----
   */
  void clear_decode_response (rtsp_decode_t *resp)
  {
!   CHECK_AND_FREE(resp->retresp);
!   CHECK_AND_FREE(resp->body);
!   CHECK_AND_FREE(resp->accept);
!   CHECK_AND_FREE(resp->accept_encoding);
!   CHECK_AND_FREE(resp->accept_language);
!   CHECK_AND_FREE(resp->allow_public);
!   CHECK_AND_FREE(resp->authorization);
!   CHECK_AND_FREE(resp->bandwidth);
!   CHECK_AND_FREE(resp->blocksize);
!   CHECK_AND_FREE(resp->cache_control);
!   CHECK_AND_FREE(resp->content_base);
!   CHECK_AND_FREE(resp->content_encoding);
!   CHECK_AND_FREE(resp->content_language);
!   CHECK_AND_FREE(resp->content_location);
!   CHECK_AND_FREE(resp->content_type);
!   CHECK_AND_FREE(resp->cookie);
!   CHECK_AND_FREE(resp->date);
!   CHECK_AND_FREE(resp->expires);
!   CHECK_AND_FREE(resp->from);
!   CHECK_AND_FREE(resp->if_modified_since);
!   CHECK_AND_FREE(resp->last_modified);
!   CHECK_AND_FREE(resp->location);
!   CHECK_AND_FREE(resp->proxy_authenticate);
!   CHECK_AND_FREE(resp->proxy_require);
!   CHECK_AND_FREE(resp->range);
!   CHECK_AND_FREE(resp->referer);
!   CHECK_AND_FREE(resp->require);
!   CHECK_AND_FREE(resp->retry_after);
!   CHECK_AND_FREE(resp->rtp_info);
!   CHECK_AND_FREE(resp->scale);
!   CHECK_AND_FREE(resp->server);
!   CHECK_AND_FREE(resp->session);
!   CHECK_AND_FREE(resp->speed);
!   CHECK_AND_FREE(resp->transport);
!   CHECK_AND_FREE(resp->unsupported);
!   CHECK_AND_FREE(resp->user_agent);
!   CHECK_AND_FREE(resp->via);
!   CHECK_AND_FREE(resp->www_authenticate);
    resp->content_length = 0;
    resp->cseq = 0;
    resp->close_connection = FALSE;
***************
*** 251,260 ****
      info->orig_url = info->url;
      info->url = NULL;
    } else {
!     CHECK_AND_FREE(info, url);
    }
  
!   CHECK_AND_FREE(info, server_name);
    rtsp_close_socket(info);
  
    ret = rtsp_dissect_url(info, decode->location);
--- 251,260 ----
      info->orig_url = info->url;
      info->url = NULL;
    } else {
!     CHECK_AND_FREE(info->url);
    }
  
!   CHECK_AND_FREE(info->server_name);
    rtsp_close_socket(info);
  
    ret = rtsp_dissect_url(info, decode->location);
Index: player/plugin/Makefile.am
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/Makefile.am,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
*** player/plugin/Makefile.am	2002/03/05 21:59:12	1.1
--- player/plugin/Makefile.am	2002/08/26 21:58:24	1.2
***************
*** 1 ****
! SUBDIRS = audio video
--- 1 ----
! SUBDIRS = audio video rtp
Index: player/plugin/audio/Makefile.am
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/audio/Makefile.am,v
retrieving revision 1.2
retrieving revision 1.4
diff -c -w -r1.2 -r1.4
Index: player/plugin/audio/celp/celp.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/audio/celp/celp.cpp,v
retrieving revision 1.9
retrieving revision 1.10
diff -c -w -r1.9 -r1.10
*** player/plugin/audio/celp/celp.cpp	2002/07/09 22:21:24	1.9
--- player/plugin/audio/celp/celp.cpp	2002/08/19 18:29:47	1.10
***************
*** 40,46 ****
   */
  
  
! static codec_data_t *celp_codec_create (format_list_t *media_fmt,
  					audio_info_t *audio,
  					const uint8_t *userdata,
  					uint32_t userdata_size,
--- 40,49 ----
   */
  
  
! static codec_data_t *celp_codec_create (const char *compressor, 
! 					int type, 
! 					int profile, 
! 					format_list_t *media_fmt,
  					audio_info_t *audio,
  					const uint8_t *userdata,
  					uint32_t userdata_size,
Index: player/plugin/audio/raw/rawa.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/audio/raw/rawa.cpp,v
retrieving revision 1.11
retrieving revision 1.13
diff -c -w -r1.11 -r1.13
*** player/plugin/audio/raw/rawa.cpp	2002/07/09 22:21:24	1.11
--- player/plugin/audio/raw/rawa.cpp	2002/08/19 18:29:47	1.13
***************
*** 25,31 ****
  /*
   * Create raw audio structure
   */
! static codec_data_t *rawa_codec_create (format_list_t *media_fmt,
  					audio_info_t *audio,
  					const uint8_t *userdata,
  					uint32_t userdata_size,
--- 25,34 ----
  /*
   * Create raw audio structure
   */
! static codec_data_t *rawa_codec_create (const char *compressor, 
! 					int type, 
! 					int profile, 
! 					format_list_t *media_fmt,
  					audio_info_t *audio,
  					const uint8_t *userdata,
  					uint32_t userdata_size,
***************
*** 90,95 ****
--- 93,99 ----
  {
    rawa_codec_t *rawa = (rawa_codec_t *)ifptr;
    rawa->m_resync = 1;
+   //LOGIT(LOG_DEBUG, "rawa", "do pause");
  }
  
  /*
***************
*** 153,159 ****
  				     rawa->m_temp_buffsize,
  				     0, 
  				     1);
! 
        if (ts == 0) rawa->m_bytes = rawa->m_temp_buffsize;
        free(rawa->m_temp_buff);
        rawa->m_temp_buff = NULL;
--- 157,163 ----
  				     rawa->m_temp_buffsize,
  				     0, 
  				     1);
!       rawa->m_resync = 0;
        if (ts == 0) rawa->m_bytes = rawa->m_temp_buffsize;
        free(rawa->m_temp_buff);
        rawa->m_temp_buff = NULL;
***************
*** 170,176 ****
      ts += calc;
      rawa->m_bytes += buflen;
    } else {
!     rawa->m_bytes = 0;
      rawa->m_ts = ts;
    }
  
--- 174,180 ----
      ts += calc;
      rawa->m_bytes += buflen;
    } else {
!     rawa->m_bytes = buflen;
      rawa->m_ts = ts;
    }
  
Index: player/plugin/video/mpeg3/Makefile.am
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/video/mpeg3/Makefile.am,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -w -r1.6 -r1.7
*** player/plugin/video/mpeg3/Makefile.am	2002/07/10 17:00:16	1.6
--- player/plugin/video/mpeg3/Makefile.am	2002/07/25 17:05:23	1.7
***************
*** 7,13 ****
  mpeg3_video_plugin_la_LIBADD = \
  	-lm \
  	$(top_builddir)/common/video/libmpeg32/video/libmpeg3video.la \
! 	$(top_builddir)/common/video/libmpeg32/libmpeg3util.la
  
  INCLUDES = -I$(top_srcdir)/player/src -I$(top_srcdir)/player/lib -I$(top_srcdir)/lib/SDL/include -I$(top_srcdir)/include -I$(top_srcdir)/lib -I$(top_srcdir)/common/video/libmpeg32 -I$(top_srcdir)/common/video/libmpeg32/video -I$(top_srcdir)/lib/mp4av -I$(top_srcdir)/lib/mp4v2
  
--- 7,14 ----
  mpeg3_video_plugin_la_LIBADD = \
  	-lm \
  	$(top_builddir)/common/video/libmpeg32/video/libmpeg3video.la \
! 	$(top_builddir)/common/video/libmpeg32/libmpeg3util.la \
! 	@SDL_LIBS@
  
  INCLUDES = -I$(top_srcdir)/player/src -I$(top_srcdir)/player/lib -I$(top_srcdir)/lib/SDL/include -I$(top_srcdir)/include -I$(top_srcdir)/lib -I$(top_srcdir)/common/video/libmpeg32 -I$(top_srcdir)/common/video/libmpeg32/video -I$(top_srcdir)/lib/mp4av -I$(top_srcdir)/lib/mp4v2
  
Index: player/plugin/video/mpeg3/mpeg3.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/video/mpeg3/mpeg3.cpp,v
retrieving revision 1.13
retrieving revision 1.18
diff -c -w -r1.13 -r1.18
*** player/plugin/video/mpeg3/mpeg3.cpp	2002/07/09 22:21:24	1.13
--- player/plugin/video/mpeg3/mpeg3.cpp	2002/08/19 18:29:47	1.18
***************
*** 26,35 ****
  #include <mpeg3videoprotos.h>
  #include <bitstream.h>
  #include "mp4av.h"
  
  //#define DEBUG_MPEG3_FRAME 1
  
! static codec_data_t *mpeg3_create (format_list_t *media_fmt,
  				   video_info_t *vinfo,
  				   const uint8_t *userdata,
  				   uint32_t ud_size,
--- 26,39 ----
  #include <mpeg3videoprotos.h>
  #include <bitstream.h>
  #include "mp4av.h"
+ #include <mpeg2t/mpeg2_transport.h>
  
  //#define DEBUG_MPEG3_FRAME 1
  
! static codec_data_t *mpeg3_create (const char *compressor,
! 				   int type, 
! 				   int profile, 
! 				   format_list_t *media_fmt,
  				   video_info_t *vinfo,
  				   const uint8_t *userdata,
  				   uint32_t ud_size,
***************
*** 99,104 ****
--- 103,110 ----
    int render = 1;
    mpeg3_codec_t *mpeg3 = (mpeg3_codec_t *)ptr;
    mpeg3video_t *video;
+   char *y, *u, *v;
+ 
    video = mpeg3->m_video;
  
    buffer[buflen] = 0;
***************
*** 128,133 ****
--- 134,141 ----
      if (video->found_seqhdr != 0) {
        mpeg3video_initdecoder(video);
        video->decoder_initted = 1;
+       mpeg3->m_vft->log_msg(LOG_DEBUG, "mpeg3", "h %d w %d", 
+ 			    video->vertical_size, video->horizontal_size);
        mpeg3->m_h = video->vertical_size;
        mpeg3->m_w = video->horizontal_size;
        mpeg3->m_vft->video_configure(mpeg3->m_ifptr, 
***************
*** 136,142 ****
  				    VIDEO_FORMAT_YUV);
        // Gross and disgusting, but it looks like it didn't clean up
        // properly - so just start from beginning of buffer and decode.
!     } else {
        mpeg3->m_vft->log_msg(LOG_DEBUG, "mpeg3", "didnt find seq header in frame %llu", ts);
        return buflen;
      }
--- 144,156 ----
  				    VIDEO_FORMAT_YUV);
        // Gross and disgusting, but it looks like it didn't clean up
        // properly - so just start from beginning of buffer and decode.
!  y = NULL;
!   ret = mpeg3video_read_yuvframe_ptr(video,
! 				     (unsigned char *)buffer,
! 				     buflen + 3,
! 				     &y,
! 				     &u,
! 				     &v);    } else {
        mpeg3->m_vft->log_msg(LOG_DEBUG, "mpeg3", "didnt find seq header in frame %llu", ts);
        return buflen;
      }
***************
*** 163,170 ****
        }
      }
  
-   char *y, *u, *v;
- 
  #if 0
    if (from_rtp) {
      int ftype;
--- 177,182 ----
***************
*** 232,237 ****
--- 244,254 ----
    }
    if (compressor != NULL && strcmp(compressor, "MPEG FILE") == 0) {
      return 1;
+   }
+   if (compressor != NULL && strcmp(compressor, "MPEG2 TRANSPORT") == 0) {
+     if ((type == MPEG2T_ST_MPEG_VIDEO) ||
+ 	(type == MPEG2T_ST_11172_VIDEO)) 
+       return 1;
    }
    return -1;
  }
Index: player/plugin/video/raw/rawv.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/video/raw/rawv.cpp,v
retrieving revision 1.10
retrieving revision 1.11
diff -c -w -r1.10 -r1.11
*** player/plugin/video/raw/rawv.cpp	2002/07/09 22:21:24	1.10
--- player/plugin/video/raw/rawv.cpp	2002/08/19 18:29:47	1.11
***************
*** 26,32 ****
  #include <mp4v2/mp4.h>
  
  
! static codec_data_t *rawv_create (format_list_t *media_fmt,
  				  video_info_t *vinfo,
  				  const uint8_t *userdata,
  				  uint32_t ud_size,
--- 26,35 ----
  #include <mp4v2/mp4.h>
  
  
! static codec_data_t *rawv_create (const char *compressor, 
! 				  int type, 
! 				  int profile, 
! 				  format_list_t *media_fmt,
  				  video_info_t *vinfo,
  				  const uint8_t *userdata,
  				  uint32_t ud_size,
Index: player/plugin/video/xvid/ourxvid.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/video/xvid/ourxvid.cpp,v
retrieving revision 1.9
retrieving revision 1.12
diff -c -w -r1.9 -r1.12
*** player/plugin/video/xvid/ourxvid.cpp	2002/07/09 22:21:24	1.9
--- player/plugin/video/xvid/ourxvid.cpp	2002/08/21 22:53:21	1.12
***************
*** 106,112 ****
    return ret;
  }
  
! static codec_data_t *xvid_create (format_list_t *media_fmt,
  				  video_info_t *vinfo,
  				  const uint8_t *userdata,
  				  uint32_t ud_size,
--- 106,115 ----
    return ret;
  }
  
! static codec_data_t *xvid_create (const char *compressor, 
! 				  int type, 
! 				  int profile,
! 				  format_list_t *media_fmt,
  				  video_info_t *vinfo,
  				  const uint8_t *userdata,
  				  uint32_t ud_size,
***************
*** 245,251 ****
  		      &frame,
  		      &param);
  
!     if (ret > 0) {
  	xvid->m_decodeState = XVID_STATE_WAIT_I;
  	xvid->m_vft->video_configure(xvid->m_ifptr, 
  				     param.width,
--- 248,254 ----
  		      &frame,
  		      &param);
  
!     if (ret == XVID_ERR_OK) {
  	xvid->m_decodeState = XVID_STATE_WAIT_I;
  	xvid->m_vft->video_configure(xvid->m_ifptr, 
  				     param.width,
***************
*** 327,332 ****
--- 330,338 ----
      if ((type == MP4_MPEG4_VIDEO_TYPE) &&
  	(profile >= 1 && profile <= 3)) {
        return 3;
+     }
+     if (type == MP4_H263_VIDEO_TYPE) {
+       return 2;
      }
      return -1;
    }
Index: player/plugin/video/xvid/ourxvid.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/video/xvid/ourxvid.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** player/plugin/video/xvid/ourxvid.h	2002/06/04 00:02:25	1.4
--- player/plugin/video/xvid/ourxvid.h	2002/08/02 20:18:20	1.5
***************
*** 49,55 ****
    uint32_t m_frame_on;
    CFilePosRecorder *m_fpos;
    video_info_t *m_vinfo;
! 
    void *m_xvid_handle;
  } xvid_codec_t;
  
--- 49,55 ----
    uint32_t m_frame_on;
    CFilePosRecorder *m_fpos;
    video_info_t *m_vinfo;
!   int m_short_headers;
    void *m_xvid_handle;
  } xvid_codec_t;
  
Index: player/plugin/video/xvid/xvid_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/plugin/video/xvid/xvid_file.cpp,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** player/plugin/video/xvid/xvid_file.cpp	2002/06/05 18:46:35	1.4
--- player/plugin/video/xvid/xvid_file.cpp	2002/08/02 20:18:20	1.5
***************
*** 35,43 ****
  {
    for (uint32_t ix = start_offset; ix + 4 < xvid->m_buffer_size; ix++) {
      if ((xvid->m_buffer[ix] == 0) &&
! 	(xvid->m_buffer[ix + 1] == 0) &&
! 	(xvid->m_buffer[ix + 2] == 1)) {
        return ix;
      }
    }
    return -1;
--- 35,48 ----
  {
    for (uint32_t ix = start_offset; ix + 4 < xvid->m_buffer_size; ix++) {
      if ((xvid->m_buffer[ix] == 0) &&
! 	(xvid->m_buffer[ix + 1] == 0)) {
!       if (xvid->m_buffer[ix + 2] == 1)
  	return ix;
+       if (((xvid->m_buffer[ix + 2] & 0xfc) == 0x80) && 
+ 	  ((xvid->m_buffer[ix + 3] & 0x3) == 0x02)) {
+ 	xvid->m_short_headers = 1;
+ 	return ix;
+       }
      }
    }
    return -1;
***************
*** 92,98 ****
    xvid->m_buffer_on = next_hdr;
  
    // Is it a VOP header ?  If not, find the first VOP header
!   if (xvid->m_buffer[next_hdr + 3] != 0xb6) {
      value = 0;
      do {
        // Increment when we've got a header pointed to by next_hdr
--- 97,104 ----
    xvid->m_buffer_on = next_hdr;
  
    // Is it a VOP header ?  If not, find the first VOP header
!   if (xvid->m_short_headers == 0 &&
!       xvid->m_buffer[next_hdr + 3] != 0xb6) {
      value = 0;
      do {
        // Increment when we've got a header pointed to by next_hdr
***************
*** 122,128 ****
  
    // next_hdr contains the location of the first VOP.
    // Record the file type (top 2 bits) after 00 00 01 b6
!   *ftype = xvid->m_buffer[next_hdr + 4];
  
    // Find the next header.
    value = xvid_find_header(xvid, next_hdr + 4);
--- 128,137 ----
  
    // next_hdr contains the location of the first VOP.
    // Record the file type (top 2 bits) after 00 00 01 b6
!   if (xvid->m_short_headers == 0) 
!     *ftype = (xvid->m_buffer[next_hdr + 4] >> 6) & 0x3;
!   else
!     *ftype = (xvid->m_buffer[next_hdr + 4] >> 1) & 0x1;
  
    // Find the next header.
    value = xvid_find_header(xvid, next_hdr + 4);
***************
*** 184,190 ****
     */
    len = strlen(name);
    if (!((strcasecmp(name + len - 5, ".divx") == 0) ||
! 	(strcasecmp(name + len - 5, ".xvid") == 0))) {
      return NULL;
    }
  
--- 193,200 ----
     */
    len = strlen(name);
    if (!((strcasecmp(name + len - 5, ".divx") == 0) ||
! 	(strcasecmp(name + len - 5, ".xvid") == 0) ||
! 	(strcasecmp(name + len - 5, ".h263") == 0))) {
      return NULL;
    }
  
***************
*** 243,249 ****
  	xvid->m_buffer_on = xvid->m_buffer_size - 3;
      } else {
        // If we have an I_VOP, mark it.
!       if ((ftype & 0xc0) == 0) {
  	calc = framecount * 1000;
  	
  	calc /= 30;
--- 253,259 ----
  	xvid->m_buffer_on = xvid->m_buffer_size - 3;
      } else {
        // If we have an I_VOP, mark it.
!       if (ftype == 0) {
  	calc = framecount * 1000;
  	
  	calc /= 30;
***************
*** 287,310 ****
    next_hdr = xvid_find_header(xvid, xvid->m_buffer_on);
    if (next_hdr < 0) {
      next_hdr = xvid_reset_buffer(xvid);
!     if (next_hdr < 0) return 0;
      next_hdr = xvid_find_header(xvid, next_hdr);
!     if (next_hdr < 0) return 0;
    }
    xvid->m_buffer_on = next_hdr;
  
    value = 0;
!   // find first vop
    while (xvid->m_buffer[next_hdr + 3] != 0xb6) {
      value = xvid_find_header(xvid, next_hdr + 4);
      if (value < 0) {
        value = xvid_reset_buffer(xvid);
!       if (value < 0) return 0;
        next_hdr = xvid_find_header(xvid, value - 4);
      } else {
        next_hdr = value;
      }
    }
  
    // find the next start code, so we have 1 frame in buffer
    // Don't have to worry about going past end of buffer, or buffer length
--- 297,331 ----
    next_hdr = xvid_find_header(xvid, xvid->m_buffer_on);
    if (next_hdr < 0) {
      next_hdr = xvid_reset_buffer(xvid);
!     if (next_hdr < 0) {
!       xvid->m_buffer_on = xvid->m_buffer_size;
!       return 0;
!     }
      next_hdr = xvid_find_header(xvid, next_hdr);
!     if (next_hdr < 0) {
!       xvid->m_buffer_on = xvid->m_buffer_size;
!       return 0;
      }
+   }
    xvid->m_buffer_on = next_hdr;
  
    value = 0;
!   // find first vop -short headers are always next frame
!   if (xvid->m_short_headers == 0) {
      while (xvid->m_buffer[next_hdr + 3] != 0xb6) {
        value = xvid_find_header(xvid, next_hdr + 4);
        if (value < 0) {
  	value = xvid_reset_buffer(xvid);
! 	if (value < 0) {
! 	  xvid->m_buffer_on = xvid->m_buffer_size;
! 	  return 0;
! 	}
  	next_hdr = xvid_find_header(xvid, value - 4);
        } else {
  	next_hdr = value;
        }
      }
+   }
  
    // find the next start code, so we have 1 frame in buffer
    // Don't have to worry about going past end of buffer, or buffer length
***************
*** 331,336 ****
--- 352,358 ----
  {
    xvid_codec_t *xvid = (xvid_codec_t *)your;
    xvid->m_buffer_on += bytes;
+   xvid->m_vft->log_msg(LOG_DEBUG, "xvid", "used %u bytes", bytes);
  }
  
  /*
Index: player/src/Makefile.am
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/Makefile.am,v
retrieving revision 1.69
retrieving revision 1.73
diff -c -w -r1.69 -r1.73
*** player/src/Makefile.am	2002/07/11 19:11:34	1.69
--- player/src/Makefile.am	2002/08/26 22:27:57	1.73
***************
*** 58,63 ****
--- 58,65 ----
  	media_utils.cpp \
  	media_utils.h \
  	mpeg2t.h \
+ 	mpeg2t_bytestream.cpp \
+ 	mpeg2t_bytestream.h \
  	mpeg2t_private.h \
  	mpeg2t_thread.cpp \
  	mpeg2t_thread.h \
***************
*** 94,99 ****
--- 96,104 ----
  	rfc3119_bytestream.h \
  	rtp_bytestream.cpp \
  	rtp_bytestream.h \
+ 	rtp_bytestream_plugin.cpp \
+ 	rtp_bytestream_plugin.h \
+ 	rtp_plugin.h \
  	sync.cpp 
  
  if NO_GLIB_GTK
***************
*** 126,136 ****
  AM_CXXFLAGS = -D_REENTRANT -DNOCONTROLS -fexceptions @BILLS_CPPWARNINGS@ -DPLAYER_PLUGIN_DIR=\"@PLAYER_PLUGIN_DIR@\"
  
  libmp4player_la_LIBADD = \
- 	codec/aa/libaa.la \
- 	codec/mp3/libmp3.la \
  	$(top_builddir)/lib/mpeg2t/libmpeg2_transport.la \
  	$(top_builddir)/common/video/libmpeg32/libmpeg3.la \
  	$(top_builddir)/player/lib/audio/mp3util/libmp3utils.la \
  	$(top_builddir)/lib/sdp/libsdp.la \
  	$(top_builddir)/player/lib/mp4util/libmp4util.la \
  	$(top_builddir)/player/lib/libhttp/libhttp.la \
--- 131,140 ----
  AM_CXXFLAGS = -D_REENTRANT -DNOCONTROLS -fexceptions @BILLS_CPPWARNINGS@ -DPLAYER_PLUGIN_DIR=\"@PLAYER_PLUGIN_DIR@\"
  
  libmp4player_la_LIBADD = \
  	$(top_builddir)/lib/mpeg2t/libmpeg2_transport.la \
  	$(top_builddir)/common/video/libmpeg32/libmpeg3.la \
  	$(top_builddir)/player/lib/audio/mp3util/libmp3utils.la \
+ 	$(top_builddir)/lib/gnu/libmpeg4ip_gnu.la \
  	$(top_builddir)/lib/sdp/libsdp.la \
  	$(top_builddir)/player/lib/mp4util/libmp4util.la \
  	$(top_builddir)/player/lib/libhttp/libhttp.la \
***************
*** 143,149 ****
  	$(top_builddir)/lib/mp4/libmp4.la \
  	$(top_builddir)/lib/mp4v2/libmp4v2.la \
  	$(top_builddir)/lib/avi/libavi.la \
! 	$(top_builddir)/lib/gnu/libmpeg4ip_gnu.la
  
  mp4player_LDADD = \
  	-lm \
--- 147,153 ----
  	$(top_builddir)/lib/mp4/libmp4.la \
  	$(top_builddir)/lib/mp4v2/libmp4v2.la \
  	$(top_builddir)/lib/avi/libavi.la \
! 	-ldl
  
  mp4player_LDADD = \
  	-lm \
Index: player/src/audio_sdl.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/audio_sdl.cpp,v
retrieving revision 1.10
retrieving revision 1.17
diff -c -w -r1.10 -r1.17
*** player/src/audio_sdl.cpp	2002/07/02 21:02:13	1.10
--- player/src/audio_sdl.cpp	2002/08/26 23:43:56	1.17
***************
*** 28,33 ****
--- 28,34 ----
  #include "audio_sdl.h"
  #include "player_util.h"
  #include <SDL_thread.h>
+ #include "our_config_file.h"
  //#define DEBUG_SYNC 1
  //#define DEBUG_AUDIO_FILL 1
  //#define DEBUG_DELAY 1
***************
*** 63,69 ****
    m_config_set = 0;
    m_audio_initialized = 0;
    m_audio_paused = 1;
!   m_resync_required = 1;
    m_dont_fill = 0;
    m_consec_no_buffers = 0;
    //SDL_Init(SDL_INIT_AUDIO);
--- 64,70 ----
    m_config_set = 0;
    m_audio_initialized = 0;
    m_audio_paused = 1;
!   m_resync_required = 0;
    m_dont_fill = 0;
    m_consec_no_buffers = 0;
    //SDL_Init(SDL_INIT_AUDIO);
***************
*** 97,102 ****
--- 98,104 ----
  		"Audio sync skipped %u buffers", 
  		m_skipped_buffers);
    audio_message(LOG_NOTICE, "didn't fill %u buffers", m_didnt_fill_buffers);
+   SDL_DestroySemaphore(m_audio_waiting);
  }
  
  /*
***************
*** 121,126 ****
--- 123,129 ----
      while ((temp & 0x1) == 0) temp >>= 1;
  
      sample_size = temp;
+     while (sample_size < 1024) sample_size *= 2;
    } 
    
    m_buffer_size = channels * sample_size * m_bytes_per_sample;
***************
*** 197,221 ****
  {
    uint8_t *to;
    uint32_t copied;
-   int64_t diff, calc;
  #ifdef DEBUG_AUDIO_FILL
!   audio_message(LOG_DEBUG, "fill %d bytes at "LLU", offset %d", 
! 		bytes, ts, m_buffer_offset_on);
  #endif
    copied = 0;
    if (m_buffer_offset_on == 0) {
      if (m_buffer_ts != 0 && m_buffer_ts != ts) {
        m_load_audio_do_next_resync = 1;
      }
      m_buffer_ts = ts;
    } else {
!     diff = ts - m_buffer_ts;
!     calc = m_buffer_offset_on * M_LLU;
!     calc /= m_bytes_per_sample;
!     calc /= m_freq;
!     if (diff > calc + 2) {
!       audio_message(LOG_DEBUG, "potential resync at ts "LLU" diff is "LLD" calc is "LLD, 
! 		    ts, diff, calc);
        uint32_t left;
        left = m_buffer_size - m_buffer_offset_on;
        to = get_audio_buffer();
--- 200,223 ----
  {
    uint8_t *to;
    uint32_t copied;
  #ifdef DEBUG_AUDIO_FILL
!   audio_message(LOG_DEBUG, "fill %d bytes at "LLU", offset %d resync %d", 
! 		bytes, ts, m_buffer_offset_on, resync);
  #endif
    copied = 0;
    if (m_buffer_offset_on == 0) {
      if (m_buffer_ts != 0 && m_buffer_ts != ts) {
        m_load_audio_do_next_resync = 1;
+       audio_message(LOG_DEBUG, "timeslot doesn't match - %llu %llu",
+ 		    ts, m_buffer_ts);
      }
      m_buffer_ts = ts;
    } else {
!     int64_t check;
!     check = ts - m_loaded_next_ts;
!     if (check > m_msec_per_frame) {
!       audio_message(LOG_DEBUG, "potential resync at ts "LLU" should be ts "LLU,
! 		    ts, m_loaded_next_ts);
        uint32_t left;
        left = m_buffer_size - m_buffer_offset_on;
        to = get_audio_buffer();
***************
*** 226,231 ****
--- 228,238 ----
        m_buffer_ts = ts;
      }
    }
+   m_loaded_next_ts = bytes * M_LLU;
+   m_loaded_next_ts /= m_bytes_per_sample;
+   m_loaded_next_ts /= m_freq;
+   m_loaded_next_ts += ts;
+ 
    while ( bytes > 0) {
      to = get_audio_buffer();
      if (to == NULL) {
***************
*** 269,274 ****
--- 276,282 ----
    if (m_dont_fill == 1) {
      return;
    }
+   //  resync = 0;
    fill_index = m_fill_index;
    m_fill_index++;
    m_fill_index %= DECODE_BUFFERS_MAX;
***************
*** 280,285 ****
--- 288,295 ----
    }
    if (m_first_filled != 0) {
      m_first_filled = 0;
+     resync = 0;
+     m_resync_required = 0;
    } else {
      int64_t diff;
      diff = ts - m_last_fill_timestamp;
***************
*** 290,295 ****
--- 300,309 ----
  		    "Filling - last %llu new %llu", m_last_fill_timestamp, ts);
  #endif
        if (diff > ((m_msec_per_frame + 1) * 4)) {
+ #ifdef DEBUG_AUDIO_FILL
+       audio_message(LOG_DEBUG, 
+ 		    "resync required %lld", diff);
+ #endif
  	resync = 1;
        } else {
  	// try to fill the holes
***************
*** 395,400 ****
--- 409,415 ----
      if (m_config_set) {
        SDL_AudioSpec wanted;
        m_do_sync = have_video;
+       memset(&wanted, 0, sizeof(wanted));
        wanted.freq = m_freq;
        wanted.channels = m_channels;
        wanted.format = m_format;
***************
*** 415,420 ****
--- 430,438 ----
  #endif
        if ((m_do_sync == 0) && m_sample_size < 4096)
  	m_sample_size = 4096;
+       if (config.get_config_value(CONFIG_LIMIT_AUDIO_SDL_BUFFER) > 0 &&
+ 	  m_sample_size > 4096) 
+ 	m_sample_size = 4096;
        wanted.samples = m_sample_size;
        wanted.callback = c_audio_callback;
        wanted.userdata = this;
***************
*** 504,511 ****
        } else {
  	if (cmptime >= current_time) {
  	  m_play_index = m_resync_buffer;
  	  play_audio();
! #if 1
  	  audio_message(LOG_INFO, "Resynced audio at " LLU " %u %u", current_time, m_resync_buffer, m_play_index);
  #endif
  	  cmptime = 0;
--- 522,530 ----
        } else {
  	if (cmptime >= current_time) {
  	  m_play_index = m_resync_buffer;
+ 	  m_resync_required = 0;
  	  play_audio();
! #ifdef DEBUG_SYNC
  	  audio_message(LOG_INFO, "Resynced audio at " LLU " %u %u", current_time, m_resync_buffer, m_play_index);
  #endif
  	  cmptime = 0;
***************
*** 655,660 ****
--- 674,683 ----
      uint32_t thislen;
      thislen = m_buffer_size - m_play_sample_index;
      if (len < thislen) thislen = len;
+ #ifdef DEBUG_SYNC
+     audio_message(LOG_DEBUG, "Playing "LLU" offset %d",
+ 		  m_buffer_time[m_play_index], m_play_sample_index);
+ #endif
      SDL_MixAudio(stream, 
  		 (const unsigned char *)&m_sample_buffer[m_play_index][m_play_sample_index],
  		 thislen,
***************
*** 677,684 ****
--- 700,719 ----
        m_play_index %= DECODE_BUFFERS_MAX;
        m_play_sample_index = 0;
        freed_buffer = 1;
+       if (m_resync_required) {
+ 	// resync required from codec side.  Shut down, and notify sync task
+ 	if (m_resync_buffer == m_play_index) {
+ 	  SDL_PauseAudio(1);
+ 	  m_audio_paused = 1;
+ 	  m_psptr->wake_sync_thread();
+ #ifdef DEBUG_SYNC
+ 	  audio_message(LOG_DEBUG, "sempost");
+ #endif
+ 	  len = 0;
+ 	}
        }
      }
+   }
        
    // Increment past this buffer.
    if (m_first_time != 0) {
***************
*** 703,719 ****
  
        if (this_time > index_time + ALLOWED_LATENCY || 
  	  this_time < index_time - ALLOWED_LATENCY) {
! #if DEBUG_SYNC
  	audio_message(LOG_DEBUG, 
! 		      "potential change - index time "LLU" time "LLU, 
! 		      index_time, this_time);
  #endif
  	m_consec_wrong_latency++;
- 	m_wrong_latency_total += this_time - index_time;
  	int64_t test;
! 	test = m_wrong_latency_total / m_consec_wrong_latency;
  	if (test > ALLOWED_LATENCY || test < -ALLOWED_LATENCY) {
! 	  if (m_consec_wrong_latency > 3) {
  	    m_consec_wrong_latency = 0;
  	    m_wrong_latency_total = 0;
  	    m_psptr->adjust_start_time(test);
--- 738,758 ----
  
        if (this_time > index_time + ALLOWED_LATENCY || 
  	  this_time < index_time - ALLOWED_LATENCY) {
! #ifdef DEBUG_SYNC
  	audio_message(LOG_DEBUG, 
! 		      "potential change - index time "LLU" time "LLU" delay %d", 
! 		      index_time, this_time, delay);
  #endif
+ 	if (m_consec_wrong_latency == 0) {
+ 	  m_consec_wrong_latency = 1;
+ 	} else {
  	  m_consec_wrong_latency++;
  	  int64_t test;
! 	  test = this_time - index_time;
! 	  m_wrong_latency_total += test;
! 	  test = m_wrong_latency_total / (m_consec_wrong_latency - 1);
  	  if (test > ALLOWED_LATENCY || test < -ALLOWED_LATENCY) {
! 	    if (m_consec_wrong_latency > 5) {
  	      m_consec_wrong_latency = 0;
  	      m_wrong_latency_total = 0;
  	      m_psptr->adjust_start_time(test);
***************
*** 723,728 ****
--- 762,768 ----
  	    m_consec_wrong_latency = 0;
  	    m_wrong_latency_total = 0;
  	  }
+ 	}
        } else {
  	m_consec_wrong_latency = 0;
  	m_wrong_latency_total = 0;
***************
*** 783,789 ****
  void CSDLAudioSync::play_audio (void)
  {
    m_first_time = 1;
!   m_resync_required = 0;
    m_audio_paused = 0;
    m_play_sample_index = 0;
    SDL_PauseAudio(0);
--- 823,829 ----
  void CSDLAudioSync::play_audio (void)
  {
    m_first_time = 1;
!   //m_resync_required = 0;
    m_audio_paused = 0;
    m_play_sample_index = 0;
    SDL_PauseAudio(0);
Index: player/src/audio_sdl.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/audio_sdl.h,v
retrieving revision 1.5
retrieving revision 1.6
diff -c -w -r1.5 -r1.6
*** player/src/audio_sdl.h	2002/07/02 21:02:13	1.5
--- player/src/audio_sdl.h	2002/07/31 22:44:28	1.6
***************
*** 96,101 ****
--- 96,102 ----
    uint32_t m_play_sample_index;
    uint32_t m_samples_loaded;
    uint32_t m_bytes_per_sample;
+   uint64_t m_loaded_next_ts;
  };
  
  #endif
Index: player/src/avi_bytestream.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/avi_bytestream.cpp,v
retrieving revision 1.19
retrieving revision 1.20
diff -c -w -r1.19 -r1.20
*** player/src/avi_bytestream.cpp	2002/06/04 00:02:25	1.19
--- player/src/avi_bytestream.cpp	2002/07/22 21:52:48	1.20
***************
*** 122,128 ****
    m_byte_on = 0;
  }
  
! void CAviVideoByteStream::set_start_time (uint64_t start)
  {
    m_play_start_time = start;
  
--- 122,128 ----
    m_byte_on = 0;
  }
  
! void CAviVideoByteStream::play (uint64_t start)
  {
    m_play_start_time = start;
  
***************
*** 209,215 ****
    if (m_buffer_on > m_this_frame_size) m_buffer_on = m_this_frame_size;
  }
  
! void CAviAudioByteStream::set_start_time (uint64_t start)
  {
    m_play_start_time = start;
    
--- 209,215 ----
    if (m_buffer_on > m_this_frame_size) m_buffer_on = m_this_frame_size;
  }
  
! void CAviAudioByteStream::play (uint64_t start)
  {
    m_play_start_time = start;
    
Index: player/src/avi_bytestream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/avi_bytestream.h,v
retrieving revision 1.14
retrieving revision 1.15
diff -c -w -r1.14 -r1.15
*** player/src/avi_bytestream.h	2002/06/04 00:02:25	1.14
--- player/src/avi_bytestream.h	2002/07/22 21:52:48	1.15
***************
*** 75,81 ****
  			    uint32_t *buflen,
  			    void **ud);
    void used_bytes_for_frame(uint32_t bytes);
!   void set_start_time (uint64_t start);
    double get_max_playtime (void) {
      double ret = m_frames_max;
      ret /= m_frame_rate;
--- 75,81 ----
  			    uint32_t *buflen,
  			    void **ud);
    void used_bytes_for_frame(uint32_t bytes);
!   void play (uint64_t start);
    double get_max_playtime (void) {
      double ret = m_frames_max;
      ret /= m_frame_rate;
***************
*** 108,114 ****
  			    uint32_t *buflen, 
  			    void **ud);
    void used_bytes_for_frame(uint32_t bytes);
!   void set_start_time(uint64_t start);
    double get_max_playtime (void) {
      return (0.0);
    };
--- 108,114 ----
  			    uint32_t *buflen, 
  			    void **ud);
    void used_bytes_for_frame(uint32_t bytes);
!   void play(uint64_t start);
    double get_max_playtime (void) {
      return (0.0);
    };
Index: player/src/avi_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/avi_file.cpp,v
retrieving revision 1.15
retrieving revision 1.17
diff -c -w -r1.15 -r1.17
*** player/src/avi_file.cpp	2002/07/05 22:03:53	1.15
--- player/src/avi_file.cpp	2002/08/19 18:29:47	1.17
***************
*** 160,165 ****
--- 160,168 ----
  				   0);
      int ret;
      ret = mptr->create_video_plugin(plugin,
+ 				    codec_name,
+ 				    -1,
+ 				    -1,
  				    NULL,
  				    vinfo,
  				    NULL,
***************
*** 177,183 ****
        return (-1);
      }
      vbyte->config(AVI_video_frames(avi), vq.frame_rate);
!     ret = mptr->create_from_file(vbyte, TRUE);
      if (ret != 0) {
        return (-1);
      }
--- 180,186 ----
        return (-1);
      }
      vbyte->config(AVI_video_frames(avi), vq.frame_rate);
!     ret = mptr->create(vbyte, TRUE, errmsg, errlen);
      if (ret != 0) {
        return (-1);
      }
***************
*** 205,210 ****
--- 208,216 ----
    
      int ret;
      ret = mptr->create_audio_plugin(plugin, 
+ 				    aq.compressor,
+ 				    aq.type,
+ 				    aq.profile,
  				    NULL, 
  				    ainfo,
  				    NULL, 
***************
*** 217,223 ****
      }
      abyte = new CAviAudioByteStream(Avifile1);
  
!     ret = mptr->create_from_file(abyte, FALSE);
      if (ret != 0) {
        return (-1);
      }
--- 223,229 ----
      }
      abyte = new CAviAudioByteStream(Avifile1);
  
!     ret = mptr->create(abyte, FALSE, errmsg, errlen);
      if (ret != 0) {
        return (-1);
      }
Index: player/src/codec_plugin.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec_plugin.cpp,v
retrieving revision 1.13
retrieving revision 1.17
diff -c -w -r1.13 -r1.17
*** player/src/codec_plugin.cpp	2002/06/21 22:40:37	1.13
--- player/src/codec_plugin.cpp	2002/08/26 22:27:57	1.17
***************
*** 37,42 ****
--- 37,43 ----
  #include "audio.h"
  #include "video.h"
  
+ #include "rtp_plugin.h"
  /*
   * Portability hacks
   */
***************
*** 74,79 ****
--- 75,88 ----
  
  static codec_plugin_list_t *audio_codecs, *video_codecs;
  
+ typedef struct rtp_plugin_list_t {
+   struct rtp_plugin_list_t *next_rtp_plugin;
+   LIBRARY_HANDLE dl_handle;
+   rtp_plugin_t *rtp_plugin;
+ } rtp_plugin_list_t;
+ 
+ static rtp_plugin_list_t *rtp_plugins;
+ 
  static void close_file_search (dir_list_t *ptr)
  {
  #ifndef _WIN32
***************
*** 133,143 ****
  {
    LIBRARY_HANDLE handle;
    codec_plugin_t *cptr;
    dir_list_t dir;
    const char *fname;
  
    audio_codecs = video_codecs = NULL;
! 
    fname = get_first_file(&dir, PLAYER_PLUGIN_DIR);
  
    while (fname != NULL) {
--- 142,153 ----
  {
    LIBRARY_HANDLE handle;
    codec_plugin_t *cptr;
+   rtp_plugin_t *rptr;
    dir_list_t dir;
    const char *fname;
  
    audio_codecs = video_codecs = NULL;
!   rtp_plugins = NULL;
    fname = get_first_file(&dir, PLAYER_PLUGIN_DIR);
  
    while (fname != NULL) {
***************
*** 174,183 ****
  		    cptr->c_type, fname);
  	  }
  	} else {
! 	  message(LOG_ERR, "plugin", "Plugin %s has wrong version %s", 
! 		  cptr->c_type, cptr->c_version);
  	}
        } else {
  	message(LOG_ERR, "plugin", "Can't find export point in plugin %s", 
  		fname);
        }
--- 184,212 ----
  		    cptr->c_type, fname);
  	  }
  	} else {
! 	  message(LOG_ERR, "plugin", "Plugin %s(%s) has wrong version %s", 
! 		  fname, cptr->c_type, cptr->c_version);
  	}
+       }
+       rptr = (rtp_plugin_t *)DLL_GET_SYM(handle, RTP_PLUGIN_EXPORT_NAME_STR);
+       if (rptr != NULL) {
+ 	if (strcmp(rptr->version, RTP_PLUGIN_VERSION) == 0) {
+ 	  rtp_plugin_list_t *p;
+ 	  p = MALLOC_STRUCTURE(rtp_plugin_list_t);
+ 	  if (p == NULL) exit(-1);
+ 			  
+ 	  p->rtp_plugin = rptr;
+ 	  p->dl_handle = handle;
+ 	  p->next_rtp_plugin = rtp_plugins;
+ 	  rtp_plugins = p;
+ 	  message(LOG_INFO, "plugin", "Adding RTP plugin %s %s", 
+ 		  rptr->name, fname);
  	} else {
+ 	  message(LOG_CRIT, "plugin", "Plugin %s (%s) has wrong version %s", 
+ 		  rptr->name, fname, rptr->version);
+ 	}
+       }
+       if (rptr == NULL && cptr == NULL) {
  	message(LOG_ERR, "plugin", "Can't find export point in plugin %s", 
  		fname);
        }
***************
*** 278,283 ****
--- 307,339 ----
    return (ret);
  }
  
+ rtp_check_return_t check_for_rtp_plugins (format_list_t *fptr,
+ 					  uint8_t rtp_payload_type,
+ 					  rtp_plugin_t **rtp_plugin)
+ {
+   rtp_plugin_list_t *r;
+   rtp_plugin_t *rptr;
+   rtp_check_return_t ret;
+ 
+   *rtp_plugin = NULL;
+   r = rtp_plugins;
+ 
+   while (r != NULL) {
+     rptr = r->rtp_plugin;
+ 
+     if (rptr->rtp_plugin_check != NULL) {
+       ret = (rptr->rtp_plugin_check)(message, fptr, rtp_payload_type);
+       if (ret != RTP_PLUGIN_NO_MATCH) {
+ 	*rtp_plugin = rptr;
+ 	return ret;
+       }
+     }
+     r = r->next_rtp_plugin;
+   }
+ 
+   return RTP_PLUGIN_NO_MATCH;
+ }
+ 
  /*
   * video_codec_check_for_raw_file
   * goes through list of video codecs to see if "name" has a raw file
***************
*** 300,306 ****
    vptr = video_codecs;
    
    while (vptr != NULL) {
- 
      if (vptr->codec->c_raw_file_check != NULL) {
        if (config.get_config_value(CONFIG_USE_MPEG4_ISO_ONLY) != 0 &&
  	  strcmp("MPEG4 ISO", vptr->codec->c_name) != 0 && 
--- 356,361 ----
***************
*** 326,332 ****
  	fbyte = new COurInByteStreamFile(vptr->codec,
  					 cifptr,
  					 maxtime);
! 	mptr->create_from_file(fbyte, TRUE);
  	mptr->set_plugin_data(vptr->codec, cifptr, get_video_vft(), NULL);
  
  	for (int ix = 0; ix < 4; ix++) 
--- 381,387 ----
  	fbyte = new COurInByteStreamFile(vptr->codec,
  					 cifptr,
  					 maxtime);
! 	mptr->create(fbyte, TRUE);
  	mptr->set_plugin_data(vptr->codec, cifptr, get_video_vft(), NULL);
  
  	for (int ix = 0; ix < 4; ix++) 
***************
*** 339,348 ****
  
  	return 0;
        }
-       return -1;
-     } else {
-       vptr = vptr->next_codec;
      }
    }
    return -1;
  }
--- 394,401 ----
  
  	return 0;
        }
      } 
+     vptr = vptr->next_codec;
    }
    return -1;
  }
***************
*** 382,388 ****
  	fbyte = new COurInByteStreamFile(aptr->codec,
  					 cifptr,
  					 maxtime);
! 	mptr->create_from_file(fbyte, FALSE);
  	mptr->set_plugin_data(aptr->codec, cifptr, NULL, get_audio_vft());
  
  	for (int ix = 0; ix < 4; ix++) 
--- 435,441 ----
  	fbyte = new COurInByteStreamFile(aptr->codec,
  					 cifptr,
  					 maxtime);
! 	mptr->create(fbyte, FALSE);
  	mptr->set_plugin_data(aptr->codec, cifptr, NULL, get_audio_vft());
  
  	for (int ix = 0; ix < 4; ix++) 
***************
*** 409,415 ****
  void close_plugins (void) 
  {
    codec_plugin_list_t *p;
! 
    while (audio_codecs != NULL) {
      p = audio_codecs;
  	DLL_CLOSE(p->dl_handle);
--- 462,468 ----
  void close_plugins (void) 
  {
    codec_plugin_list_t *p;
!   rtp_plugin_list_t *r;
    while (audio_codecs != NULL) {
      p = audio_codecs;
      DLL_CLOSE(p->dl_handle);
***************
*** 421,426 ****
--- 474,485 ----
      DLL_CLOSE(p->dl_handle);
      video_codecs = video_codecs->next_codec;
      free(p);
+   }
+   while (rtp_plugins != NULL) {
+     r = rtp_plugins;
+     DLL_CLOSE(r->dl_handle);
+     rtp_plugins = r->next_rtp_plugin;
+     free(r);
    }
  }
  
Index: player/src/codec_plugin.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec_plugin.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -c -w -r1.13 -r1.14
*** player/src/codec_plugin.h	2002/07/09 22:21:24	1.13
--- player/src/codec_plugin.h	2002/08/19 18:29:47	1.14
***************
*** 200,206 ****
   *         ifptr - handle to use for audio callbacks
   * Returns - must return a handle that contains codec_data_t.
   */
! typedef codec_data_t *(*ac_create_f)(format_list_t *sdp_media,
  				     audio_info_t *audio,
  				     const uint8_t *user_data,
  				     uint32_t userdata_size,
--- 200,209 ----
   *         ifptr - handle to use for audio callbacks
   * Returns - must return a handle that contains codec_data_t.
   */
! typedef codec_data_t *(*ac_create_f)(const char *compressor, 
! 				     int type, 
! 				     int profile, 
! 				     format_list_t *sdp_media,
  				     audio_info_t *audio,
  				     const uint8_t *user_data,
  				     uint32_t userdata_size,
***************
*** 217,223 ****
   *         ifptr - handle to use for video callbacks
   * Returns - must return a handle that contains codec_data_t.
   */
! typedef codec_data_t *(*vc_create_f)(format_list_t *sdp_media,
  			     video_info_t *video,
  			     const uint8_t *user_data,
  			     uint32_t userdata_size,
--- 220,229 ----
   *         ifptr - handle to use for video callbacks
   * Returns - must return a handle that contains codec_data_t.
   */
! typedef codec_data_t *(*vc_create_f)(const char *compressor, 
! 				     int type, 
! 				     int profile, 
! 				     format_list_t *sdp_media,
  				     video_info_t *video,
  				     const uint8_t *user_data,
  				     uint32_t userdata_size,
***************
*** 364,370 ****
  #endif
  
  
! #define PLUGIN_VERSION "0.4"
  
  /*
   * Use this for an audio plugin without raw file support
--- 370,376 ----
  #endif
  
  
! #define PLUGIN_VERSION "0.5"
  
  /*
   * Use this for an audio plugin without raw file support
Index: player/src/codec_plugin_private.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec_plugin_private.h,v
retrieving revision 1.5
retrieving revision 1.6
diff -c -w -r1.5 -r1.6
*** player/src/codec_plugin_private.h	2002/06/04 00:02:25	1.5
--- player/src/codec_plugin_private.h	2002/08/26 22:27:57	1.6
***************
*** 24,29 ****
--- 24,30 ----
  #define __CODEC_PLUGIN_PRIVATE_H__
  
  #include "codec_plugin.h"
+ #include "rtp_plugin.h"
  
  void initialize_plugins(void);
  
***************
*** 48,51 ****
--- 49,57 ----
  				    const char *name);
  int video_codec_check_for_raw_file (CPlayerSession *psptr,
  				    const char *name);
+ 
+ // RTP plugins
+ rtp_check_return_t check_for_rtp_plugins(format_list_t *fptr,
+ 					 uint8_t rtp_payload_type,
+ 					 rtp_plugin_t **rtp_plugin);
  #endif
Index: player/src/gui_main.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/gui_main.cpp,v
retrieving revision 1.71
retrieving revision 1.76
diff -c -w -r1.71 -r1.76
*** player/src/gui_main.cpp	2002/06/24 17:35:58	1.71
--- player/src/gui_main.cpp	2002/08/26 22:27:57	1.76
***************
*** 17,22 ****
--- 17,23 ----
   * 
   * Contributor(s): 
   *              Bill May        wmay@cisco.com
+  *            Peter Maersk-Moller     peter@maersk-moller.net
   */
  /*
   * gui_main.cpp - Contains the gtk based gui for this player.
***************
*** 38,43 ****
--- 39,45 ----
  #include <libhttp/http.h>
  #include <rtp/debug.h>
  #include "codec_plugin_private.h"
+ #include <mpeg2t/mpeg2_transport.h>
  /* ??? */
  #ifndef LOG_PRI
  #define LOG_PRI(p) ((p) & LOG_PRIMASK)
***************
*** 147,152 ****
--- 149,157 ----
    gtk_widget_set_sensitive(play_button, 1);
    gtk_widget_set_sensitive(pause_button, 1);
    gtk_widget_set_sensitive(stop_button, 1);
+ #ifdef HAVE_GTK_2_0
+   gtk_range_set_value(GTK_RANGE(time_slider), 0.0);
+ #endif
    if (psptr->session_is_seekable()) {
      gtk_widget_set_sensitive(time_slider, 1);
    }
***************
*** 229,235 ****
      free((void *)last_entry);
    }
    last_entry = strdup(name);
!   if (strncmp("rtsp://", name, strlen("rtsp://")) != 0) {
      if (last_file != NULL) {
        free((void *)last_file);
        last_file = NULL;
--- 234,242 ----
      free((void *)last_entry);
    }
    last_entry = strdup(name);
!   if (!((strncmp("rtsp://", name, strlen("rtsp://")) == 0) ||
! 	(strncmp("http://", name, strlen("http://")) == 0) ||
! 	(strncmp("mpeg2t://", name, strlen("mpeg2t://")) == 0))) {
      if (last_file != NULL) {
        free((void *)last_file);
        last_file = NULL;
***************
*** 333,338 ****
--- 340,346 ----
  	  "ISO reference decoder for MPEG4\n"
  	  "FAAC decoder\n"
  	  "Xvid decoder\n"
+ 	  "Libmpeg3 file and video decoder\n"
  	  "Developed by Bill May, 10/00 to present", VERSION);
  
    ShowMessage("About gmp4player",buffer);
***************
*** 413,419 ****
  
  static void on_playlist_child_selected (GtkWidget *window, gpointer data)
  {
!   gchar *entry = 
      gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(combo)->entry));
    if (strcmp(entry, "") == 0) 
      return;
--- 421,427 ----
  
  static void on_playlist_child_selected (GtkWidget *window, gpointer data)
  {
!   const gchar *entry = 
      gtk_entry_get_text(GTK_ENTRY(GTK_COMBO(combo)->entry));
    if (strcmp(entry, "") == 0) 
      return;
***************
*** 424,430 ****
  
  static void on_play_list_selected (GtkWidget *window, gpointer data)
  {
!   gchar *entry = gtk_entry_get_text(GTK_ENTRY(window));
    start_session_from_name(entry);
  }
  
--- 432,438 ----
  
  static void on_play_list_selected (GtkWidget *window, gpointer data)
  {
!   const gchar *entry = gtk_entry_get_text(GTK_ENTRY(window));
    start_session_from_name(entry);
  }
  
***************
*** 541,549 ****
    master_volume = volume;
    config.set_config_value(CONFIG_VOLUME, master_volume);
    gtk_range_set_adjustment(GTK_RANGE(volume_slider), val);
    gtk_range_slider_update(GTK_RANGE(volume_slider));
    gtk_range_clear_background(GTK_RANGE(volume_slider));
!   //gtk_range_draw_background(GTK_RANGE(volume_slider));
     if (master_muted == 0 && psptr && psptr->session_has_audio()) {
       psptr->set_audio_volume(master_volume);
     }
--- 549,558 ----
    master_volume = volume;
    config.set_config_value(CONFIG_VOLUME, master_volume);
    gtk_range_set_adjustment(GTK_RANGE(volume_slider), val);
+ #ifndef HAVE_GTK_2_0
    gtk_range_slider_update(GTK_RANGE(volume_slider));
    gtk_range_clear_background(GTK_RANGE(volume_slider));
! #endif
     if (master_muted == 0 && psptr && psptr->session_has_audio()) {
       psptr->set_audio_volume(master_volume);
     }
***************
*** 605,610 ****
--- 614,627 ----
    config.set_config_value(CONFIG_SDP_DEBUG, LOG_PRI(loglevel));
  }
  
+ static void on_debug_mpeg2t (GtkWidget *window, gpointer data)
+ {
+   int loglevel = GPOINTER_TO_INT(data);
+ 
+   mpeg2t_set_loglevel(LOG_PRI(loglevel));
+   config.set_config_value(CONFIG_MPEG2T_DEBUG, LOG_PRI(loglevel));
+ }
+ 
  static void on_media_play_audio (GtkWidget *window, gpointer data)
  {
    GtkCheckMenuItem *checkmenu;
***************
*** 658,679 ****
    }
  }
  
! static void on_time_slider_pressed (GtkWidget *window, gpointer data)
  {
    time_slider_pressed = 1;
  }
  
! static void on_time_slider_adjusted (GtkWidget *window, gpointer data)
  {
    double maxtime, newtime;
    time_slider_pressed = 0;
    if (psptr == NULL) 
!     return;
    maxtime = psptr->get_max_time();
    if (maxtime == 0.0)
!     return;
!   GtkAdjustment *val = gtk_range_get_adjustment(GTK_RANGE(time_slider));
!   newtime = (maxtime * val->value) / 100.0;
    SDL_mutexP(command_mutex);
    if (play_state == PLAYING) {
      psptr->pause_all_media();
--- 675,703 ----
    }
  }
  
! static int on_time_slider_pressed (GtkWidget *window, gpointer data)
  {
    time_slider_pressed = 1;
+   return (FALSE);
  }
  
! static int on_time_slider_adjusted (GtkWidget *window, gpointer data)
  {
    double maxtime, newtime;
    time_slider_pressed = 0;
    if (psptr == NULL) 
!     return FALSE;
    maxtime = psptr->get_max_time();
    if (maxtime == 0.0)
!     return FALSE;
!   gdouble val;
! #ifdef HAVE_GTK_2_0
!   val = gtk_range_get_value(GTK_RANGE(time_slider));
! #else
!   GtkAdjustment *adj_val = gtk_range_get_adjustment(GTK_RANGE(time_slider));
!   val = adj_val->value;
! #endif
!   newtime = (maxtime * val) / 100.0;
    SDL_mutexP(command_mutex);
    if (play_state == PLAYING) {
      psptr->pause_all_media();
***************
*** 683,696 ****
    if (ret == 0) 
      adjust_gui_for_play();
    SDL_mutexV(command_mutex);
!   if (ret == 0) {
!     gtk_range_set_adjustment(GTK_RANGE(time_slider), val);
!     gtk_range_slider_update(GTK_RANGE(time_slider));
!     gtk_range_clear_background(GTK_RANGE(time_slider));
!   //gtk_range_draw_background(GTK_RANGE(vol));
!   } else {
      close_session();
    }
  }
  
  static void on_loop_enabled_button (GtkWidget *widget, gpointer *data)
--- 707,716 ----
    if (ret == 0) 
      adjust_gui_for_play();
    SDL_mutexV(command_mutex);
!   if (ret != 0) {
      close_session();
    } 
+   return FALSE;
  }
  
  static void on_loop_enabled_button (GtkWidget *widget, gpointer *data)
***************
*** 723,728 ****
--- 743,751 ----
        } else {
  	val = (playtime * 100.0) / val;
        }
+ #ifdef HAVE_GTK_2_0
+       gtk_range_set_value(GTK_RANGE(time_slider), val);
+ #else
        GtkAdjustment *adj = gtk_range_get_adjustment(GTK_RANGE(time_slider));
        adj->value = val;
        gtk_range_set_adjustment(GTK_RANGE(time_slider), adj);
***************
*** 730,735 ****
--- 753,759 ----
        gtk_range_clear_background(GTK_RANGE(time_slider));
        gtk_range_draw_background(GTK_RANGE(time_slider));
        gtk_widget_show(time_slider);
+ #endif
      }
      int hr, min, tot;
      tot = (int) playtime;
***************
*** 987,992 ****
--- 1011,1018 ----
    sdp_set_loglevel(config.get_config_value(CONFIG_SDP_DEBUG));
    http_set_error_func(player_library_message);
    http_set_loglevel(config.get_config_value(CONFIG_HTTP_DEBUG));
+   mpeg2t_set_error_func(player_library_message);
+   mpeg2t_set_loglevel(config.get_config_value(CONFIG_MPEG2T_DEBUG));
    /*
     * Set up main window
     */
***************
*** 1005,1011 ****
--- 1031,1041 ----
    gtk_widget_show(main_vbox);
    // add stuff
    accel_group = gtk_accel_group_new();
+ #ifdef HAVE_GTK_2_0
+   gtk_window_add_accel_group(GTK_WINDOW(main_window), accel_group);
+ #else
    gtk_accel_group_attach(accel_group, GTK_OBJECT(main_window));
+ #endif
    tooltips = gtk_tooltips_new();
  
    GtkWidget *menubar, *menu, *menuitem;
***************
*** 1146,1151 ****
--- 1176,1185 ----
  			"SDP library", 
  			config.get_config_value(CONFIG_SDP_DEBUG),
  			GTK_SIGNAL_FUNC(on_debug_sdp));
+   CreateLogLevelSubmenu(debugsub,
+ 			"Mpeg2 Transport Library",
+ 			config.get_config_value(CONFIG_MPEG2T_DEBUG),
+ 			GTK_SIGNAL_FUNC(on_debug_mpeg2t));
  
    CreateMenuItemSeperator(menu);
    menuitem = CreateMenuItem(menu,
***************
*** 1223,1229 ****
    play_button = gtk_toggle_button_new();
    image = CreateWidgetFromXpm(main_window,xpm_play);
    gtk_container_add(GTK_CONTAINER(play_button), image);
!   gdk_pixmap_unref((GdkPixmap *)image);
    gtk_widget_show(play_button);
    gtk_signal_connect(GTK_OBJECT(play_button),
  		     "clicked",
--- 1257,1265 ----
    play_button = gtk_toggle_button_new();
    image = CreateWidgetFromXpm(main_window,xpm_play);
    gtk_container_add(GTK_CONTAINER(play_button), image);
! #if 0
!   //gdk_pixmap_unref((GdkPixmap *)image);
! #endif
    gtk_widget_show(play_button);
    gtk_signal_connect(GTK_OBJECT(play_button),
  		     "clicked",
***************
*** 1234,1240 ****
--- 1270,1278 ----
    pause_button = gtk_toggle_button_new();
    image = CreateWidgetFromXpm(main_window,xpm_pause);
    gtk_container_add(GTK_CONTAINER(pause_button), image);
+ #if 0
    gdk_pixmap_unref((GdkPixmap *)image);
+ #endif
    gtk_widget_show(pause_button);
    gtk_signal_connect(GTK_OBJECT(pause_button),
  		     "clicked",
***************
*** 1245,1251 ****
--- 1283,1291 ----
    stop_button = gtk_toggle_button_new();
    image = CreateWidgetFromXpm(main_window,xpm_stop);
    gtk_container_add(GTK_CONTAINER(stop_button), image);
+ #if 0
    gdk_pixmap_unref((GdkPixmap *)image);
+ #endif
    gtk_widget_show(stop_button);
    gtk_signal_connect(GTK_OBJECT(stop_button),
  		     "clicked",
***************
*** 1275,1281 ****
--- 1315,1323 ----
  			      master_muted == 0 ?
  			      xpm_speaker : xpm_speaker_muted);
    gtk_container_add(GTK_CONTAINER(speaker_button), image);
+ #if 0
    gdk_pixmap_unref((GdkPixmap *)image);
+ #endif
    gtk_widget_show(speaker_button);
    gtk_signal_connect(GTK_OBJECT(speaker_button),
  		     "clicked",
***************
*** 1296,1316 ****
    gtk_scale_set_digits(GTK_SCALE(vol),0);
    gtk_scale_set_draw_value(GTK_SCALE(vol), 0);
    gtk_range_set_adjustment ( GTK_RANGE( vol ), GTK_ADJUSTMENT(vol_adj));
    gtk_range_slider_update ( GTK_RANGE( vol ) );
    gtk_range_clear_background ( GTK_RANGE( vol ) );
    //gtk_range_draw_background ( GTK_RANGE( vol ) );
  
! #if 0
    // We don't need this - I'm not 100% sure why, but we don't...
    gtk_signal_connect(vol_adj,
  		     "value_changed",
  		     GTK_SIGNAL_FUNC(on_volume_adjusted),
  		     vol);
! #endif
    gtk_signal_connect(GTK_OBJECT(vol), 
  		     "button_release_event",
  		     GTK_SIGNAL_FUNC(on_volume_adjusted),
  		     vol);
    gtk_widget_show(vol);
    volume_slider = vol;
    gtk_box_pack_start(GTK_BOX(hbox2), vol, TRUE, TRUE, 0);
--- 1338,1364 ----
    gtk_scale_set_digits(GTK_SCALE(vol),0);
    gtk_scale_set_draw_value(GTK_SCALE(vol), 0);
    gtk_range_set_adjustment ( GTK_RANGE( vol ), GTK_ADJUSTMENT(vol_adj));
+ #ifdef HAVE_GTK_2_0
+   gtk_widget_set_size_request(GTK_WIDGET(vol), 100, -1);
+   gtk_range_set_update_policy(GTK_RANGE(vol), GTK_UPDATE_DISCONTINUOUS);
+ #else
    gtk_range_slider_update ( GTK_RANGE( vol ) );
    gtk_range_clear_background ( GTK_RANGE( vol ) );
    //gtk_range_draw_background ( GTK_RANGE( vol ) );
+ #endif
  
! #ifdef HAVE_GTK_2_0
    // We don't need this - I'm not 100% sure why, but we don't...
    gtk_signal_connect(vol_adj,
  		     "value_changed",
  		     GTK_SIGNAL_FUNC(on_volume_adjusted),
  		     vol);
! #else
    gtk_signal_connect(GTK_OBJECT(vol), 
  		     "button_release_event",
  		     GTK_SIGNAL_FUNC(on_volume_adjusted),
  		     vol);
+ #endif
    gtk_widget_show(vol);
    volume_slider = vol;
    gtk_box_pack_start(GTK_BOX(hbox2), vol, TRUE, TRUE, 0);
***************
*** 1356,1370 ****
  				  0.5);
    
    time_slider = gtk_hscale_new(GTK_ADJUSTMENT(time_slider_adj));
-   gtk_widget_ref(time_slider);
    gtk_range_set_update_policy(GTK_RANGE(time_slider), GTK_UPDATE_DELAYED);
    gtk_scale_set_digits(GTK_SCALE(time_slider),0);
    gtk_scale_set_draw_value(GTK_SCALE(time_slider), 0);
    gtk_range_set_adjustment(GTK_RANGE(time_slider), 
  			   GTK_ADJUSTMENT(time_slider_adj));
    gtk_range_slider_update(GTK_RANGE(time_slider));
    gtk_range_clear_background(GTK_RANGE( time_slider));
!   //gtk_range_draw_background(GTK_RANGE(time_slider));
    gtk_signal_connect(GTK_OBJECT(time_slider), 
  		     "button_release_event",
  		     GTK_SIGNAL_FUNC(on_time_slider_adjusted),
--- 1404,1419 ----
  				  0.5);
    
    time_slider = gtk_hscale_new(GTK_ADJUSTMENT(time_slider_adj));
    gtk_range_set_update_policy(GTK_RANGE(time_slider), GTK_UPDATE_DELAYED);
    gtk_scale_set_digits(GTK_SCALE(time_slider),0);
    gtk_scale_set_draw_value(GTK_SCALE(time_slider), 0);
    gtk_range_set_adjustment(GTK_RANGE(time_slider), 
  			   GTK_ADJUSTMENT(time_slider_adj));
+ #ifndef HAVE_GTK_2_0
    gtk_range_slider_update(GTK_RANGE(time_slider));
    gtk_range_clear_background(GTK_RANGE( time_slider));
! #endif
! 
    gtk_signal_connect(GTK_OBJECT(time_slider), 
  		     "button_release_event",
  		     GTK_SIGNAL_FUNC(on_time_slider_adjusted),
Index: player/src/gui_utils.c
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/gui_utils.c,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -w -r1.7 -r1.8
*** player/src/gui_utils.c	2001/09/13 22:01:03	1.7
--- player/src/gui_utils.c	2002/08/14 01:04:58	1.8
***************
*** 57,65 ****
--- 57,69 ----
        printf("Error\n");
        return (NULL);
      }
+ #ifdef HAVE_GTK_2_0
+     pixmap = gtk_image_new_from_pixmap(gdkpixmap, mask);
+ #else
      pixmap = gtk_pixmap_new (gdkpixmap, mask);
      gdk_pixmap_unref (gdkpixmap);
      gdk_bitmap_unref (mask);
+ #endif
      gtk_widget_show(pixmap);
      return pixmap;
  }
Index: player/src/media_utils.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/media_utils.cpp,v
retrieving revision 1.84
retrieving revision 1.93
diff -c -w -r1.84 -r1.93
*** player/src/media_utils.cpp	2002/07/09 22:40:13	1.84
--- player/src/media_utils.cpp	2002/08/26 22:27:57	1.93
***************
*** 33,46 ****
  #include "qtime_file.h"
  #include "our_config_file.h"
  #include "rtp_bytestream.h"
- #include "codec/aa/isma_rtp_bytestream.h"
  #include "codec_plugin_private.h"
  #include <gnu/strcasestr.h>
  #include "rfc3119_bytestream.h"
  #include "mpeg3_rtp_bytestream.h"
  #include "mpeg3_file.h"
  #include "audio.h"
  #include "mpeg2t.h"
  /*
   * This needs to be global so we can store any ports that we don't
   * care about but need to reserve
--- 33,48 ----
  #include "qtime_file.h"
  #include "our_config_file.h"
  #include "rtp_bytestream.h"
  #include "codec_plugin_private.h"
  #include <gnu/strcasestr.h>
  #include "rfc3119_bytestream.h"
  #include "mpeg3_rtp_bytestream.h"
  #include "mpeg3_file.h"
  #include "audio.h"
+ #ifndef _WIN32
  #include "mpeg2t.h"
+ #endif
+ #include "rtp_bytestream_plugin.h"
  /*
   * This needs to be global so we can store any ports that we don't
   * care about but need to reserve
***************
*** 53,62 ****
  };
  
  enum {
-   MPEG4IP_AUDIO_AAC,
    MPEG4IP_AUDIO_MP3,
    MPEG4IP_AUDIO_WAV,
-   MPEG4IP_AUDIO_MPEG4_GENERIC,
    MPEG4IP_AUDIO_MP3_ROBUST,
    MPEG4IP_AUDIO_GENERIC,
  };
--- 55,62 ----
***************
*** 78,84 ****
    {NULL, -1},
  },
    audio_codecs[] = {
-     {"MPEG4-GENERIC", MPEG4IP_AUDIO_MPEG4_GENERIC},
      {"MPA", MPEG4IP_AUDIO_MP3 },
      {"mpa-robust", MPEG4IP_AUDIO_MP3_ROBUST}, 
      {"L16", MPEG4IP_AUDIO_GENERIC },
--- 78,83 ----
***************
*** 138,150 ****
--- 137,154 ----
      snprintf(buffer, sizeof(buffer), "Description: %s", sdp->session_desc);
      psptr->set_session_desc(1, buffer);
    }
+ #ifndef _WIN32
    if (sdp->media != NULL &&
        sdp->media->next == NULL &&
        strcasecmp(sdp->media->media, "video") == 0 &&
        sdp->media->fmt != NULL &&
        strcmp(sdp->media->fmt->fmt, "33") == 0) {
      // we have a mpeg2 transport stream
+     return (create_mpeg2t_session(psptr, NULL, sdp, errmsg, errlen,
+ 				  have_audio_driver, cc_vft));
+ 				  
    }
+ #endif
    media_desc_t *sdp_media;
    audio_count = video_count = 0;
    for (sdp_media = psptr->get_sdp_info()->media;
***************
*** 506,518 ****
      err = create_media_for_http(psptr, name, errmsg, errlen, cc_vft);
      return (err);
    }    
! #if 0
    if (strncmp(name, "mpeg2t://", strlen("mpeg2t://")) == 0) {
!     err = create_mpeg2t_session(psptr, name, errmsg, errlen, cc_vft);
      return (err);
    }
! #endif
! #ifndef _WINDOWS
    struct stat statbuf;
    if (stat(name, &statbuf) != 0) {
      snprintf(errmsg, errlen, "File \'%s\' not found", name);
--- 510,526 ----
      err = create_media_for_http(psptr, name, errmsg, errlen, cc_vft);
      return (err);
    }    
! 
!   int have_audio_driver;
! 
!   have_audio_driver = do_we_have_audio();
! #ifndef _WIN32
    if (strncmp(name, "mpeg2t://", strlen("mpeg2t://")) == 0) {
!     err = create_mpeg2t_session(psptr, name, NULL, errmsg, errlen, 
! 				have_audio_driver, cc_vft);
      return (err);
    }
! 
    struct stat statbuf;
    if (stat(name, &statbuf) != 0) {
      snprintf(errmsg, errlen, "File \'%s\' not found", name);
***************
*** 538,547 ****
      return err;
    }
  
-   int have_audio_driver;
  
-   have_audio_driver = do_we_have_audio();
- 
    if (strcasecmp(suffix, ".sdp") == 0) {
      err = create_media_from_sdp_file(psptr, 
  				     name, 
--- 546,552 ----
***************
*** 574,580 ****
    } else if (strcasecmp(suffix, ".mpeg") == 0 ||
  	     strcasecmp(suffix, ".mpg") == 0) {
      err = create_media_for_mpeg_file(psptr, name, errmsg, 
! 				     errlen, have_audio_driver);
    } else {
      // raw files
      if (have_audio_driver) {
--- 579,585 ----
    } else if (strcasecmp(suffix, ".mpeg") == 0 ||
  	     strcasecmp(suffix, ".mpg") == 0) {
      err = create_media_for_mpeg_file(psptr, name, errmsg, 
! 				     errlen, have_audio_driver, cc_vft);
    } else {
      // raw files
      if (have_audio_driver) {
***************
*** 595,601 ****
--- 600,675 ----
    return (err);
  }
  
+ int check_name_for_network (const char *name, 
+ 			    int &isOnDemand, 
+ 			    int &isRtpOverRtsp)
+ {
+   sdp_decode_info_t *sdp_info;
+   session_desc_t *sdp;
+   int translated;
+   http_resp_t *http_resp;
+   int do_sdp = 0;
+ 
+   http_resp = NULL;
+   isOnDemand = 0;
+   isRtpOverRtsp = 0;
+   sdp_info = NULL;
+   if (strncmp(name, "mpeg2t://", strlen("mpeg2t://")) == 0) {
+     return 1;
+   }
+   if (strncmp(name, "rtsp://", strlen("rtsp://")) == 0) {
+     isOnDemand = 1;
+     isRtpOverRtsp = config.get_config_value(CONFIG_USE_RTP_OVER_RTSP);
+     return 1;
+   }
+   // handle http, .sdp case
+   if (strncmp(name, "http://", strlen("http://")) == 0) {
+     http_client_t *http_client;
+     int ret;
+     http_client = http_init_connection(name);
+ 
+     if (http_client == NULL) {
+       return -1;
+     } 
+     ret = http_get(http_client, NULL, &http_resp);
+     if (ret > 0) {
+       sdp_decode_info_t *sdp_info;
+       sdp_info = set_sdp_decode_from_memory(http_resp->body);
+       do_sdp = 1;
+       http_free_connection(http_client);
+     } else return -1;
+     do_sdp = 1;
+   } else {
+     const char *suffix = strrchr(name, '.');
+     if (suffix == NULL) {
+       return -1;
+     }
+     if (strcasecmp(name, ".sdp") == 0) {
+       sdp_info = set_sdp_decode_from_filename(name);
+     } else 
+       return 0;
+   }
+   if (do_sdp != 0) {
+     if ((sdp_decode(sdp_info, &sdp, &translated) != 0) ||
+ 	translated != 1){
+       sdp_decode_info_free(sdp_info);
+       return (-1);
+     }
+     if (sdp->control_string != NULL) {
+       isOnDemand = 1;
+       isRtpOverRtsp = config.get_config_value(CONFIG_USE_RTP_OVER_RTSP);
+     }
+     sdp_free_session_desc(sdp);
+     if (http_resp != NULL)
+       http_resp_free(http_resp);
+     sdp_decode_info_free(sdp_info);
+     return 1;
+   }
+   return 0;
+ }
+ 
    
+   
  CRtpByteStreamBase *create_rtp_byte_stream_for_format (format_list_t *fmt,
  						       unsigned int rtp_pt,
  						       int ondemand,
***************
*** 612,619 ****
  						       uint32_t rtp_ts)
  {
    CRtpByteStreamBase *rtp_byte_stream;
- 
    int codec;
    if (strcmp("video", fmt->media->media) == 0) {
      if (rtp_pt == 32) {
        codec = VIDEO_MPEG12;
--- 686,738 ----
  						       uint32_t rtp_ts)
  {
    CRtpByteStreamBase *rtp_byte_stream;
    int codec;
+   rtp_check_return_t plugin_ret;
+   rtp_plugin_t *rtp_plugin;
+ 
+   rtp_plugin = NULL;
+   rtp_byte_stream = NULL;
+   plugin_ret = check_for_rtp_plugins(fmt, rtp_pt, &rtp_plugin);
+ 
+   if (plugin_ret != RTP_PLUGIN_NO_MATCH) {
+     switch (plugin_ret) {
+     case RTP_PLUGIN_MATCH:
+       player_debug_message("Starting rtp bytestream %s from plugin", 
+ 			   rtp_plugin->name);
+       rtp_byte_stream = new CPluginRtpByteStream(rtp_plugin,
+ 						 fmt,
+ 						 rtp_pt,
+ 						ondemand,
+ 						tps,
+ 						head,
+ 						tail,
+ 						rtp_seq_set,
+ 						rtp_seq,
+ 						rtp_ts_set,
+ 						rtp_base_ts,
+ 						rtcp_received,
+ 						ntp_frac,
+ 						ntp_sec,
+ 						rtp_ts);
+       break;
+     case RTP_PLUGIN_MATCH_USE_VIDEO_DEFAULT:
+       // just fall through...
+       break; 
+     case RTP_PLUGIN_MATCH_USE_AUDIO_DEFAULT:
+       rtp_byte_stream = 
+ 	new CAudioRtpByteStream(rtp_pt, fmt, ondemand, tps, head, tail, 
+ 				rtp_seq_set, rtp_seq,
+ 				rtp_ts_set, rtp_base_ts, 
+ 				rtcp_received, ntp_frac, ntp_sec, rtp_ts);
+       if (rtp_byte_stream != NULL) {
+ 	player_debug_message("Starting generic audio byte stream");
+ 	return (rtp_byte_stream);
+       }
+ 
+     default:
+       break;
+     }
+   } else {
    if (strcmp("video", fmt->media->media) == 0) {
      if (rtp_pt == 32) {
        codec = VIDEO_MPEG12;
***************
*** 644,649 ****
--- 763,770 ----
    } else {
      if (rtp_pt == 14) {
        codec = MPEG4IP_AUDIO_MP3;
+     } else if (rtp_pt >= 0 && rtp_pt <= 23) {
+       codec = MPEG4IP_AUDIO_GENERIC;
      }  else {
        codec = lookup_codec_by_name(fmt->rtpmap->encode_name, 
  				   audio_codecs);
***************
*** 652,697 ****
        }
      }
      switch (codec) {
!     case MPEG4IP_AUDIO_AAC:
!     case MPEG4IP_AUDIO_MPEG4_GENERIC:
!       fmtp_parse_t *fmtp;
! 
!       fmtp = parse_fmtp_for_mpeg4(fmt->fmt_param, message);
!       if (fmtp->size_length == 0) {
! 	// No headers in RTP packet -create normal bytestream
! 	player_debug_message("Size of AAC RTP header is 0 - normal bytestream");
! 	break;
!       }
!       rtp_byte_stream = new CIsmaAudioRtpByteStream(fmt,
! 						    fmtp,
! 						    rtp_pt,
! 						    ondemand,
! 						    tps,
! 						    head,
! 						    tail,
! 						    rtp_seq_set,
! 						    rtp_seq,
! 						    rtp_ts_set,
! 						    rtp_base_ts,
! 						    rtcp_received,
! 						    ntp_frac,
! 						    ntp_sec,
! 						    rtp_ts);
!       if (rtp_byte_stream != NULL) {
! 	return (rtp_byte_stream);
!       }
!       // Otherwise, create default...
!       break;
!     case MPEG4IP_AUDIO_MP3:
        rtp_byte_stream = 
! 	new CMP3RtpByteStream(rtp_pt, fmt, ondemand, tps, head, tail, 
  			      rtp_seq_set, rtp_seq,
  			      rtp_ts_set, rtp_base_ts, 
  			      rtcp_received, ntp_frac, ntp_sec, rtp_ts);
        if (rtp_byte_stream != NULL) {
! 	player_debug_message("Starting mp3 2250 byte stream");
  	return (rtp_byte_stream);
        }
        break;
      case MPEG4IP_AUDIO_MP3_ROBUST:
        rtp_byte_stream = 
--- 773,790 ----
        }
      }
      switch (codec) {
!     case MPEG4IP_AUDIO_MP3: {
        rtp_byte_stream = 
! 	new CAudioRtpByteStream(rtp_pt, fmt, ondemand, tps, head, tail, 
  				rtp_seq_set, rtp_seq,
  				rtp_ts_set, rtp_base_ts, 
  				rtcp_received, ntp_frac, ntp_sec, rtp_ts);
        if (rtp_byte_stream != NULL) {
! 	rtp_byte_stream->set_skip_on_advance(4);
! 	player_debug_message("Starting mp3 2250 audio byte stream");
  	return (rtp_byte_stream);
        }
+     }
        break;
      case MPEG4IP_AUDIO_MP3_ROBUST:
        rtp_byte_stream = 
***************
*** 733,737 ****
--- 826,831 ----
  				       ntp_frac,
  				       ntp_sec,
  				       rtp_ts);
+   }
    return (rtp_byte_stream);
  }
Index: player/src/media_utils.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/media_utils.h,v
retrieving revision 1.19
retrieving revision 1.20
diff -c -w -r1.19 -r1.20
*** player/src/media_utils.h	2002/07/02 21:02:13	1.19
--- player/src/media_utils.h	2002/08/20 17:23:41	1.20
***************
*** 71,76 ****
--- 71,77 ----
  			   uint32_t errlen,
  			   control_callback_vft_t *);
  
+ int check_name_for_network(const char *name, int &isOnDemand, int &isRtpOverRtsp);
  int lookup_audio_codec_by_name(const char *name);
  int lookup_video_codec_by_name(const char *name);
  
Index: player/src/mp4_bytestream.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mp4_bytestream.cpp,v
retrieving revision 1.25
retrieving revision 1.26
diff -c -w -r1.25 -r1.26
*** player/src/mp4_bytestream.cpp	2002/06/13 22:50:35	1.25
--- player/src/mp4_bytestream.cpp	2002/07/22 21:52:48	1.26
***************
*** 247,253 ****
    m_byte_on = 0;
  }
  
! void CMp4ByteStream::set_start_time (uint64_t start)
  {
    m_play_start_time = start;
  
--- 247,253 ----
    m_byte_on = 0;
  }
  
! void CMp4ByteStream::play (uint64_t start)
  {
    m_play_start_time = start;
  
Index: player/src/mp4_bytestream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mp4_bytestream.h,v
retrieving revision 1.10
retrieving revision 1.11
diff -c -w -r1.10 -r1.11
*** player/src/mp4_bytestream.h	2002/06/04 00:02:25	1.10
--- player/src/mp4_bytestream.h	2002/07/22 21:52:48	1.11
***************
*** 54,60 ****
    void check_for_end_of_frame(void);
    double get_max_playtime(void);
  
!   void set_start_time(uint64_t start);
   private:
  #ifdef OUTPUT_TO_FILE
    FILE *m_output_file;
--- 54,60 ----
    void check_for_end_of_frame(void);
    double get_max_playtime(void);
  
!   void play(uint64_t start);
   private:
  #ifdef OUTPUT_TO_FILE
    FILE *m_output_file;
Index: player/src/mp4_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mp4_file.cpp,v
retrieving revision 1.20
retrieving revision 1.22
diff -c -w -r1.20 -r1.22
*** player/src/mp4_file.cpp	2002/07/09 22:40:13	1.20
--- player/src/mp4_file.cpp	2002/08/19 18:29:47	1.22
***************
*** 142,147 ****
--- 142,150 ----
  				     vq[ix].config_len);
  
        int ret = mptr->create_video_plugin(plugin, 
+ 					  "MP4 FILE",
+ 					  vq[ix].type,
+ 					  vq[ix].profile,
  					  NULL, // sdp info
  					  vinfo, // video info
  					  vq[ix].config,
***************
*** 161,167 ****
  	return (-1);
        }
  
!       ret = mptr->create_from_file(vbyte, TRUE);
        if (ret != 0) {
  	return (-1);
        }
--- 164,170 ----
  	return (-1);
        }
  
!       ret = mptr->create(vbyte, TRUE, errmsg, errlen);
        if (ret != 0) {
  	return (-1);
        }
***************
*** 218,223 ****
--- 221,229 ----
  				     aq[ix].config_len);
  
        ret = mptr->create_audio_plugin(plugin,
+ 				      "MP4 FILE",
+ 				      aq[ix].type, 
+ 				      aq[ix].profile,
  				      NULL, // sdp info
  				      ainfo, // audio info
  				      aq[ix].config,
***************
*** 232,238 ****
  	return -1;
        }
  
!       ret = mptr->create_from_file(abyte, FALSE);
        if (ret != 0) {
  	return (-1);
        }
--- 238,244 ----
  	return -1;
        }
  
!       ret = mptr->create(abyte, FALSE, errmsg, errlen);
        if (ret != 0) {
  	return (-1);
        }
Index: player/src/mpeg2t.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg2t.h,v
retrieving revision 1.1
retrieving revision 1.3
diff -c -w -r1.1 -r1.3
*** player/src/mpeg2t.h	2002/07/05 22:03:53	1.1
--- player/src/mpeg2t.h	2002/07/26 22:46:33	1.3
***************
*** 5,12 ****
  
  int create_mpeg2t_session(CPlayerSession *psptr,
  			  const char *name, 
  			  char *errmsg, 
  			  uint32_t errlen, 
! 			  //int have_audio_driver,
  			  control_callback_vft_t *cc_vft);
  #endif
--- 5,13 ----
  
  int create_mpeg2t_session(CPlayerSession *psptr,
  			  const char *name, 
+ 			  session_desc_t *sdp,
  			  char *errmsg, 
  			  uint32_t errlen, 
! 			  int have_audio_driver,
  			  control_callback_vft_t *cc_vft);
  #endif
Index: player/src/mpeg2t_private.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg2t_private.h,v
retrieving revision 1.1
retrieving revision 1.6
diff -c -w -r1.1 -r1.6
*** player/src/mpeg2t_private.h	2002/07/05 22:03:53	1.1
--- player/src/mpeg2t_private.h	2002/07/24 22:00:24	1.6
***************
*** 18,23 ****
--- 18,25 ----
   * Contributor(s): 
   *              Bill May        wmay@cisco.com
   */
+ #ifndef __MPEG2T_PRIVATE_H__
+ #define __MPEG2T_PRIVATE_H__ 1
  #include "mpeg2t_thread.h"
  #include "mpeg2t_thread_ipc.h"
  #include <rtp/rtp.h>
***************
*** 34,46 ****
   * Some useful macros.
   */
  #define ADV_SPACE(a) {while (isspace(*(a)) && (*(a) != '\0'))(a)++;}
- #define CHECK_AND_FREE(a, b) { if (a->b != NULL) { free(a->b); a->b = NULL;}}
  
  
  typedef struct mpeg2t_thread_info_ mpeg2t_thread_info_t;
  
  struct addrinfo;
  
  struct mpeg2t_client_ {
    /*
     * Information about the server we're talking to.
--- 36,59 ----
   * Some useful macros.
   */
  #define ADV_SPACE(a) {while (isspace(*(a)) && (*(a) != '\0'))(a)++;}
  
+ class CPlayerMedia;
  
  typedef struct mpeg2t_thread_info_ mpeg2t_thread_info_t;
  
  struct addrinfo;
  
+ typedef struct mpeg2t_stream_t {
+   struct mpeg2t_stream_t *next_stream;
+   CPlayerMedia *m_mptr;
+   int m_have_info;
+   int m_is_video;
+   int m_buffering;
+   int m_frames_since_last_psts;
+   uint64_t m_last_psts;
+ } mpeg2t_stream_t;
+ 
+ 
  struct mpeg2t_client_ {
    /*
     * Information about the server we're talking to.
***************
*** 71,76 ****
--- 84,90 ----
  #endif
    int recv_timeout;
  
+   uint16_t rtp_seq;
    /*
     * Thread information
     */
***************
*** 85,91 ****
     */
    uint32_t m_buffer_len, m_offset_on;
    char m_resp_buffer[1500];
! 
  };
  
  #ifdef __cplusplus
--- 99,105 ----
     */
    uint32_t m_buffer_len, m_offset_on;
    char m_resp_buffer[1500];
!   mpeg2t_stream_t *stream;
  };
  
  #ifdef __cplusplus
***************
*** 121,123 ****
--- 135,138 ----
  }
  #endif
  
+ #endif
Index: player/src/mpeg2t_thread.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg2t_thread.cpp,v
retrieving revision 1.1
retrieving revision 1.16
diff -c -w -r1.1 -r1.16
*** player/src/mpeg2t_thread.cpp	2002/07/05 22:03:53	1.1
--- player/src/mpeg2t_thread.cpp	2002/08/19 18:29:47	1.16
***************
*** 26,34 ****
--- 26,38 ----
  #include <rtp/memory.h>
  #include <rtp/net_udp.h>
  #include "player_session.h"
+ #include "player_media.h"
  #include "player_util.h"
  #include "our_config_file.h"
  #include "media_utils.h"
+ #include "codec_plugin_private.h"
+ #include "mpeg2t_bytestream.h"
+ #include "player_sdp.h"
  
  #ifdef _WIN32
  DEFINE_MESSAGE_MACRO(mpeg2t_message, "mpeg2t")
***************
*** 46,51 ****
--- 50,56 ----
    mpeg2t_pid_t *pidptr;
    uint32_t buflen;
    uint32_t buflen_used;
+ 
    buflen = blen;
  
    do {
***************
*** 64,69 ****
--- 69,141 ----
  	}
  	break;
        case MPEG2T_ES_PAK:
+ 	mpeg2t_stream_t *sptr;
+ 	CPlayerMedia *mptr;
+ 	mpeg2t_es_t *es_pid;
+ 	es_pid = (mpeg2t_es_t *)pidptr;
+ 	sptr = (mpeg2t_stream_t *)mpeg2t_es_get_userdata(es_pid);
+ 	if (sptr != NULL) {
+ 	  if (sptr->m_buffering == 0) {
+ 	    if (es_pid->save_frames != 0) {
+ 	      mptr = sptr->m_mptr;
+ 	      mptr->bytestream_primed();
+ 	    }
+ 	  } else {
+ 	    // we're buffering.
+ 	    if (sptr->m_have_info == 0) {
+ 	      if (es_pid->info_loaded == 0) {
+ 		// just dump the frame - record the psts
+ 		mpeg2t_frame_t *fptr;
+ 		do {
+ 		  fptr = mpeg2t_get_es_list_head(es_pid);
+ 		  if (fptr != NULL) {
+ 		    if (fptr->have_ps_ts) {
+ 		      sptr->m_last_psts = fptr->ps_ts;
+ 		      sptr->m_frames_since_last_psts = 0;
+ 		    } else 
+ 		      sptr->m_frames_since_last_psts++;
+ 		    free(fptr);
+ 		  }
+ 		} while (fptr != NULL);
+ 	      } else {
+ 		// just got the info in pid
+ 		sptr->m_have_info = 1;
+ 		mpeg2t_message(LOG_DEBUG, "%s Info is loading - starting buffering", 
+ 			       sptr->m_is_video ? "video" : "audio");
+ 		if (es_pid->list->have_ps_ts == 0) {
+ 		  mpeg2t_message(LOG_ERR, "have psts is 0 when info loaded");
+ 		}
+ 	      }
+ 	    } else {
+ 	      int msec;
+ 	      if (sptr->m_is_video) {
+ 		// use the video values for buffering
+ 		double msec_in_list;
+ 		msec_in_list = es_pid->frames_in_list;
+ 		msec_in_list *= 1000.0;
+ 		msec_in_list /= es_pid->frame_rate;
+ 		msec = (int)msec_in_list;
+ 	      } else {
+ 		// use the audio values for buffering
+ 		msec = es_pid->frames_in_list;
+ 		msec *= 1000;
+ 		msec *= es_pid->sample_per_frame;
+ 		msec /= es_pid->sample_freq;
+ 	      }
+ #if 0
+ 	      mpeg2t_message(LOG_DEBUG, "%s buffer %d", 
+ 			     sptr->m_is_video ? "video" : "audio", msec);
+ #endif
+ 	      if (msec >= config.get_config_value(CONFIG_RTP_BUFFER_TIME_MSEC)) {
+ 		// yipee - done buffering..
+ 		sptr->m_buffering = 0;
+ 		sptr->m_mptr->start_decoding();
+ 		mpeg2t_message(LOG_DEBUG, "%s done buffering %d",
+ 			       sptr->m_is_video ? "video" : "audio", msec);
+ 	      }
+ 	    }
+ 	  }
+ 	}
  	break;
        }
      }
***************
*** 71,86 ****
      buflen -= buflen_used;
    } while (buflen >= 188);
    if (buflen > 0) {
!     mpeg2t_message(LOG_ERR, "decode buffer size is not multiple of 188 - %d %d",
  		   blen, buflen);
    }
  }
  
  static void mpeg2t_rtp_callback (struct rtp *session, rtp_event *e)
  {
    if (e->type == RX_RTP) {
      rtp_packet *rpak;
      rpak = (rtp_packet *)e->data;
      mpeg2t_decode_buffer((mpeg2t_client_t *)rtp_get_userdata(session), 
  			  rpak->rtp_data, 
  			  rpak->rtp_data_len);
--- 143,165 ----
      buflen -= buflen_used;
    } while (buflen >= 188);
    if (buflen > 0) {
!     mpeg2t_message(LOG_ERR, 
! 		   "decode buffer size is not multiple of 188 - %d %d",
  		   blen, buflen);
    }
  }
  
  static void mpeg2t_rtp_callback (struct rtp *session, rtp_event *e)
  {
+   mpeg2t_client_t *info;
+ 
    if (e->type == RX_RTP) {
      rtp_packet *rpak;
      rpak = (rtp_packet *)e->data;
+     info = (mpeg2t_client_t *)rtp_get_userdata(session);
+ 
+     info->rtp_seq = rpak->rtp_pak_seq + 1;
+ 
      mpeg2t_decode_buffer((mpeg2t_client_t *)rtp_get_userdata(session), 
  			 rpak->rtp_data, 
  			 rpak->rtp_data_len);
***************
*** 150,156 ****
  
    
    continue_thread = 0;
!   mpeg2t_message(LOG_DEBUG, "thread started");
    mpeg2t_thread_init_thread_info(info);
    while (continue_thread == 0) {
      //    mpeg2t_message(LOG_DEBUG, "thread waiting");
--- 229,235 ----
  
    
    continue_thread = 0;
!   //mpeg2t_message(LOG_DEBUG, "thread started");
    mpeg2t_thread_init_thread_info(info);
    while (continue_thread == 0) {
      //mpeg2t_message(LOG_DEBUG, "thread waiting");
***************
*** 178,184 ****
        read = mpeg2t_thread_get_control_message(info, &msg_type);
        if (read == sizeof(msg_type)) {
  	// received message
! 	mpeg2t_message(LOG_DEBUG, "Comm socket msg %d", msg_type);
  	switch (msg_type) {
  	case MPEG2T_MSG_QUIT:
  	  continue_thread = 1;
--- 257,263 ----
        read = mpeg2t_thread_get_control_message(info, &msg_type);
        if (read == sizeof(msg_type)) {
  	// received message
! 	//mpeg2t_message(LOG_DEBUG, "Comm socket msg %d", msg_type);
  	switch (msg_type) {
  	case MPEG2T_MSG_QUIT:
  	  continue_thread = 1;
***************
*** 188,194 ****
  	  mpeg2t_thread_ipc_respond(info, ret);
  	  break;
  	default:
! 	  //	  mpeg2t_message(LOG_ERR, "Unknown message %d received", msg_type);
  	  break;
  	}
        }
--- 267,273 ----
  	  mpeg2t_thread_ipc_respond(info, ret);
  	  break;
  	default:
! 	  mpeg2t_message(LOG_ERR, "Unknown message %d received", msg_type);
  	  break;
  	}
        }
***************
*** 208,214 ****
      } else {
        if (mpeg2t_thread_has_receive_data(info)) {
  	if (info->udp != NULL) {
! 	  mpeg2t_message(LOG_DEBUG, "receiving udp data");
  	  buflen = udp_recv(info->udp, buffer, RTP_MAX_PACKET_LEN);
  	  mpeg2t_decode_buffer(info, buffer, buflen);
  	}
--- 287,293 ----
      } else {
        if (mpeg2t_thread_has_receive_data(info)) {
  	if (info->udp != NULL) {
! 	  //mpeg2t_message(LOG_DEBUG, "receiving udp data");
  	  buflen = udp_recv(info->udp, buffer, RTP_MAX_PACKET_LEN);
  	  mpeg2t_decode_buffer(info, buffer, buflen);
  	}
***************
*** 306,322 ****
    } while (ret == SDL_MUTEX_TIMEDOUT && max >= 0);
  
    if (ret == SDL_MUTEX_TIMEDOUT) {
      snprintf(errmsg, errmsg_len, "Did not receive Transport Stream Program Map in %d seconds", config.get_config_value(CONFIG_MPEG2T_PAM_WAIT_SECS));
      mpeg2t_delete_client(info);
      return NULL;
    }
    return (info);
  }
  
  void mpeg2t_delete_client (mpeg2t_client_t *info)
  {
    mpeg2t_thread_close(info);
!   CHECK_AND_FREE(info, address);
    free(info);
  }
  
--- 385,420 ----
    } while (ret == SDL_MUTEX_TIMEDOUT && max >= 0);
  
    if (ret == SDL_MUTEX_TIMEDOUT) {
+     if (info->decoder->program_maps_recvd != 0) {
+       mpeg2t_message(LOG_INFO, "Program count received %d doesn't match program count %d", 
+ 		     info->decoder->program_maps_recvd, 
+ 		     info->decoder->program_count);
+     } else {
        snprintf(errmsg, errmsg_len, "Did not receive Transport Stream Program Map in %d seconds", config.get_config_value(CONFIG_MPEG2T_PAM_WAIT_SECS));
        mpeg2t_delete_client(info);
        return NULL;
      }
+   }
    return (info);
  }
  
  void mpeg2t_delete_client (mpeg2t_client_t *info)
  {
+   mpeg2t_stream_t *p;
+ 
    mpeg2t_thread_close(info);
! 
!   CHECK_AND_FREE(info->address);
!   delete_mpeg2t_transport(info->decoder);
!   info->decoder = NULL;
!   SDL_DestroyMutex(info->msg_mutex);
!   SDL_DestroySemaphore(info->pam_recvd_sem);
!   p = info->stream;
!   while (p != NULL) {
!     info->stream = p->next_stream;
!     free(p);
!     p = info->stream;
!   }
    free(info);
  }
  
***************
*** 325,340 ****
    mpeg2t_delete_client((mpeg2t_client_t *)data);
  }
  
  int create_mpeg2t_session (CPlayerSession *psptr,
  			   const char *orig_name, 
  			   char *errmsg, 
  			   uint32_t errlen, 
! 			   //int have_audio_driver,
  			   control_callback_vft_t *cc_vft)
  {
    const char *colon, *slash, *name;
    char *addr, *port;
    uint32_t addrlen, portlen;
    name = orig_name + strlen("mpeg2t://");
    colon = strchr(name, ':');
    slash = strchr(name, '/');
--- 423,627 ----
    mpeg2t_delete_client((mpeg2t_client_t *)data);
  }
  
+ static int mpeg2t_create_video(mpeg2t_client_t *info,
+ 			       CPlayerSession *psptr, 
+ 			       video_query_t *vq, 
+ 			       int video_offset,
+ 			       char *errmsg, 
+ 			       uint32_t errlen,
+ 			       int &sdesc)
+ {
+   int ix;
+   CPlayerMedia *mptr;
+   codec_plugin_t *plugin;
+ 
+   for (ix = 0; ix < video_offset; ix++) {
+     if (vq[ix].enabled != 0) {
+ 
+       mptr = new CPlayerMedia(psptr);
+       if (mptr == NULL) {
+ 	return (-1);
+       }
+       video_info_t *vinfo;
+       vinfo = MALLOC_STRUCTURE(video_info_t);
+       vinfo->height = vq[ix].h;
+       vinfo->width = vq[ix].w;
+       if (vinfo->height == 480 && vinfo->width == 352) {
+ 	psptr->double_screen_width();
+       }
+       plugin = check_for_video_codec("MPEG2 TRANSPORT",
+ 				     NULL,
+ 				     vq[ix].type,
+ 				     vq[ix].profile,
+ 				     vq[ix].config, 
+ 				     vq[ix].config_len);
+ 
+       int ret = mptr->create_video_plugin(plugin, 
+ 					  "MPEG2 TRANSPORT",
+ 					  vq[ix].type,
+ 					  vq[ix].profile,
+ 					  NULL, // sdp info
+ 					  vinfo, // video info
+ 					  vq[ix].config,
+ 					  vq[ix].config_len);
+ 
+       if (ret < 0) {
+ 	mpeg2t_message(LOG_ERR, "Failed to create plugin data");
+ 	snprintf(errmsg, errlen, "Failed to start plugin");
+ 	delete mptr;
+ 	return -1;
+       }
+ 
+       CMpeg2tVideoByteStream *vbyte;
+       mpeg2t_pid_t *pidptr;
+       mpeg2t_es_t *es_pid;
+       pidptr = mpeg2t_lookup_pid(info->decoder,vq[ix].track_id);
+       if (pidptr->pak_type != MPEG2T_ES_PAK) {
+ 	mpeg2t_message(LOG_CRIT, "mpeg2t video type is not es pak");
+ 	exit(1);
+       }
+       es_pid = (mpeg2t_es_t *)pidptr;
+       vbyte = new CMpeg2tVideoByteStream(es_pid);
+       if (vbyte == NULL) {
+ 	mpeg2t_message(LOG_CRIT, "failed to create byte stream");
+ 	delete mptr;
+ 	return (-1);
+       }
+       ret = mptr->create(vbyte, TRUE, errmsg, errlen, 1);
+       if (ret != 0) {
+ 	mpeg2t_message(LOG_CRIT, "failed to create from file");
+ 	return (-1);
+       }
+       mpeg2t_stream_t *stream;
+       stream = MALLOC_STRUCTURE(mpeg2t_stream_t);
+       stream->m_mptr = mptr;
+       stream->m_is_video = 1;
+       stream->m_buffering = 1;
+       stream->m_frames_since_last_psts = 0;
+       stream->m_last_psts = 0;
+       stream->m_have_info = 0;
+       stream->next_stream = info->stream;
+       info->stream = stream;
+       if (es_pid->info_loaded) {
+ 	char buffer[80];
+ 	if (mpeg2t_write_stream_info(es_pid, buffer, 80) >= 0) {
+ 	  psptr->set_session_desc(sdesc, buffer);
+ 	  sdesc++;
+ 	}
+       }
+       mpeg2t_es_set_userdata(es_pid, stream);
+       mpeg2t_start_saving_frames(es_pid);
+     } 
+   }
+   return 0;
+ }
+ 
+ static int mpeg2t_create_audio (mpeg2t_client_t *info,
+ 				CPlayerSession *psptr, 
+ 				audio_query_t *aq, 
+ 				int audio_offset,
+ 				char *errmsg, 
+ 				uint32_t errlen,
+ 				int &sdesc)
+ {
+   int ix;
+   CPlayerMedia *mptr;
+   codec_plugin_t *plugin;
+ 
+   for (ix = 0; ix < audio_offset; ix++) {
+     if (aq[ix].enabled != 0) {
+ 
+       mptr = new CPlayerMedia(psptr);
+       if (mptr == NULL) {
+ 	return (-1);
+       }
+       audio_info_t *ainfo;
+       ainfo = MALLOC_STRUCTURE(audio_info_t);
+       ainfo->freq = aq[ix].sampling_freq;
+       ainfo->chans = aq[ix].chans;
+       ainfo->bitspersample = 0;
+       plugin = check_for_audio_codec("MPEG2 TRANSPORT",
+ 				     NULL,
+ 				     aq[ix].type,
+ 				     aq[ix].profile,
+ 				     aq[ix].config, 
+ 				     aq[ix].config_len);
+ 
+       int ret = mptr->create_audio_plugin(plugin, 
+ 					  "MPEG2 TRANSPORT",
+ 					  aq[ix].type,
+ 					  aq[ix].profile,
+ 					  NULL, // sdp info
+ 					  ainfo, // video info
+ 					  aq[ix].config,
+ 					  aq[ix].config_len);
+ 
+       if (ret < 0) {
+ 	mpeg2t_message(LOG_ERR, "Failed to create plugin data");
+ 	snprintf(errmsg, errlen, "Failed to start plugin");
+ 	delete mptr;
+ 	return -1;
+       }
+ 
+       CMpeg2tAudioByteStream *abyte;
+       mpeg2t_pid_t *pidptr;
+       mpeg2t_es_t *es_pid;
+       pidptr = mpeg2t_lookup_pid(info->decoder,aq[ix].track_id);
+       if (pidptr->pak_type != MPEG2T_ES_PAK) {
+ 	mpeg2t_message(LOG_CRIT, "mpeg2t video type is not es pak");
+ 	exit(1);
+       }
+       es_pid = (mpeg2t_es_t *)pidptr;
+       abyte = new CMpeg2tAudioByteStream(es_pid);
+       if (abyte == NULL) {
+ 	mpeg2t_message(LOG_CRIT, "failed to create byte stream");
+ 	delete mptr;
+ 	return (-1);
+       }
+       ret = mptr->create(abyte, FALSE, errmsg, errlen, 1);
+       if (ret != 0) {
+ 	mpeg2t_message(LOG_CRIT, "failed to create from file");
+ 	return (-1);
+       }
+       mpeg2t_stream_t *stream;
+       stream = MALLOC_STRUCTURE(mpeg2t_stream_t);
+       stream->m_mptr = mptr;
+       stream->m_is_video = 0;
+       stream->m_buffering = 1;
+       stream->m_frames_since_last_psts = 0;
+       stream->m_last_psts = 0;
+       stream->m_have_info = 0;
+       stream->next_stream = info->stream;
+       info->stream = stream;
+       if (es_pid->info_loaded) {
+ 	char buffer[80];
+ 	if (mpeg2t_write_stream_info(es_pid, buffer, 80) >= 0) {
+ 	  psptr->set_session_desc(sdesc, buffer);
+ 	  sdesc++;
+ 	}
+       }
+ 
+       mpeg2t_es_set_userdata(es_pid, stream);
+       mpeg2t_start_saving_frames(es_pid);
+     } 
+   }
+   return 0;
+ }
+ 
  int create_mpeg2t_session (CPlayerSession *psptr,
  			   const char *orig_name, 
+ 			   session_desc_t *sdp,
  			   char *errmsg, 
  			   uint32_t errlen, 
! 			   int have_audio_driver,
  			   control_callback_vft_t *cc_vft)
  {
    const char *colon, *slash, *name;
    char *addr, *port;
    uint32_t addrlen, portlen;
+   mpeg2t_client_t *mp2t;
+   in_port_t rxport;
+     if (orig_name != NULL) {
      name = orig_name + strlen("mpeg2t://");
      colon = strchr(name, ':');
      slash = strchr(name, '/');
***************
*** 353,359 ****
    addr[addrlen] = '\0';
    memcpy(port, colon + 1, portlen);
    port[portlen] = '\0';
-   in_port_t rxport;
    char *eport;
    rxport = strtoul(port, &eport, 10);
    if (eport == NULL || *eport != '\0') {
--- 640,645 ----
***************
*** 365,376 ****
    free(port);
    
  
-   mpeg2t_client_t *mp2t;
    mp2t = mpeg2t_create_client(addr, rxport, 0, 0, 0.0, 0, errmsg, errlen);
    free(addr);
    if (mp2t == NULL) {
      return -1;
    }
    psptr->set_media_close_callback(close_mpeg2t_client, mp2t);
    return -1;
  }  
--- 651,909 ----
      free(port);
    
  
      mp2t = mpeg2t_create_client(addr, rxport, 0, 0, 0.0, 0, errmsg, errlen);
      free(addr);
+   } else if (sdp != NULL) {
+     // from SDP
+     connect_desc_t *cptr;
+     double bw;
+     cptr = get_connect_desc_from_media(sdp->media);
+     if (find_rtcp_bandwidth_from_media(sdp->media, &bw) < 0) {
+       bw = 5000.0;
+     }
+     mp2t = mpeg2t_create_client(cptr->conn_addr,
+ 				sdp->media->port,
+ 				0,
+ 				1, // use rtp
+ 				bw,
+ 				cptr->ttl,
+ 				errmsg, 
+ 				errlen);
+   } else {
+     return -1;
+   }
+ 
    if (mp2t == NULL) {
      return -1;
    }
    psptr->set_media_close_callback(close_mpeg2t_client, mp2t);
+   // Okay - we need to gather together information about pids and
+   // lists, then call the audio/video query vectors.
+   int audio_count, video_count;
+   int audio_info_count, video_info_count;
+   int passes;
+   mpeg2t_pid_t *pid_ptr;
+   mpeg2t_es_t *es_pid;
+   pid_ptr = &mp2t->decoder->pas.pid;
+   audio_count = video_count = 0;
+   audio_info_count = video_info_count = 0;
+   passes = 0;
+ 
+   do {
+   SDL_LockMutex(mp2t->decoder->pid_mutex);
+   while (pid_ptr != NULL) {
+     switch (pid_ptr->pak_type) {
+     case MPEG2T_PAS_PAK:
+     case MPEG2T_PROG_MAP_PAK:
+       break;
+     case MPEG2T_ES_PAK:
+       es_pid = (mpeg2t_es_t *)pid_ptr;
+       switch (es_pid->stream_type) {
+       case MPEG2T_ST_MPEG_VIDEO:
+       case MPEG2T_ST_MPEG4_VIDEO:
+       case MPEG2T_ST_11172_VIDEO:
+ 	video_count++;
+ 	if (es_pid->info_loaded) video_info_count++;
+ 	break;
+       case MPEG2T_ST_11172_AUDIO:
+       case MPEG2T_ST_MPEG_AUDIO:
+ 	audio_count++;
+ 	if (es_pid->info_loaded) audio_info_count++;
+ 	break;
+       case MPEG2T_ST_MPEG_AUDIO_6_A:
+       case MPEG2T_ST_MPEG_AUDIO_6_B:
+       case MPEG2T_ST_MPEG_AUDIO_6_C:
+       case MPEG2T_ST_MPEG_AUDIO_6_D:
+       case MPEG2T_ST_MPEG2_AAC:
+       default:
+ 	mpeg2t_message(LOG_INFO, "PID %x - Unknown/unused stream type %d",
+ 		       pid_ptr->pid, es_pid->stream_type);
+ 	break;
+       }
+       break;
+     }
+     pid_ptr = pid_ptr->next_pid;
+   }
+   SDL_UnlockMutex(mp2t->decoder->pid_mutex);
+   passes++;
+   if (audio_count != audio_info_count ||
+       video_info_count != video_count) {
+     SDL_Delay(1 * 1000);
+   }
+   } while (audio_info_count != audio_count && video_info_count != video_info_count);
+   video_query_t *vq;
+   audio_query_t *aq;
+   if (video_count > 0) {
+     vq = (video_query_t *)malloc(sizeof(video_query_t) * video_count);
+     memset(vq, 0, sizeof(video_query_t) * video_count);
+   } else {
+     vq = NULL;
+   }
+   if (audio_count > 0) {
+     aq = (audio_query_t *)malloc(sizeof(audio_query_t) * audio_count);
+     memset(aq, 0, sizeof(audio_query_t) * audio_count);
+   } else {
+     aq = NULL;
+   }
+ 
+   int vid_cnt = 0, aud_cnt = 0;
+   codec_plugin_t *plugin;
+ 
+   pid_ptr = &mp2t->decoder->pas.pid;
+   SDL_LockMutex(mp2t->decoder->pid_mutex);
+   while (pid_ptr != NULL) {
+     switch (pid_ptr->pak_type) {
+     case MPEG2T_PAS_PAK:
+     case MPEG2T_PROG_MAP_PAK:
+       break;
+     case MPEG2T_ES_PAK:
+       es_pid = (mpeg2t_es_t *)pid_ptr;
+       switch (es_pid->stream_type) {
+       case MPEG2T_ST_11172_VIDEO:
+       case MPEG2T_ST_MPEG_VIDEO:
+       case MPEG2T_ST_MPEG4_VIDEO:
+ 	if (vid_cnt < video_count) {
+ 	  plugin = check_for_video_codec("MPEG2 TRANSPORT",
+ 					 NULL,
+ 					 es_pid->stream_type,
+ 					 -1,
+ 					 es_pid->es_data,
+ 					 es_pid->es_info_len);
+ 	  if (plugin == NULL) {
+ 	    snprintf(errmsg, errlen, 
+ 		     "Can't find plugin for stream type %d",
+ 		     es_pid->stream_type);
+ 	    mpeg2t_message(LOG_ERR, errmsg);
+ 	  } else {
+ 	    vq[vid_cnt].track_id = pid_ptr->pid;
+ 	    vq[vid_cnt].compressor = "MPEG2 TRANSPORT";
+ 	    vq[vid_cnt].type = es_pid->stream_type;
+ 	    vq[vid_cnt].profile = -1;
+ 	    vq[vid_cnt].fptr = NULL;
+ 	    if (es_pid->info_loaded != 0) {
+ 	      vq[vid_cnt].h = es_pid->h;
+ 	      vq[vid_cnt].w = es_pid->w;
+ 	      vq[vid_cnt].frame_rate = es_pid->frame_rate;
+ 	      mpeg2t_message(LOG_DEBUG, "video stream h %d w %d fr %g bitr %g", 
+ 			     es_pid->h, es_pid->w, es_pid->frame_rate, 
+ 			     es_pid->bitrate);
+ 	    } else {
+ 	      vq[vid_cnt].h = -1;
+ 	      vq[vid_cnt].w = -1;
+ 	      vq[vid_cnt].frame_rate = 0.0;
+ 	    }
+ 	    vq[vid_cnt].config = es_pid->es_data;
+ 	    vq[vid_cnt].config_len = es_pid->es_info_len;
+ 	    vq[vid_cnt].enabled = 0;
+ 	    vq[vid_cnt].reference = NULL;
+ 	    vid_cnt++;
+ 	  }
+ 	}
+ 	break;
+       case MPEG2T_ST_MPEG_AUDIO:
+       case MPEG2T_ST_11172_AUDIO:
+ 	if (aud_cnt < audio_count) {
+ 	  plugin = check_for_audio_codec("MPEG2 TRANSPORT",
+ 					 NULL,
+ 					 es_pid->stream_type,
+ 					 -1,
+ 					 es_pid->es_data,
+ 					 es_pid->es_info_len);
+ 	  if (plugin == NULL) {
+ 	    snprintf(errmsg, errlen, 
+ 		     "Can't find plugin for stream type %d",
+ 		     es_pid->stream_type);
+ 	    mpeg2t_message(LOG_ERR, errmsg);
+ 	  } else {
+ 	    aq[aud_cnt].track_id = pid_ptr->pid;
+ 	    aq[aud_cnt].compressor = "MPEG2 TRANSPORT";
+ 	    aq[aud_cnt].type = es_pid->stream_type;
+ 	    aq[aud_cnt].profile = -1;
+ 	    aq[aud_cnt].fptr = NULL;
+ 	    aq[aud_cnt].config = es_pid->es_data;
+ 	    aq[aud_cnt].config_len = es_pid->es_info_len;
+ 	    if (es_pid->info_loaded != 0) {
+ 	      aq[aud_cnt].chans = es_pid->audio_chans;
+ 	      aq[aud_cnt].sampling_freq = es_pid->sample_freq;
+ 	      mpeg2t_message(LOG_DEBUG, "audio stream chans %d sf %d bitrate %g", 
+ 			     es_pid->audio_chans, es_pid->sample_freq, es_pid->bitrate / 1000.0);
+ 	    } else {
+ 	      aq[aud_cnt].chans = -1;
+ 	      aq[aud_cnt].sampling_freq = -1;
+ 	    }
+ 	    aq[aud_cnt].enabled = 0;
+ 	    aq[aud_cnt].reference = NULL;
+ 	    aud_cnt++;
+ 	  }
+ 	}
+ 	break;
+       case MPEG2T_ST_MPEG_AUDIO_6_A:
+       case MPEG2T_ST_MPEG_AUDIO_6_B:
+       case MPEG2T_ST_MPEG_AUDIO_6_C:
+       case MPEG2T_ST_MPEG_AUDIO_6_D:
+       case MPEG2T_ST_MPEG2_AAC:
+       default:
+ 	mpeg2t_message(LOG_INFO, "PID %x - Unknown/unused stream type %d",
+ 		       es_pid->stream_type, pid_ptr->pid);
+ 	break;
+       }
+       break;
+     }
+     pid_ptr = pid_ptr->next_pid;
+   }
+   SDL_UnlockMutex(mp2t->decoder->pid_mutex);
+   if (cc_vft && cc_vft->media_list_query != NULL) {
+     (cc_vft->media_list_query)(psptr, video_count, vq, audio_count, aq);
+   } else {
+     if (video_count > 0) {
+       vq[0].enabled = 1;
+     }
+     if (audio_count > 0) {
+       aq[0].enabled = 1;
+     }
+   }
+   int total_enabled = 0;
+ 
+   psptr->set_session_desc(0, "MPEG2 Transport Stream");
+ 
+   int sdesc = 1;
+   for (vid_cnt = 0; vid_cnt < video_count; vid_cnt++) {
+     if (vq[vid_cnt].enabled == 1) {
+       // create video media
+       if (mpeg2t_create_video(mp2t, psptr, vq, video_count, 
+ 			      errmsg, errlen, sdesc) < 0) {
+ 	free(aq);
+ 	free(vq);
+ 	return -1;
+       }
+       total_enabled++;
+     }
+   }
+   for (aud_cnt = 0; aud_cnt < audio_count; aud_cnt++) {
+     if (aq[aud_cnt].enabled == 1) {
+       // create audio media
+       if (mpeg2t_create_audio(mp2t, psptr, aq, 
+ 			      audio_count, errmsg, errlen, sdesc) < 0) {
+ 	free(aq);
+ 	free(vq);
+ 	return -1;
+       }
+       total_enabled++;
+     }
+   }
+   free(aq);
+   free(vq);
+   if (total_enabled != 0) {
+     // This is to get the m_streaming bit set, so we can do the
+     // elapsed time correctly
+     psptr->create_streaming_broadcast(NULL, errmsg, errlen);
+     return 0;
+   }
    return -1;
  }  
+ 
+ // NOTE TO SELF - need to add a mechanism that indicates that 
+ // we're paused.  We'll need to keep reading the RTP packets, but
+ // will want to flush them.
+ // Options are to add a do_pause to the bytestream.
+ // or have a pause registration in either player media or playersession
Index: player/src/mpeg2t_thread.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg2t_thread.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
Index: player/src/mpeg2t_thread_nx.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg2t_thread_nx.cpp,v
retrieving revision 1.1
retrieving revision 1.3
diff -c -w -r1.1 -r1.3
*** player/src/mpeg2t_thread_nx.cpp	2002/07/05 22:03:53	1.1
--- player/src/mpeg2t_thread_nx.cpp	2002/07/19 16:54:08	1.3
***************
*** 2,8 ****
  #include "mpeg2t_thread_nx.h"
  #include "player_util.h"
  
- #undef HAVE_SOCKETPAIR
  #define COMM_SOCKET_THREAD info->m_thread_info->comm_socket_write_to
  #define COMM_SOCKET_CALLER info->m_thread_info->comm_socket[1]
  
--- 2,7 ----
***************
*** 56,71 ****
  #else
    COMM_SOCKET_THREAD = info->m_thread_info->comm_socket[0];
  #endif
-   mpeg2t_message(LOG_DEBUG, "mpeg2t_thread running");
  
  }
  int mpeg2t_thread_wait_for_event (mpeg2t_client_t *info)
  {
    mpeg2t_thread_info_t *tinfo = info->m_thread_info;
-   int count;
    int ret;
  
    #ifdef HAVE_POLL
  #define DATA_SOCKET_HAS_DATA ((tinfo->pollit[1].revents & (POLLIN | POLLPRI)) != 0)
  #define RTCP_SOCKET_HAS_DATA ((tinfo->pollit[2].revents & (POLLIN | POLLPRI)) != 0)
  #define COMM_SOCKET_HAS_DATA   ((tinfo->pollit[0].revents & (POLLIN | POLLPRI)) != 0)
--- 55,69 ----
  #else
    COMM_SOCKET_THREAD = info->m_thread_info->comm_socket[0];
  #endif
  
  }
  int mpeg2t_thread_wait_for_event (mpeg2t_client_t *info)
  {
    mpeg2t_thread_info_t *tinfo = info->m_thread_info;
    int ret;
  
    #ifdef HAVE_POLL
+   int count;
  #define DATA_SOCKET_HAS_DATA ((tinfo->pollit[1].revents & (POLLIN | POLLPRI)) != 0)
  #define RTCP_SOCKET_HAS_DATA ((tinfo->pollit[2].revents & (POLLIN | POLLPRI)) != 0)
  #define COMM_SOCKET_HAS_DATA   ((tinfo->pollit[0].revents & (POLLIN | POLLPRI)) != 0)
***************
*** 81,89 ****
  
      count = info->data_socket == 0 ? 1 : info->useRTP ? 3 : 2;
  
!     mpeg2t_message(LOG_DEBUG, "start poll");
      ret = poll(tinfo->pollit,count, info->recv_timeout);
!     mpeg2t_message(LOG_DEBUG, "poll ret %d - count %d", ret, count);
  #else
  #define DATA_SOCKET_HAS_DATA (FD_ISSET(info->data_socket, &tinfo->read_set))
  #define RTCP_SOCKET_HAS_DATA (FD_ISSET(info->rtcp_socket, &tinfo->read_set))
--- 79,87 ----
  
      count = info->data_socket == 0 ? 1 : info->useRTP ? 3 : 2;
  
!     //mpeg2t_message(LOG_DEBUG, "start poll");
      ret = poll(tinfo->pollit,count, info->recv_timeout);
!     //mpeg2t_message(LOG_DEBUG, "poll ret %d - count %d", ret, count);
  #else
  #define DATA_SOCKET_HAS_DATA (FD_ISSET(info->data_socket, &tinfo->read_set))
  #define RTCP_SOCKET_HAS_DATA (FD_ISSET(info->rtcp_socket, &tinfo->read_set))
***************
*** 100,105 ****
--- 98,104 ----
  	FD_SET(info->rtcp_socket, &tinfo->read_set);
  	max_fd = MAX(info->rtcp_socket, max_fd);
        }
+     }
      FD_SET(COMM_SOCKET_THREAD, &tinfo->read_set);
      timeout.tv_sec = info->recv_timeout / 1000;
      timeout.tv_usec = (info->recv_timeout % 1000) * 1000;
***************
*** 173,180 ****
      mpeg2t_message(LOG_CRIT, "Couldn't create comm sockets - errno %d", errno);
      return -1;
    }
-   mpeg2t_message(LOG_DEBUG, "values are %d %d", tinfo->comm_socket[0],
- 		 tinfo->comm_socket[1]);
  #else
    COMM_SOCKET_THREAD = -1;
    COMM_SOCKET_CALLER = socket(AF_UNIX, SOCK_STREAM, 0);
--- 172,177 ----
Index: player/src/mpeg3_bytestream.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg3_bytestream.cpp,v
retrieving revision 1.10
retrieving revision 1.13
diff -c -w -r1.10 -r1.13
*** player/src/mpeg3_bytestream.cpp	2002/07/03 18:10:15	1.10
--- player/src/mpeg3_bytestream.cpp	2002/07/24 22:00:24	1.13
***************
*** 58,63 ****
--- 58,64 ----
  #ifdef OUTPUT_TO_FILE
    fclose(m_output_file);
  #endif
+   mpeg3_close(m_file);
  }
  
  int CMpeg3VideoByteStream::eof(void)
***************
*** 159,165 ****
    return (1);
  }
  
! void CMpeg3VideoByteStream::set_start_time (uint64_t start)
  {
    m_play_start_time = start;
  
--- 160,166 ----
    return (1);
  }
  
! void CMpeg3VideoByteStream::play (uint64_t start)
  {
    m_play_start_time = start;
  
***************
*** 209,214 ****
--- 210,217 ----
  #ifdef OUTPUT_TO_FILE
    fclose(m_output_file);
  #endif
+   CHECK_AND_FREE(m_buffer);
+   mpeg3_close(m_file);
  }
  
  int CMpeg3AudioByteStream::eof(void)
***************
*** 297,303 ****
    return (1);
  }
  
! void CMpeg3AudioByteStream::set_start_time (uint64_t start)
  {
    m_play_start_time = start;
  
--- 300,306 ----
    return (1);
  }
  
! void CMpeg3AudioByteStream::play (uint64_t start)
  {
    m_play_start_time = start;
  
Index: player/src/mpeg3_bytestream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg3_bytestream.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -w -r1.6 -r1.7
*** player/src/mpeg3_bytestream.h	2002/07/10 19:58:52	1.6
--- player/src/mpeg3_bytestream.h	2002/07/22 21:52:49	1.7
***************
*** 49,55 ****
  		      uint32_t *buflen);
    double get_max_playtime(void);
  
!   void set_start_time(uint64_t start);
   private:
  #ifdef OUTPUT_TO_FILE
    FILE *m_output_file;
--- 49,55 ----
  		      uint32_t *buflen);
    double get_max_playtime(void);
  
!   void play(uint64_t start);
   private:
  #ifdef OUTPUT_TO_FILE
    FILE *m_output_file;
***************
*** 86,92 ****
  		      uint32_t *buflen);
    double get_max_playtime(void);
  
!   void set_start_time(uint64_t start);
   private:
  #ifdef OUTPUT_TO_FILE
    FILE *m_output_file;
--- 86,92 ----
  		      uint32_t *buflen);
    double get_max_playtime(void);
  
!   void play(uint64_t start);
   private:
  #ifdef OUTPUT_TO_FILE
    FILE *m_output_file;
Index: player/src/mpeg3_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg3_file.cpp,v
retrieving revision 1.2
retrieving revision 1.8
diff -c -w -r1.2 -r1.8
*** player/src/mpeg3_file.cpp	2002/05/17 22:34:02	1.2
--- player/src/mpeg3_file.cpp	2002/08/19 18:29:47	1.8
***************
*** 32,41 ****
  #include "mpeg3_bytestream.h"
  #include "codec_plugin_private.h"
  
! static int create_mpeg3_video (mpeg3_t *vfile, 
  			       CPlayerSession *psptr,
  			       char *errmsg, 
! 			       uint32_t errlen)
  {
    CPlayerMedia *mptr;
    codec_plugin_t *plugin;
--- 32,43 ----
  #include "mpeg3_bytestream.h"
  #include "codec_plugin_private.h"
  
! static int create_mpeg3_video (video_query_t *vq,
! 			       mpeg3_t *vfile, 
  			       CPlayerSession *psptr,
  			       char *errmsg, 
! 			       uint32_t errlen, 
! 			       int &sdesc)
  {
    CPlayerMedia *mptr;
    codec_plugin_t *plugin;
***************
*** 60,69 ****
    }
    video_info_t *vinfo;
    vinfo = MALLOC_STRUCTURE(video_info_t);
!   vinfo->height = mpeg3_video_height(vfile, 0);
!   vinfo->width = mpeg3_video_width(vfile, 0);
  
!   ret = mptr->create_video_plugin(plugin, NULL, vinfo, NULL, 0);
    if (ret < 0) {
      mpeg3f_message(LOG_ERR, "Failed to create video plugin");
      snprintf(errmsg, errlen, "Failed to create video plugin");
--- 62,90 ----
    }
    video_info_t *vinfo;
    vinfo = MALLOC_STRUCTURE(video_info_t);
!   vinfo->height = vq->h;
!   vinfo->width = vq->w;
  
!   if (vinfo->height == 480 && vinfo->width == 352) {
!     psptr->double_screen_width();
!   }
!   char buffer[80];
!   int bitrate;
!   ret = snprintf(buffer, 80, "MPEG-%d Video, %d x %d, %g",
! 		 mpeg3_video_layer(vfile, vq->track_id),
! 		 vinfo->width, vinfo->height, vq->frame_rate);
!   bitrate = (int)(mpeg3_video_bitrate(vfile, vq->track_id) / 1000.0);
!   if (bitrate > 0) {
!     snprintf(buffer + ret, 80 - ret, ", %d kbps", bitrate);
!   }
!   psptr->set_session_desc(sdesc, buffer);
!   sdesc++;
!   mpeg3f_message(LOG_DEBUG, "video stream h %d w %d fr %g bitr %d", 
! 		 vinfo->height, vinfo->width, vq->frame_rate,
! 		 bitrate);
!   ret = mptr->create_video_plugin(plugin, "MPEG FILE", 
! 				  vq->type, vq->profile, 
! 				  NULL, vinfo, NULL, 0);
    if (ret < 0) {
      mpeg3f_message(LOG_ERR, "Failed to create video plugin");
      snprintf(errmsg, errlen, "Failed to create video plugin");
***************
*** 71,82 ****
      return -1;
    }
    CMpeg3VideoByteStream *vbyte;
!   vbyte = new CMpeg3VideoByteStream(vfile, 0);
    if (vbyte == NULL) {
      snprintf(errmsg, errlen, "Failed to create video bytestream");
      return -1;
    }
!   ret = mptr->create_from_file(vbyte, TRUE);
    if (ret != 0) {
      snprintf(errmsg, errlen, "Couldn't create video media");
      return -1;
--- 92,103 ----
      return -1;
    }
    CMpeg3VideoByteStream *vbyte;
!   vbyte = new CMpeg3VideoByteStream(vfile, vq->track_id);
    if (vbyte == NULL) {
      snprintf(errmsg, errlen, "Failed to create video bytestream");
      return -1;
    }
!   ret = mptr->create(vbyte, TRUE, errmsg, errlen);
    if (ret != 0) {
      snprintf(errmsg, errlen, "Couldn't create video media");
      return -1;
***************
*** 84,93 ****
    return 1;
  }
  
! static int create_mpeg3_audio (mpeg3_t *afile, 
  			       CPlayerSession *psptr,
  			       char *errmsg, 
! 			       uint32_t errlen)
  {
    CPlayerMedia *mptr;
    codec_plugin_t *plugin;
--- 105,116 ----
    return 1;
  }
  
! static int create_mpeg3_audio (audio_query_t * aq,
! 			       mpeg3_t *afile, 
  			       CPlayerSession *psptr,
  			       char *errmsg, 
! 			       uint32_t errlen,
! 			       int &sdesc)
  {
    CPlayerMedia *mptr;
    codec_plugin_t *plugin;
***************
*** 95,107 ****
  
    plugin = check_for_audio_codec("MPEG FILE",
  				 NULL,
! 				 mpeg3_get_audio_format(afile, 0),
  				 -1,
  				 NULL,
  				 0);
    if (plugin == NULL) {
      snprintf(errmsg, errlen, "Can't find plugin for mpeg audio format %s",
! 	     mpeg3_audio_format(afile, 0));
      return 0;
    } 
    mptr = new CPlayerMedia(psptr);
--- 118,130 ----
  
    plugin = check_for_audio_codec("MPEG FILE",
  				 NULL,
! 				 aq->type,
  				 -1,
  				 NULL,
  				 0);
    if (plugin == NULL) {
      snprintf(errmsg, errlen, "Can't find plugin for mpeg audio format %s",
! 	     mpeg3_audio_format(afile, aq->track_id));
      return 0;
    } 
    mptr = new CPlayerMedia(psptr);
***************
*** 111,121 ****
    }
    audio_info_t *ainfo;
    ainfo = MALLOC_STRUCTURE(audio_info_t);
!   ainfo->freq = mpeg3_sample_rate(afile, 0);
!   ainfo->chans = mpeg3_audio_channels(afile, 0);
    ainfo->bitspersample = 16;
  
!   ret = mptr->create_audio_plugin(plugin, NULL, ainfo, NULL, 0);
    if (ret < 0) {
      mpeg3f_message(LOG_ERR, "Failed to create audio plugin");
      snprintf(errmsg, errlen, "Failed to create audio plugin");
--- 134,154 ----
    }
    audio_info_t *ainfo;
    ainfo = MALLOC_STRUCTURE(audio_info_t);
!   ainfo->freq = aq->sampling_freq;
!   ainfo->chans = aq->chans;
    ainfo->bitspersample = 16;
+ 
+   char buffer[80];
+   snprintf(buffer, 80, "%s Audio, %d %s", 
+ 	   mpeg3_audio_format(afile, aq->track_id),
+ 	   ainfo->freq,
+ 	   ainfo->chans == 1 ? "mono" : "stereo");
+   psptr->set_session_desc(sdesc, buffer);
+   sdesc++;
  
!   ret = mptr->create_audio_plugin(plugin, "MPEG FILE", 
! 				  aq->type, aq->profile,
! 				  NULL, ainfo, NULL, 0);
    if (ret < 0) {
      mpeg3f_message(LOG_ERR, "Failed to create audio plugin");
      snprintf(errmsg, errlen, "Failed to create audio plugin");
***************
*** 124,135 ****
      return -1;
    }
    CMpeg3AudioByteStream *abyte;
!   abyte = new CMpeg3AudioByteStream(afile, 0);
    if (abyte == NULL) {
      snprintf(errmsg, errlen, "Failed to create audio bytestream");
      return -1;
    }
!   ret = mptr->create_from_file(abyte, FALSE);
    if (ret != 0) {
      snprintf(errmsg, errlen, "Couldn't create audio media");
      return -1;
--- 157,168 ----
      return -1;
    }
    CMpeg3AudioByteStream *abyte;
!   abyte = new CMpeg3AudioByteStream(afile, aq->track_id);
    if (abyte == NULL) {
      snprintf(errmsg, errlen, "Failed to create audio bytestream");
      return -1;
    }
!   ret = mptr->create(abyte, FALSE);
    if (ret != 0) {
      snprintf(errmsg, errlen, "Couldn't create audio media");
      return -1;
***************
*** 141,150 ****
  				const char *name,
  				char *errmsg, 
  				uint32_t errlen,
! 				int has_audio_driver)
  {
!   mpeg3_t *file, *vfile, *afile;
!   int has_video, has_audio;
  
    if (mpeg3_check_sig(name) != 1) {
      snprintf(errmsg, errlen, "file %s is not a valid .mpg file",
--- 174,190 ----
  				const char *name,
  				char *errmsg, 
  				uint32_t errlen,
! 				int have_audio_driver,
! 				control_callback_vft_t *cc_vft)
  {
!   mpeg3_t *file,*newfile;
!   int video_streams, audio_streams;
!   int video_cnt, audio_cnt;
!   int ix;
!   codec_plugin_t *plugin;
!   int audio_offset;
!   int ret;
!   int sdesc;
  
    if (mpeg3_check_sig(name) != 1) {
      snprintf(errmsg, errlen, "file %s is not a valid .mpg file",
***************
*** 153,189 ****
    }
  
    file = mpeg3_open(name);
!   has_video = mpeg3_has_video(file);
!   has_audio = mpeg3_has_audio(file);
!   if (has_video != 0 && 
!       (has_audio != 0 && has_audio_driver)) {
!     // need to open both audio and video
!     vfile = file;
!     afile = mpeg3_open_copy(name, vfile);
!   } else if (has_video != 0) {
!     vfile = file;
!     afile = NULL;
!   } else if (has_audio != 0) {
!     vfile = NULL;
!     afile = file;
!   } else {
!     snprintf(errmsg, errlen, "Weird error - neither audio nor video");
!     return -1;
!   }
!   if (vfile != NULL) {
!     has_video = create_mpeg3_video(vfile, psptr, errmsg, errlen);
!     if (has_video <= 0) {
!       mpeg3_close(vfile);
!     }
!     if (has_video < 0) return -1;
!   }
!   if (afile != NULL) {
!     has_audio = create_mpeg3_audio(afile, psptr, errmsg, errlen);
!     if (has_audio <= 0) {
!       mpeg3_close(afile);
      }
!     if (has_audio < 0) return -1;
    }
    psptr->session_set_seekable(1);
    return 0;
  }
--- 193,328 ----
    }
  
    file = mpeg3_open(name);
!   video_streams = mpeg3_total_vstreams(file);
!   audio_streams = mpeg3_total_astreams(file);
! 
!   video_cnt = 0;
!   if (video_streams > 0) {
!     plugin = check_for_video_codec("MPEG FILE",
! 				   NULL,
! 				   -1,
! 				   -1,
! 				   NULL,
! 				   0);
!     if (plugin != NULL) video_cnt = video_streams;
    }
! 
!   for (ix = 0, audio_cnt = 0; ix < audio_streams; ix++) {
!     plugin = check_for_audio_codec("MPEG FILE",
! 				   NULL,
! 				   mpeg3_get_audio_format(file, ix),
! 				   -1,
! 				   NULL,
! 				   0);
!     if (plugin != NULL) audio_cnt++;
    }
+     
+   video_query_t *vq;
+   audio_query_t *aq;
+ 
+   if (video_cnt > 0) {
+     vq = (video_query_t *)malloc(sizeof(video_query_t) * video_cnt);
+   } else {
+     vq = NULL;
+   }
+   if (have_audio_driver && audio_cnt > 0) {
+     aq = (audio_query_t *)malloc(sizeof(audio_query_t) * audio_cnt);
+   } else {
+     aq = NULL;
+   }
+     
+   for (ix = 0; ix < video_cnt; ix++) {
+     vq[ix].track_id = ix;
+     vq[ix].compressor = "MPEG FILE";
+     vq[ix].type = mpeg3_video_layer(file, ix);
+     vq[ix].profile = -1;
+     vq[ix].fptr = NULL;
+     vq[ix].h = mpeg3_video_height(file, ix);
+     vq[ix].w = mpeg3_video_width(file, ix);
+     vq[ix].frame_rate = mpeg3_frame_rate(file, ix);
+     vq[ix].config = NULL;
+     vq[ix].config_len = 0;
+     vq[ix].enabled = 0;
+     vq[ix].reference = NULL;
+   }
+   audio_offset = 0;
+   if (have_audio_driver) {
+     for (ix = 0; ix < audio_streams; ix++) {
+       plugin = check_for_audio_codec("MPEG FILE",
+ 				     NULL,
+ 				     mpeg3_get_audio_format(file, ix),
+ 				     -1,
+ 				     NULL,
+ 				     0);
+       if (plugin != NULL) {
+ 	aq[audio_offset].track_id = ix;
+ 	aq[audio_offset].compressor = "MPEG FILE";
+ 	aq[audio_offset].type = mpeg3_get_audio_format(file, ix);
+ 	aq[audio_offset].profile = -1;
+ 	aq[audio_offset].fptr = NULL;
+ 	aq[audio_offset].config = NULL;
+ 	aq[audio_offset].config_len = 0;
+ 	aq[audio_offset].sampling_freq = mpeg3_sample_rate(file, ix);
+ 	aq[audio_offset].chans = mpeg3_audio_channels(file, ix);
+ 	aq[audio_offset].enabled = 0;
+ 	aq[audio_offset].reference = NULL;
+ 	audio_offset++;
+       } else {
+ 	mpeg3f_message(LOG_ERR, "Unsupported audio type %s in track %d", 
+ 		       mpeg3_audio_format(file, ix), ix);
+       }
+     }
+   }
+ 
+   if (cc_vft && cc_vft->media_list_query != NULL) {
+     (cc_vft->media_list_query)(psptr, video_cnt, vq, audio_offset, aq);
+   } else {
+     if (video_cnt > 0) vq[0].enabled = 1;
+     if (audio_offset > 0) aq[0].enabled = 1;
+   }
+ 
+   newfile = file;
+ 
+   ret = 0;
+   sdesc = 1;
+   for (ix = 0; ret >= 0 && ix < video_cnt; ix++) {
+     if (vq[ix].enabled) {
+       if (newfile == NULL) {
+ 	newfile = mpeg3_open_copy(name, file);
+       }
+       ret = create_mpeg3_video(&vq[ix], newfile, psptr, errmsg, errlen, sdesc);
+       if (ret <= 0) {
+ 	if (newfile != file) {
+ 	  mpeg3_close(file);
+ 	  newfile = NULL;
+ 	}
+       } else {
+ 	newfile = NULL;
+       }
+     }
+   }
+   if (ret >= 0) {
+     for (ix = 0; ix < audio_offset && ret >= 0; ix++) {
+       if (aq[ix].enabled) {
+ 	if (newfile == NULL) {
+ 	  newfile = mpeg3_open_copy(name, file);
+ 	}
+ 	ret = create_mpeg3_audio(&aq[ix], newfile, psptr, errmsg, errlen,sdesc);
+ 	if (ret <= 0) {
+ 	  if (newfile != file) {
+ 	    mpeg3_close(file);
+ 	    newfile = NULL;
+ 	  }
+ 	} else {
+ 	  newfile = NULL;
+ 	}
+       }
+     }
+   }
+ 
+   free(vq);
+   free(aq);
+   if (ret < 0) return ret;
    psptr->session_set_seekable(1);
    return 0;
  }
Index: player/src/mpeg3_file.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/mpeg3_file.h,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
*** player/src/mpeg3_file.h	2002/05/14 16:33:10	1.1
--- player/src/mpeg3_file.h	2002/07/26 17:59:48	1.2
***************
*** 33,38 ****
  				const char *name,
  				char *errmsg,
  				uint32_t errlen, 
! 				int have_audio_driver);
  
  #endif
--- 33,39 ----
  				const char *name,
  				char *errmsg,
  				uint32_t errlen, 
! 				int have_audio_driver,
! 				control_callback_vft_t *cc_vft);
  
  #endif
Index: player/src/our_bytestream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/our_bytestream.h,v
retrieving revision 1.28
retrieving revision 1.29
diff -c -w -r1.28 -r1.29
*** player/src/our_bytestream.h	2002/06/04 00:02:25	1.28
--- player/src/our_bytestream.h	2002/07/22 21:52:49	1.29
***************
*** 64,70 ****
     */
    virtual int skip_next_frame (uint64_t *ts, int *hasSyncFrame, uint8_t **buffer, uint32_t *buflen) { assert(0 == 1);return 0; };
    virtual double get_max_playtime (void) = 0;
!   virtual void set_start_time (uint64_t start) { m_play_start_time = start; };
   protected:
    uint64_t m_play_start_time;
    const char *m_name;
--- 64,71 ----
     */
    virtual int skip_next_frame (uint64_t *ts, int *hasSyncFrame, uint8_t **buffer, uint32_t *buflen) { assert(0 == 1);return 0; };
    virtual double get_max_playtime (void) = 0;
!   virtual void pause (void) {};
!   virtual void play (uint64_t start) { m_play_start_time = start; };
   protected:
    uint64_t m_play_start_time;
    const char *m_name;
Index: player/src/our_bytestream_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/our_bytestream_file.cpp,v
retrieving revision 1.35
retrieving revision 1.36
diff -c -w -r1.35 -r1.36
*** player/src/our_bytestream_file.cpp	2002/06/20 20:36:47	1.35
--- player/src/our_bytestream_file.cpp	2002/07/22 21:52:49	1.36
***************
*** 37,43 ****
  {
  }
  
! void COurInByteStreamFile::set_start_time (uint64_t start) 
  {
    if (m_plugin->c_raw_file_seek_to != NULL)
    m_plugin->c_raw_file_seek_to(m_plugin_data, start);
--- 37,43 ----
  {
  }
  
! void COurInByteStreamFile::play (uint64_t start) 
  {
    if (m_plugin->c_raw_file_seek_to != NULL)
    m_plugin->c_raw_file_seek_to(m_plugin_data, start);
Index: player/src/our_bytestream_file.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/our_bytestream_file.h,v
retrieving revision 1.23
retrieving revision 1.24
diff -c -w -r1.23 -r1.24
*** player/src/our_bytestream_file.h	2002/06/04 00:02:25	1.23
--- player/src/our_bytestream_file.h	2002/07/22 21:52:49	1.24
***************
*** 44,50 ****
  			    void **userdata);
    void used_bytes_for_frame(uint32_t bytes);
    double get_max_playtime (void) { return m_max_play_time; };
!   void set_start_time(uint64_t start);
   private:
    codec_plugin_t *m_plugin;
    codec_data_t *m_plugin_data;
--- 44,50 ----
  			    void **userdata);
    void used_bytes_for_frame(uint32_t bytes);
    double get_max_playtime (void) { return m_max_play_time; };
!   void play(uint64_t start);
   private:
    codec_plugin_t *m_plugin;
    codec_data_t *m_plugin_data;
Index: player/src/our_config_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/our_config_file.cpp,v
retrieving revision 1.16
retrieving revision 1.18
diff -c -w -r1.16 -r1.18
*** player/src/our_config_file.cpp	2002/07/05 22:03:53	1.16
--- player/src/our_config_file.cpp	2002/08/13 23:29:22	1.18
***************
*** 54,59 ****
--- 54,61 ----
    { CONFIG_PLAY_VIDEO, "PlayVideo", CONFIG_INT, 1, NULL },
    { CONFIG_RTP_BUFFER_TIME_MSEC, "RtpBufferTimeMsec", CONFIG_INT, 2000, NULL },
    { CONFIG_MPEG2T_PAM_WAIT_SECS, "Mpeg2tPamWaitSecs", CONFIG_INT, 30, NULL },
+   { CONFIG_LIMIT_AUDIO_SDL_BUFFER, "LimitAudioSdlBuffer", CONFIG_INT, 0, NULL},
+   { CONFIG_MPEG2T_DEBUG, "Mpeg2tDebug", CONFIG_INT, LOG_ALERT, NULL },
  };
  
  CConfig config(configs, CONFIG_MAX);
Index: player/src/our_config_file.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/our_config_file.h,v
retrieving revision 1.15
retrieving revision 1.17
diff -c -w -r1.15 -r1.17
*** player/src/our_config_file.h	2002/07/05 22:03:53	1.15
--- player/src/our_config_file.h	2002/08/13 23:29:22	1.17
***************
*** 46,52 ****
  #define CONFIG_PLAY_VIDEO 20
  #define CONFIG_RTP_BUFFER_TIME_MSEC 21
  #define CONFIG_MPEG2T_PAM_WAIT_SECS 22
! #define CONFIG_MAX 23
  
  extern CConfig config;
  
--- 46,54 ----
  #define CONFIG_PLAY_VIDEO 20
  #define CONFIG_RTP_BUFFER_TIME_MSEC 21
  #define CONFIG_MPEG2T_PAM_WAIT_SECS 22
! #define CONFIG_MPEG2T_DEBUG 23
! #define CONFIG_LIMIT_AUDIO_SDL_BUFFER 24
! #define CONFIG_MAX 25
  
  extern CConfig config;
  
Index: player/src/player_media.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/player_media.cpp,v
retrieving revision 1.109
retrieving revision 1.118
diff -c -w -r1.109 -r1.118
*** player/src/player_media.cpp	2002/07/09 22:21:24	1.109
--- player/src/player_media.cpp	2002/08/26 23:43:56	1.118
***************
*** 127,132 ****
--- 127,133 ----
    m_user_data = NULL;
    m_rtcp_received = 0;
    m_streaming = 0;
+   m_stream_ondemand = 0;
    m_rtp_use_rtsp = 0;
  }
  
***************
*** 152,158 ****
    }
  
    if (m_decode_thread) {
-     media_message(LOG_DEBUG, "decode thread %d", m_is_video);
      m_decode_msg_queue.send_message(MSG_STOP_THREAD, 
  				    NULL, 
  				    0, 
--- 153,158 ----
***************
*** 167,176 ****
    m_next = NULL;
    m_parent = NULL;
  
-   if (m_decode_thread_sem) {
-     SDL_DestroySemaphore(m_decode_thread_sem);
-     m_decode_thread_sem = NULL;
-   }
    if (m_ports) {
      delete m_ports;
      m_ports = NULL;
--- 167,172 ----
***************
*** 215,221 ****
--- 211,221 ----
      free((void *)m_user_data);
      m_user_data = NULL;
    }
+   if (m_decode_thread_sem) {
+     SDL_DestroySemaphore(m_decode_thread_sem);
+     m_decode_thread_sem = NULL;
    }
+ }
  
  void CPlayerMedia::clear_rtp_packets (void)
  {
***************
*** 256,269 ****
    return 0;
  }
  /*
!  * CPlayerMedia::create_from_file - create when we've already got a
   * bytestream
   */
! int CPlayerMedia::create_from_file (COurInByteStream *b, 
! 				    int is_video)
  {
    m_byte_stream = b;
!   return create_common(is_video, NULL, 0);
  }
  
  /*
--- 256,273 ----
    return 0;
  }
  /*
!  * CPlayerMedia::create - create when we've already got a
   * bytestream
   */
! int CPlayerMedia::create (COurInByteStream *b, 
! 			  int is_video,
! 			  char *errmsg,
! 			  uint32_t errlen,
! 			  int streaming)
  {
    m_byte_stream = b;
!   m_streaming = streaming;
!   return create_common(is_video, errmsg, errlen);
  }
  
  /*
***************
*** 429,434 ****
--- 433,441 ----
  }
  
  int CPlayerMedia::create_video_plugin (const codec_plugin_t *p,
+ 				       const char *compressor, 
+ 				       int type, 
+ 				       int profile, 
  				       format_list_t *sdp_media,
  				       video_info_t *video,
  				       const uint8_t *user_data,
***************
*** 441,447 ****
  
    m_plugin = p;
    m_video_info = video;
!   m_plugin_data = (p->vc_create)(sdp_media,
  				 video,
  				 user_data,
  				 userdata_size,
--- 448,456 ----
  
    m_plugin = p;
    m_video_info = video;
!   m_plugin_data = (p->vc_create)(compressor, 
! 				 type,
! 				 profile, sdp_media,
  				 video,
  				 user_data,
  				 userdata_size,
***************
*** 488,493 ****
--- 497,505 ----
  }
  
  int CPlayerMedia::create_audio_plugin (const codec_plugin_t *p,
+ 				       const char *compressor, 
+ 				       int type, 
+ 				       int profile,
  				       format_list_t *sdp_media,
  				       audio_info_t *audio,
  				       const uint8_t *user_data,
***************
*** 500,506 ****
  
    m_audio_info = audio;
    m_plugin = p;
!   m_plugin_data = (p->ac_create)(sdp_media,
  				 audio,
  				 user_data,
  				 userdata_size,
--- 512,521 ----
  
    m_audio_info = audio;
    m_plugin = p;
!   m_plugin_data = (p->ac_create)(compressor,
! 				 type, 
! 				 profile, 
! 				 sdp_media,
  				 audio,
  				 user_data,
  				 userdata_size,
***************
*** 572,588 ****
         * that it needs to start
         */
        m_play_start_time = start_time_offset;
-       if (m_rtp_byte_stream != NULL) {
- 	m_rtp_byte_stream->set_start_time((uint64_t)(start_time_offset * 1000.0));
        }
      }
      m_paused = 0;
      if (m_rtp_use_rtsp) {
        rtsp_thread_perform_callback(m_parent->get_rtsp_client(),
  				   c_rtp_start, 
  				   this);
-     } else {
-       m_rtp_msg_queue.send_message(MSG_START_SESSION);
      }
    } else {
      /*
--- 587,601 ----
         * that it needs to start
         */
        m_play_start_time = start_time_offset;
      }
+     if (m_byte_stream != NULL) {
+       m_byte_stream->play((uint64_t)(start_time_offset * 1000.0));
      }
      m_paused = 0;
      if (m_rtp_use_rtsp) {
        rtsp_thread_perform_callback(m_parent->get_rtsp_client(),
  				   c_rtp_start, 
  				   this);
      } 
    } else {
      /*
***************
*** 591,597 ****
      if (m_paused == 0 || start_time_offset == 0.0) {
        m_byte_stream->reset();
      }
!     m_byte_stream->set_start_time((uint64_t)(start_time_offset * 1000.0));
      m_play_start_time = start_time_offset;
      m_paused = 0;
      start_decoding();
--- 604,610 ----
      if (m_paused == 0 || start_time_offset == 0.0) {
        m_byte_stream->reset();
      }
!     m_byte_stream->play((uint64_t)(start_time_offset * 1000.0));
      m_play_start_time = start_time_offset;
      m_paused = 0;
      start_decoding();
***************
*** 623,632 ****
  	free_decode_response(decode);
        }
      }
      m_rtp_msg_queue.send_message(MSG_PAUSE_SESSION);
!     if (m_rtp_byte_stream) m_rtp_byte_stream->reset();
    }
    
    /*
     * Pause the various threads
     */
--- 636,648 ----
  	free_decode_response(decode);
        }
      }
+     if (m_recv_thread != NULL) {
        m_rtp_msg_queue.send_message(MSG_PAUSE_SESSION);
!     }
    }
  
+   if (m_byte_stream != NULL) 
+     m_byte_stream->pause();
    /*
     * Pause the various threads
     */
***************
*** 1211,1217 ****
    CMsg *newmsg;
    int recv_thread_stop = 0;
    connect_desc_t *cptr;
-   int receiving = 0;
    cptr = get_connect_desc_from_media(m_media_info);
  
  
--- 1227,1232 ----
***************
*** 1256,1304 ****
    if (m_rtp_session != NULL) {
      rtp_set_option(m_rtp_session, RTP_OPT_WEAK_VALIDATION, FALSE);
      rtp_set_option(m_rtp_session, RTP_OPT_PROMISC, TRUE);
    }
    m_rtp_inited = 1;
    
    while (recv_thread_stop == 0) {
-     /*
-      * See if we need to check for a state change - this will allow
-      * changes to the rtp info, if required.
-      */
-     while ((newmsg = m_rtp_msg_queue.get_message()) != NULL) {
-       switch (newmsg->get_value()) {
-       case MSG_STOP_THREAD:
- 	recv_thread_stop = 1;
- 	continue;
-       case MSG_START_SESSION:
- 	if (m_rtp_session == NULL) {
- 	  continue;
- 	}
- 	rtp_start();
- 	receiving = 1;
- 	break;
-       case MSG_PAUSE_SESSION:
- 	break;
-       }
-       delete newmsg;
-     }
-     if (receiving == 0) {
-       SDL_Delay(50);
-       continue;
-     }
-     while (receiving == 1 && recv_thread_stop == 0) {
        if ((newmsg = m_rtp_msg_queue.get_message()) != NULL) {
  	//player_debug_message("recv thread message %d", newmsg->get_value());
  	switch (newmsg->get_value()) {
  	case MSG_STOP_THREAD:
  	  recv_thread_stop = 1;
  	  break;
- 	case MSG_START_SESSION:
- 	  //media_message(LOG_ERR, "Got play when playing");
- 	  break;
  	case MSG_PAUSE_SESSION:
  	  // Indicate that we need to restart the session.
  	  // But keep going...
- 	  media_message(LOG_DEBUG, "calling rtp start from pause");
  	  rtp_start();
  	  break;
  	}
--- 1271,1290 ----
    if (m_rtp_session != NULL) {
      rtp_set_option(m_rtp_session, RTP_OPT_WEAK_VALIDATION, FALSE);
      rtp_set_option(m_rtp_session, RTP_OPT_PROMISC, TRUE);
+     rtp_start();
    }
    m_rtp_inited = 1;
    
    while (recv_thread_stop == 0) {
      if ((newmsg = m_rtp_msg_queue.get_message()) != NULL) {
        //player_debug_message("recv thread message %d", newmsg->get_value());
        switch (newmsg->get_value()) {
        case MSG_STOP_THREAD:
  	recv_thread_stop = 1;
  	break;
        case MSG_PAUSE_SESSION:
  	// Indicate that we need to restart the session.
  	// But keep going...
  	rtp_start();
  	break;
        }
***************
*** 1308,1313 ****
--- 1294,1302 ----
      if (recv_thread_stop == 1) {
        continue;
      }
+     if (m_rtp_session == NULL) {
+       SDL_Delay(50); 
+     } else {
        timeout.tv_sec = 0;
        timeout.tv_usec = 500000;
        retcode = rtp_recv(m_rtp_session, &timeout, 0);
***************
*** 1315,1322 ****
        // Run rtp periodic after each packet received or idle time.
        if (m_paused == 0)
  	rtp_periodic();
- 
      }
    }
    /*
     * When we're done, send a bye, close up rtp, and go home
--- 1304,1311 ----
        // Run rtp periodic after each packet received or idle time.
        if (m_paused == 0)
  	rtp_periodic();
      }
+     
    }
    /*
     * When we're done, send a bye, close up rtp, and go home
***************
*** 1401,1406 ****
--- 1390,1396 ----
  
    fmt = m_media_info->fmt;
    while (fmt != NULL) {
+     // rtp payloads are all numeric
      temp = atoi(fmt->fmt);
      if (temp == payload_type) {
        m_media_fmt = fmt;
***************
*** 1411,1418 ****
  	  media_message(LOG_ERR, "Media %s, rtp payload type of %u, no rtp map",
  			m_media_info->media, payload_type);
  	  return (FALSE);
! 	}
  	tickpersec = 90000;
        }
  
        bs = 
--- 1401,1421 ----
  	  media_message(LOG_ERR, "Media %s, rtp payload type of %u, no rtp map",
  			m_media_info->media, payload_type);
  	  return (FALSE);
! 	} else {
! 	  // generic payload type.  between 0 and 23 are audio - most
! 	  // are 8000
! 	  // all video (above 25) are 90000
  	  tickpersec = 90000;
+ 	  if (payload_type >= 0 && payload_type <= 23) {
+ 	    tickpersec = 8000;
+ 	    if (payload_type == 6) {
+ 	      tickpersec = 16000;
+ 	    } else if (payload_type == 10 || payload_type == 11) {
+ 	      tickpersec = 44100;
+ 	    } else if (payload_type == 14) 
+ 	      tickpersec = 90000;
+ 	  }
+ 	}
        }
  
        bs = 
***************
*** 1430,1436 ****
  					  m_rtcp_ntp_frac,
  					  m_rtcp_ntp_sec,
  					  m_rtcp_rtp_ts);
!       bs->set_start_time((uint64_t)(m_play_start_time * 1000.0));
        m_rtp_byte_stream = bs;
        m_byte_stream = m_rtp_byte_stream;
  #if 1
--- 1433,1439 ----
  					  m_rtcp_ntp_frac,
  					  m_rtcp_ntp_sec,
  					  m_rtcp_rtp_ts);
!       bs->play((uint64_t)(m_play_start_time * 1000.0));
        m_rtp_byte_stream = bs;
        m_byte_stream = m_rtp_byte_stream;
  #if 1
***************
*** 1443,1448 ****
--- 1446,1453 ----
      }
      fmt = fmt->next;
    }
+   media_message(LOG_ERR, "Payload type %d not in format list for media %s", 
+ 		payload_type, m_is_video ? "video" : "audio");
    return (FALSE);
  }
  
***************
*** 1470,1482 ****
  void CPlayerMedia::rtp_init_tcp (void) 
  {
    connect_desc_t *cptr;
    cptr = get_connect_desc_from_media(m_media_info);
    m_rtp_session = rtp_init_extern_net(m_source_addr == NULL ? 
  				      cptr->conn_addr : m_source_addr,
  				      m_our_port,
  				      m_server_port,
  				      cptr->ttl,
! 				      5000.0, // rtcp bandwidth ?
  				      c_recv_callback,
  				      c_rtcp_send_packet,
  				      (uint8_t *)this);
--- 1475,1492 ----
  void CPlayerMedia::rtp_init_tcp (void) 
  {
    connect_desc_t *cptr;
+   double bw;
+ 
+   if (find_rtcp_bandwidth_from_media(m_media_info, &bw) < 0) {
+     bw = 5000.0;
+   } 
    cptr = get_connect_desc_from_media(m_media_info);
    m_rtp_session = rtp_init_extern_net(m_source_addr == NULL ? 
  				      cptr->conn_addr : m_source_addr,
  				      m_our_port,
  				      m_server_port,
  				      cptr->ttl,
! 				      bw, // rtcp bandwidth ?
  				      c_recv_callback,
  				      c_rtcp_send_packet,
  				      (uint8_t *)this);
Index: player/src/player_media.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/player_media.h,v
retrieving revision 1.59
retrieving revision 1.61
diff -c -w -r1.59 -r1.61
*** player/src/player_media.h	2002/07/09 22:21:24	1.59
--- player/src/player_media.h	2002/08/19 18:29:47	1.61
***************
*** 53,59 ****
  		       int use_rtsp,
  		       int media_number_in_session);
    /* API routine - create - where we provide the bytestream */
!   int create_from_file (COurInByteStream *b, int is_video);
    /* API routine - play, pause */
    int do_play(double start_time_offset = 0.0);
    int do_pause(void);
--- 53,63 ----
  		       int use_rtsp,
  		       int media_number_in_session);
    /* API routine - create - where we provide the bytestream */
!   int create(COurInByteStream *b, 
! 	     int is_video, 
! 	     char *errmsg = NULL, 
! 	     uint32_t errlen = 0, 
! 	     int streaming = 0);
    /* API routine - play, pause */
    int do_play(double start_time_offset = 0.0);
    int do_pause(void);
***************
*** 95,105 ****
--- 99,115 ----
    const audio_info_t *get_audio_info (void) { return m_audio_info; };
  
    int create_video_plugin(const codec_plugin_t *p,
+ 			  const char *compressor, 
+ 			  int profile, 
+ 			  int type, 
  			  format_list_t *sdp_media,
  			  video_info_t *video,
  			  const uint8_t *user_data,
  			  uint32_t userdata_size);
    int create_audio_plugin(const codec_plugin_t *p,
+ 			  const char *compressor, 
+ 			  int profile, 
+ 			  int type, 
  			  format_list_t *sdp_media,
  			  audio_info_t *audio,
  			  const uint8_t *user_data,
Index: player/src/player_media_decode.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/player_media_decode.cpp,v
retrieving revision 1.83
retrieving revision 1.87
diff -c -w -r1.83 -r1.87
*** player/src/player_media_decode.cpp	2002/07/02 22:54:10	1.83
--- player/src/player_media_decode.cpp	2002/08/19 18:29:47	1.87
***************
*** 58,64 ****
--- 58,67 ----
  {
    m_decode_thread_waiting = 1;
  #ifdef DEBUG_DECODE
+   if (m_media_info)
      media_message(LOG_INFO, "decode thread %s waiting", m_media_info->media);
+   else
+     media_message(LOG_INFO, "decode thread waiting");
  #endif
    SDL_SemWait(m_decode_thread_sem);
    m_decode_thread_waiting = 0;
***************
*** 165,171 ****
  					   m_user_data,
  					   m_user_data_size);
  	  if (m_plugin != NULL) {
! 	    m_plugin_data = (m_plugin->vc_create)(m_media_fmt,
  						  m_video_info,
  						  m_user_data,
  						  m_user_data_size,
--- 168,177 ----
  					   m_user_data,
  					   m_user_data_size);
  	  if (m_plugin != NULL) {
! 	    m_plugin_data = (m_plugin->vc_create)(NULL, // must figure from sdp
! 						  -1,
! 						  -1,
! 						  m_media_fmt,
  						  m_video_info,
  						  m_user_data,
  						  m_user_data_size,
***************
*** 186,192 ****
  					   m_user_data,
  					   m_user_data_size);
  	  if (m_plugin != NULL) {
! 	    m_plugin_data = (m_plugin->ac_create)(m_media_fmt,
  						  m_audio_info,
  						  m_user_data,
  						  m_user_data_size,
--- 192,201 ----
  					   m_user_data,
  					   m_user_data_size);
  	  if (m_plugin != NULL) {
! 	    m_plugin_data = (m_plugin->ac_create)(NULL, 
! 						  -1,
! 						  -1,
! 						  m_media_fmt,
  						  m_audio_info,
  						  m_user_data,
  						  m_user_data_size,
***************
*** 257,263 ****
  	  (m_parent->get_session_state() == SESSION_PLAYING)) {
  	uint64_t current_time = m_parent->get_playing_time();
  	if (current_time >= ourtime) {
! #ifdef DEBUG_DECODE
  	  media_message(LOG_INFO, "Candidate for skip decode %llu our %llu", 
  			       current_time, ourtime);
  #endif
--- 266,272 ----
  	  (m_parent->get_session_state() == SESSION_PLAYING)) {
  	uint64_t current_time = m_parent->get_playing_time();
  	if (current_time >= ourtime) {
! #if 1
  	  media_message(LOG_INFO, "Candidate for skip decode %llu our %llu", 
  			       current_time, ourtime);
  #endif
Index: player/src/player_session.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/player_session.cpp,v
retrieving revision 1.71
retrieving revision 1.73
diff -c -w -r1.71 -r1.73
*** player/src/player_session.cpp	2002/07/05 22:03:53	1.71
--- player/src/player_session.cpp	2002/07/26 22:46:33	1.73
***************
*** 75,80 ****
--- 75,81 ----
    m_unused_ports = NULL;
    m_first_time_played = 0;
    m_latency = 0;
+   m_double_screen_width = 0;
  }
  
  CPlayerSession::~CPlayerSession ()
***************
*** 299,305 ****
--- 300,309 ----
  {
    if (m_video_sync == NULL) {
      m_video_sync = create_video_sync(this);
+     if (m_double_screen_width) {
+       m_video_sync->double_width();
      }
+   }
    return m_video_sync;
  }
  
***************
*** 528,533 ****
--- 532,547 ----
      send_sync_thread_a_message(MSG_SYNC_RESIZE_SCREEN);
    }
  }
+ 
+ void CPlayerSession::double_screen_width (void)
+ {
+   m_double_screen_width = 1;
+   if (m_video_sync) {
+     m_video_sync->double_width();
+     send_sync_thread_a_message(MSG_SYNC_RESIZE_SCREEN);
+   }
+ }
+ 
  double CPlayerSession::get_max_time (void)
  {
    CPlayerMedia *p;
***************
*** 597,603 ****
  {
    m_start -= time;
    m_clock_wrapped = -1;
! #if 0
    sync_message(LOG_INFO, "Adjusting start time "LLD " to " LLU, time,
  	       get_current_time());
  #endif
--- 611,617 ----
  {
    m_start -= time;
    m_clock_wrapped = -1;
! #if 1
    sync_message(LOG_INFO, "Adjusting start time "LLD " to " LLU, time,
  	       get_current_time());
  #endif
Index: player/src/player_session.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/player_session.h,v
retrieving revision 1.54
retrieving revision 1.56
diff -c -w -r1.54 -r1.56
*** player/src/player_session.h	2002/07/05 22:03:53	1.54
--- player/src/player_session.h	2002/07/26 22:46:33	1.56
***************
*** 117,122 ****
--- 117,123 ----
    int get_audio_volume(void) { return m_audio_volume; };
    void set_screen_location(int x, int y);
    void set_screen_size(int scaletimes2, int fullscreen = 0);
+   void double_screen_width(void);
    void session_set_seekable (int seekable) {
      m_seekable = seekable;
    };
***************
*** 219,224 ****
--- 220,226 ----
    CIpPort *m_unused_ports;
    int m_rtp_over_rtsp;
    uint64_t m_first_time_played;
+   int m_double_screen_width;
  };
  
  int c_sync_thread(void *data);
Index: player/src/qtime_bytestream.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/qtime_bytestream.cpp,v
retrieving revision 1.43
retrieving revision 1.44
diff -c -w -r1.43 -r1.44
*** player/src/qtime_bytestream.cpp	2002/06/05 18:46:35	1.43
--- player/src/qtime_bytestream.cpp	2002/07/22 21:52:49	1.44
***************
*** 210,216 ****
    m_byte_on = 0;
  }
  
! void CQTVideoByteStream::set_start_time (uint64_t start)
  {
    m_play_start_time = start;
    uint32_t ix;
--- 210,216 ----
    m_byte_on = 0;
  }
  
! void CQTVideoByteStream::play (uint64_t start)
  {
    m_play_start_time = start;
    uint32_t ix;
***************
*** 376,382 ****
    m_byte_on = 0;
  }
  
! void CQTAudioByteStream::set_start_time (uint64_t start)
  {
    m_play_start_time = start;
    
--- 376,382 ----
    m_byte_on = 0;
  }
  
! void CQTAudioByteStream::play (uint64_t start)
  {
    m_play_start_time = start;
    
Index: player/src/qtime_bytestream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/qtime_bytestream.h,v
retrieving revision 1.33
retrieving revision 1.34
diff -c -w -r1.33 -r1.34
*** player/src/qtime_bytestream.h	2002/06/04 00:02:25	1.33
--- player/src/qtime_bytestream.h	2002/07/22 21:52:49	1.34
***************
*** 81,87 ****
    int can_skip_frame(void) { return 1; };
    int skip_next_frame (uint64_t *ts, int *hasSync, uint8_t **buffer,
  		       uint32_t *buflen);
!   void set_start_time(uint64_t start);
    double get_max_playtime(void);
    void config(long num_frames, float frate, int time_scale);
   protected:
--- 81,87 ----
    int can_skip_frame(void) { return 1; };
    int skip_next_frame (uint64_t *ts, int *hasSync, uint8_t **buffer,
  		       uint32_t *buflen);
!   void play(uint64_t start);
    double get_max_playtime(void);
    void config(long num_frames, float frate, int time_scale);
   protected:
***************
*** 109,115 ****
    uint64_t start_next_frame(uint8_t **buffer,
  			    uint32_t *buflen,
  			    void **ud);
!   void set_start_time(uint64_t start);
    double get_max_playtime (void) {
      double ret = m_frames_max * m_samples_per_frame;
      ret /= m_frame_rate;
--- 109,115 ----
    uint64_t start_next_frame(uint8_t **buffer,
  			    uint32_t *buflen,
  			    void **ud);
!   void play(uint64_t start);
    double get_max_playtime (void) {
      double ret = m_frames_max * m_samples_per_frame;
      ret /= m_frame_rate;
Index: player/src/qtime_file.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/qtime_file.cpp,v
retrieving revision 1.39
retrieving revision 1.41
diff -c -w -r1.39 -r1.41
*** player/src/qtime_file.cpp	2002/07/05 22:03:53	1.39
--- player/src/qtime_file.cpp	2002/08/19 18:29:47	1.41
***************
*** 193,198 ****
--- 193,201 ----
       * Create plugin
       */
      ret = mptr->create_video_plugin(plugin, 
+ 				    codec_name, 
+ 				    -1,
+ 				    -1,
  				    NULL,
  				    vinfo,
  				    (uint8_t *)foo,
***************
*** 212,218 ****
  		  quicktime_video_time_scale(m_qtfile, ix));
      player_debug_message("Video Max time is %g", vbyte->get_max_playtime());
  
!     ret = mptr->create_from_file(vbyte, TRUE);
      if (ret != 0) {
        return (-1);
      }
--- 215,221 ----
  		  quicktime_video_time_scale(m_qtfile, ix));
      player_debug_message("Video Max time is %g", vbyte->get_max_playtime());
  
!     ret = mptr->create(vbyte, TRUE);
      if (ret != 0) {
        return (-1);
      }
***************
*** 279,284 ****
--- 282,290 ----
      audio->freq = sample_rate;
  
      int ret = mptr->create_audio_plugin(plugin,
+ 					codec, 
+ 					-1, 
+ 					-1,
  					NULL, // SDP info
  					audio,
  					ud,
***************
*** 292,298 ****
      abyte->config(len, sample_rate, samples_per_frame);
      player_debug_message("audio Max time is %g len %ld", 
  			 abyte->get_max_playtime(), len);
!     ret = mptr->create_from_file(abyte, FALSE);
      if (ret != 0) {
        return (-1);
      }
--- 298,304 ----
      abyte->config(len, sample_rate, samples_per_frame);
      player_debug_message("audio Max time is %g len %ld", 
  			 abyte->get_max_playtime(), len);
!     ret = mptr->create(abyte, FALSE);
      if (ret != 0) {
        return (-1);
      }
Index: player/src/rtp_bytestream.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/rtp_bytestream.cpp,v
retrieving revision 1.53
retrieving revision 1.61
diff -c -w -r1.53 -r1.61
*** player/src/rtp_bytestream.cpp	2002/07/02 22:54:10	1.53
--- player/src/rtp_bytestream.cpp	2002/08/26 23:43:56	1.61
***************
*** 219,224 ****
--- 219,241 ----
  void CRtpByteStreamBase::set_wallclock_offset (uint64_t wclock, 
  					       uint32_t rtp_ts) 
  {
+   if (m_wallclock_offset_set == 1 &&
+       m_stream_ondemand == 0) {
+     int32_t rtp_ts_diff;
+     uint64_t wclock_diff;
+     uint64_t wclock_calc;
+     wclock_diff = wclock - m_wallclock_offset;
+     rtp_ts_diff = rtp_ts - m_wallclock_rtp_ts;
+     wclock_calc = rtp_ts_diff * M_LLU;
+     wclock_calc /= m_rtptime_tickpersec;
+     wclock_calc += m_wallclock_offset;
+     if (wclock_calc != wclock) {
+       rtp_message(LOG_DEBUG, 
+ 		  "%s - set wallclock - wclock should be "LLU" is "LLU, 
+ 		m_name, wclock_calc, wclock);
+     }
+     
+   }
    m_wallclock_offset_set = 1;
    SDL_LockMutex(m_rtp_packet_mutex);
    m_wallclock_offset = wclock;
***************
*** 335,340 ****
--- 352,361 ----
    m_buffering = 0;
  }
  
+ void CRtpByteStreamBase::pause(void)
+ {
+   reset();
+ }
  /*
   * recv_task - called from the player media rtp task - make sure
   * we have 2 seconds of buffering, then go...
***************
*** 395,402 ****
  	    if (m_rtp_base_seq_set != 0 &&
  		m_rtp_base_seq == m_head->rtp_pak_seq &&
  		m_rtp_base_ts != m_head->rtp_pak_ts) {
! 	      rtp_message(LOG_NOTICE, "%s - rtp ts doesn't match RTPInfo %d", 
! 			  m_name, m_head->rtp_pak_ts);
  	      m_rtp_base_ts = m_head->rtp_pak_ts;
  	    }
  	    //
--- 416,423 ----
  	    if (m_rtp_base_seq_set != 0 &&
  		m_rtp_base_seq == m_head->rtp_pak_seq &&
  		m_rtp_base_ts != m_head->rtp_pak_ts) {
! 	      rtp_message(LOG_NOTICE, "%s - rtp ts doesn't match RTPInfo %d seq %d", 
! 			  m_name, m_head->rtp_pak_ts, m_head->rtp_pak_seq);
  	      m_rtp_base_ts = m_head->rtp_pak_ts;
  	    }
  	    //
***************
*** 431,440 ****
        } else {
  	uint64_t timeout;
  	timeout = get_time_of_day() - m_recvd_pak_timeout_time;
! 	if (m_stream_ondemand) {
  	  uint64_t range_end = (uint64_t)(get_max_playtime() * 1000.0);
  	  if (m_last_realtime + timeout >= range_end) {
! 	    rtp_message(LOG_DEBUG, "%s Timedout at range end", m_name);
  	    m_eof = 1;
  	  }
  	} else {
--- 452,463 ----
        } else {
  	uint64_t timeout;
  	timeout = get_time_of_day() - m_recvd_pak_timeout_time;
! 	if (m_stream_ondemand && get_max_playtime() != 0.0) {
  	  uint64_t range_end = (uint64_t)(get_max_playtime() * 1000.0);
  	  if (m_last_realtime + timeout >= range_end) {
! 	    rtp_message(LOG_DEBUG, 
! 			"%s Timedout at range end - last "LLU" range end "LLU, 
! 			m_name, m_last_realtime, range_end);
  	    m_eof = 1;
  	  }
  	} else {
***************
*** 591,596 ****
--- 614,627 ----
  #ifdef DEBUG_RTP_PAKS
      rtp_message(LOG_DEBUG, "%s Still left - %d bytes", m_name, *buflen);
  #endif
+ #if 0
+   rtp_message(LOG_DEBUG, "%s start %02x %02x %02x %02x %02x", m_name,
+ 		  	(*buffer)[0],
+ 		  	(*buffer)[1],
+ 		  	(*buffer)[2],
+ 		  	(*buffer)[3],
+ 		  	(*buffer)[4]);
+ #endif
      return (m_last_realtime);
    } else {
      m_buffer_len = 0;
***************
*** 638,643 ****
--- 669,682 ----
      m_bytes_used = 0;
      *buffer = m_buffer + m_bytes_used;
      *buflen = m_buffer_len - m_bytes_used;
+ #if 0
+   rtp_message(LOG_DEBUG, "%s start %02x %02x %02x %02x %02x", m_name,
+ 		  	(*buffer)[0],
+ 		  	(*buffer)[1],
+ 		  	(*buffer)[2],
+ 		  	(*buffer)[3],
+ 		  	(*buffer)[4]);
+ #endif
  #ifdef DEBUG_RTP_PAKS
      rtp_message(LOG_DEBUG, "%s buffer len %d", m_name, m_buffer_len);
  #endif
***************
*** 763,769 ****
    } else diff = 0;
  
    m_doing_add = 0;
!   if (diff > 2) {
      // Still bytes in the buffer...
      *buffer = (uint8_t *)m_working_pak->rtp_data + m_bytes_used;
      *buflen = diff;
--- 802,808 ----
    } else diff = 0;
  
    m_doing_add = 0;
!   if (diff > 0) {
      // Still bytes in the buffer...
      *buffer = (uint8_t *)m_working_pak->rtp_data + m_bytes_used;
      *buflen = diff;
***************
*** 775,783 ****
    } else {
      if (m_working_pak) xfree(m_working_pak);
      m_buffer_len = 0;
      m_working_pak = m_head;
      remove_packet_rtp_queue(m_working_pak, 0);
!     *buffer = (uint8_t *)m_working_pak->rtp_data;
      *buflen = m_working_pak->rtp_data_len;
      ts = m_working_pak->rtp_pak_ts;
  #ifdef DEBUG_RTP_PAKS
--- 814,823 ----
    } else {
      if (m_working_pak) xfree(m_working_pak);
      m_buffer_len = 0;
+     m_bytes_used = m_skip_on_advance_bytes;
      m_working_pak = m_head;
      remove_packet_rtp_queue(m_working_pak, 0);
!     *buffer = (uint8_t *)m_working_pak->rtp_data + m_bytes_used;
      *buflen = m_working_pak->rtp_data_len;
      ts = m_working_pak->rtp_pak_ts;
  #ifdef DEBUG_RTP_PAKS
Index: player/src/rtp_bytestream.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/rtp_bytestream.h,v
retrieving revision 1.28
retrieving revision 1.30
diff -c -w -r1.28 -r1.30
*** player/src/rtp_bytestream.h	2002/07/02 21:02:13	1.28
--- player/src/rtp_bytestream.h	2002/08/26 22:27:57	1.30
***************
*** 79,84 ****
--- 79,85 ----
      m_rtp_base_seq_set = 1;
      m_rtp_base_seq = s;
    };
+   int can_skip_frame (void) { return 1; } ;
    void set_wallclock_offset (uint64_t wclock, uint32_t rtp_ts);
    int rtp_ready (void) {
      return (m_stream_ondemand | m_wallclock_offset_set);
***************
*** 88,93 ****
--- 89,95 ----
    int recv_task(int waiting);
    uint32_t get_last_rtp_timestamp (void) {return m_rtptime_last; };
    void remove_packet_rtp_queue(rtp_packet *pak, int free);
+   void pause(void);
   protected:
    void init(void);
    // Make sure all classes call this to calculate real time.
***************
*** 150,156 ****
    ~CRtpByteStream();
    uint64_t start_next_frame(uint8_t **buffer, uint32_t *buflen,
  			    void **userdata);
-   int can_skip_frame (void) { return 1; } ;
    int skip_next_frame(uint64_t *ts, int *havesync, uint8_t **buffer,
  		      uint32_t *buflen);
    void used_bytes_for_frame(uint32_t bytes);
--- 152,157 ----
Index: player/src/sync.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/sync.cpp,v
retrieving revision 1.90
retrieving revision 1.91
diff -c -w -r1.90 -r1.91
*** player/src/sync.cpp	2002/07/02 21:02:13	1.90
--- player/src/sync.cpp	2002/07/25 21:07:01	1.91
***************
*** 207,218 ****
    CMsg *newmsg;
  
    newmsg = m_sync_thread_msg_queue.get_message();
!   if (newmsg && newmsg->get_value() == MSG_STOP_THREAD) {
      return (SYNC_STATE_EXIT);
    }
!   if (newmsg && newmsg->get_value() == MSG_PAUSE_SESSION) {
      m_sync_pause_done = 1;
    }
    SDL_Delay(100);
  	
    return (SYNC_STATE_INIT);
--- 207,224 ----
    CMsg *newmsg;
  
    newmsg = m_sync_thread_msg_queue.get_message();
!   if (newmsg != NULL) {
!     int value = newmsg->get_value();
!     delete newmsg;
! 
!     if (value == MSG_STOP_THREAD) {
        return (SYNC_STATE_EXIT);
      }
!     if (value == MSG_PAUSE_SESSION) {
        m_sync_pause_done = 1;
      }
+   }
+ 
    SDL_Delay(100);
  	
    return (SYNC_STATE_INIT);
Index: player/src/video.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/video.cpp,v
retrieving revision 1.74
retrieving revision 1.75
diff -c -w -r1.74 -r1.75
*** player/src/video.cpp	2002/05/28 21:22:53	1.74
--- player/src/video.cpp	2002/07/26 22:46:33	1.75
***************
*** 112,116 ****
--- 112,119 ----
  {
  }
  
+ void CVideoSync::double_width(void)
+ {
+ }
  /* end file video.cpp */
  
Index: player/src/video.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/video.h,v
retrieving revision 1.37
retrieving revision 1.38
diff -c -w -r1.37 -r1.38
*** player/src/video.h	2002/06/03 18:34:38	1.37
--- player/src/video.h	2002/07/26 22:46:33	1.38
***************
*** 54,59 ****
--- 54,60 ----
  			 int &have_eof);
    virtual void do_video_resize(void);     // from sync
    virtual void flush_sync_buffers(void);  // from sync task in response to stop
+   virtual void double_width(void);
   protected:
    CPlayerSession *m_psptr;
    SDL_sem *m_decode_sem;
Index: player/src/video_dummy.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/video_dummy.cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** player/src/video_dummy.cpp	2002/06/04 00:02:25	1.2
--- player/src/video_dummy.cpp	2002/07/26 22:46:33	1.3
***************
*** 91,96 ****
--- 91,100 ----
    return (1);
  }
  
+ void CDummyVideoSync::double_width (void)
+ {
+ }
+ 
  static void c_video_configure (void *ifptr,
  			      int w,
  			      int h,
Index: player/src/video_dummy.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/video_dummy.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** player/src/video_dummy.h	2002/06/04 00:02:25	1.2
--- player/src/video_dummy.h	2002/07/26 22:46:33	1.3
***************
*** 51,56 ****
--- 51,57 ----
  		      int m_pixelw_uv,
  		      uint64_t time);
    void config (int w, int h); // from codec
+   void double_width(void);
   protected:
    int m_width;
    int m_height;
Index: player/src/video_sdl.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/video_sdl.cpp,v
retrieving revision 1.3
retrieving revision 1.5
diff -c -w -r1.3 -r1.5
*** player/src/video_sdl.cpp	2002/06/05 18:46:35	1.3
--- player/src/video_sdl.cpp	2002/07/26 22:46:33	1.5
***************
*** 76,81 ****
--- 76,82 ----
    m_consec_skipped = 0;
    m_fullscreen = 0;
    m_filled_frames = 0;
+   m_double_width = 0;
  }
  
  CSDLVideoSync::~CSDLVideoSync (void)
***************
*** 166,171 ****
--- 167,173 ----
  #endif
        }
        int w = m_width * video_scale / 2;
+       if (m_double_width) w *= 2;
        int h = m_height * video_scale / 2;
        m_screen = SDL_SetVideoMode(w,
  				  h,
***************
*** 398,404 ****
    } 
  #ifdef CHECK_SYNC_TIME
  else {
! #if 0
      video_message(LOG_DEBUG, "Video lagging current time "LLU" "LLU" "LLU, 
  			 play_this_at, current_time, m_msec_per_frame);
  #endif
--- 400,406 ----
    } 
  #ifdef CHECK_SYNC_TIME
  else {
! #ifdef VIDEO_SYNC_PLAY
      video_message(LOG_DEBUG, "Video lagging current time "LLU" "LLU" "LLU, 
  			 play_this_at, current_time, m_msec_per_frame);
  #endif
***************
*** 644,649 ****
--- 646,652 ----
    }
  
    int w = m_width * video_scale / 2;
+   if (m_double_width) w *= 2;
    int h = m_height * video_scale / 2;
      
    video_message(LOG_DEBUG, "Setting video mode %d %d %x", 
***************
*** 677,682 ****
--- 680,690 ----
  				 SDL_YV12_OVERLAY, 
  				 m_screen);
    }
+ }
+ 
+ void CSDLVideoSync::double_width (void)
+ {
+   m_double_width = 1;
  }
  
  static void c_video_configure (void *ifptr,
Index: player/src/video_sdl.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/video_sdl.h,v
retrieving revision 1.4
retrieving revision 1.5
diff -c -w -r1.4 -r1.5
*** player/src/video_sdl.h	2002/06/05 18:46:36	1.4
--- player/src/video_sdl.h	2002/07/26 22:46:33	1.5
***************
*** 56,61 ****
--- 56,62 ----
    void set_fullscreen(int fullscreen);
    int get_fullscreen (void) { return m_fullscreen; };
    void do_video_resize(void); // from sync
+   void double_width(void);
   private:
    int m_video_bpp;
    int m_video_scale;
***************
*** 64,69 ****
--- 65,71 ----
    int m_video_initialized;
    int m_config_set;
    int m_paused;
+   int m_double_width;
    volatile int m_have_data;
    SDL_Surface *m_screen;
    SDL_Overlay *m_image;
Index: player/src/codec/aa/aac.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec/aa/aac.cpp,v
retrieving revision 1.13
retrieving revision 1.14
diff -c -w -r1.13 -r1.14
*** player/src/codec/aa/aac.cpp	2002/07/09 22:21:24	1.13
--- player/src/codec/aa/aac.cpp	2002/08/19 18:29:47	1.14
***************
*** 30,36 ****
  /*
   * Create CAACodec class
   */
! static codec_data_t *aac_codec_create (format_list_t *media_fmt,
  				       audio_info_t *audio,
  				       const uint8_t *userdata,
  				       uint32_t userdata_size,
--- 30,39 ----
  /*
   * Create CAACodec class
   */
! static codec_data_t *aac_codec_create (const char *compressor, 
! 				       int type, 
! 				       int profile, 
! 				       format_list_t *media_fmt,
  				       audio_info_t *audio,
  				       const uint8_t *userdata,
  				       uint32_t userdata_size,
Index: player/src/codec/mp3/mp3if.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec/mp3/mp3if.cpp,v
retrieving revision 1.18
retrieving revision 1.21
diff -c -w -r1.18 -r1.21
*** player/src/codec/mp3/mp3if.cpp	2002/07/09 22:21:24	1.18
--- player/src/codec/mp3/mp3if.cpp	2002/08/19 18:29:47	1.21
***************
*** 21,26 ****
--- 21,27 ----
  #include "mp3if.h"
  #include <mp4av/mp4av.h>
  #include <mp4v2/mp4.h>
+ #include <mpeg2t/mpeg2_transport.h>
  
  #define mp3_message mp3->m_vft->log_msg
  #define DEBUG_SYNC 1
***************
*** 28,34 ****
  /*
   * Create CMP3Codec class
   */
! static codec_data_t *mp3_codec_create (format_list_t *media_fmt,
  				       audio_info_t *audio,
  				       const uint8_t *userdata,
  				       uint32_t userdata_size,
--- 29,38 ----
  /*
   * Create CMP3Codec class
   */
! static codec_data_t *mp3_codec_create (const char *compressor, 
! 				       int type, 
! 				       int profile, 
! 				       format_list_t *media_fmt,
  				       audio_info_t *audio,
  				       const uint8_t *userdata,
  				       uint32_t userdata_size,
***************
*** 231,236 ****
--- 235,245 ----
      }
      if ((strcasecmp(compressor, "MPEG FILE") == 0) &&
  	(audio_type == 1)) { // AUDIO_MPEG def from libmpeg3
+       return 1;
+     }
+     if ((strcasecmp(compressor, "MPEG2 TRANSPORT") == 0) &&
+ 	((audio_type == MPEG2T_ST_MPEG_AUDIO) ||
+ 	 (audio_type == MPEG2T_ST_11172_AUDIO))) {
        return 1;
      }
    }
Index: player/src/codec/mpeg4/mpeg4.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec/mpeg4/mpeg4.cpp,v
retrieving revision 1.66
retrieving revision 1.69
diff -c -w -r1.66 -r1.69
*** player/src/codec/mpeg4/mpeg4.cpp	2002/07/09 22:21:24	1.66
--- player/src/codec/mpeg4/mpeg4.cpp	2002/09/10 22:42:18	1.69
***************
*** 141,147 ****
    return havevol;
  }
  
! static codec_data_t *iso_create (format_list_t *media_fmt,
  				 video_info_t *vinfo,
  				 const uint8_t *userdata,
  				 uint32_t ud_size,
--- 141,150 ----
    return havevol;
  }
  
! static codec_data_t *iso_create (const char *compressor, 
! 				 int type, 
! 				 int profile, 
! 				 format_list_t *media_fmt,
  				 video_info_t *vinfo,
  				 const uint8_t *userdata,
  				 uint32_t ud_size,
***************
*** 270,275 ****
--- 273,302 ----
    switch (iso->m_decodeState) {
    case DECODE_STATE_VOL_SEARCH: {
      uint32_t used = 0;
+     if (buffer[0] == 0 &&
+ 	buffer[1] == 0 &&
+ 	(buffer[2] & 0xfc) == 0x80 &&
+ 	(buffer[3] & 0x03) == 0x02) {
+       // we have the short header
+       iso->m_short_header = 1;
+       iso->m_pvodec->SetUpBitstreamBuffer((unsigned char *)buffer, buflen);
+       iso->m_pvodec->video_plane_with_short_header();
+       iso->m_pvodec->postVO_VOLHeadInit(iso->m_pvodec->getWidth(),
+ 					iso->m_pvodec->getHeight(),
+ 					&iso->m_bSpatialScalability);
+       iso_message(LOG_INFO, mp4iso, "Decoding using short headers");
+       iso->m_vft->video_configure(iso->m_ifptr, 
+ 				  iso->m_pvodec->getWidth(),
+ 				  iso->m_pvodec->getHeight(),
+ 				  VIDEO_FORMAT_YUV);
+       iso->m_decodeState = DECODE_STATE_NORMAL;
+       try {
+ 	iEof = iso->m_pvodec->h263_decode();
+       } catch (...) {
+ 	iso_message(LOG_ERR, mp4iso, "Couldn't decode h263 in vol search");
+       }
+       break; 
+     }
      while (used < buflen && iso->m_decodeState == DECODE_STATE_VOL_SEARCH) {
        try {
  	iso->m_pvodec->SetUpBitstreamBuffer((unsigned char *)buffer + used, buflen - used);
***************
*** 333,339 ****
--- 360,370 ----
      break;
    case DECODE_STATE_NORMAL:
      try {
+       if (iso->m_short_header != 0) {
+ 	iEof = iso->m_pvodec->h263_decode();
+       } else {
  	iEof = iso->m_pvodec->decode(NULL, FALSE, FALSE);
+       }
      } catch (int err) {
        // This is because sometimes, the encoder doesn't read all the bytes
        // it should out of the rtp packet.  The rtp bytestream does a read
***************
*** 472,478 ****
  {
    if (compressor != NULL && 
        (strcasecmp(compressor, "MP4 FILE") == 0)) {
!     if (type == MP4_MPEG4_VIDEO_TYPE) {
        return 1;
      }
      return -1;
--- 503,509 ----
  {
    if (compressor != NULL && 
        (strcasecmp(compressor, "MP4 FILE") == 0)) {
!     if (type == MP4_MPEG4_VIDEO_TYPE || type == MP4_H263_VIDEO_TYPE) {
        return 1;
      }
      return -1;
Index: player/src/codec/mpeg4/mpeg4.h
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec/mpeg4/mpeg4.h,v
retrieving revision 1.28
retrieving revision 1.29
diff -c -w -r1.28 -r1.29
*** player/src/codec/mpeg4/mpeg4.h	2002/06/04 00:02:25	1.28
--- player/src/codec/mpeg4/mpeg4.h	2002/09/10 22:42:18	1.29
***************
*** 64,69 ****
--- 64,70 ----
    CFilePosRecorder *m_fpos;
    int m_framerate;
    video_info_t *m_vinfo;
+   int m_short_header;
  } iso_decode_t;
  
  void iso_clean_up(iso_decode_t *iso);
Index: player/src/codec/wav/ourwav.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/player/src/codec/wav/ourwav.cpp,v
retrieving revision 1.19
retrieving revision 1.20
diff -c -w -r1.19 -r1.20
*** player/src/codec/wav/ourwav.cpp	2002/07/09 22:21:24	1.19
--- player/src/codec/wav/ourwav.cpp	2002/08/19 18:29:47	1.20
***************
*** 24,30 ****
  /*
   * Create CAACodec class
   */
! static codec_data_t *wav_codec_create (format_list_t *media_fmt,
  				       audio_info_t *audio,
  				       const uint8_t *userdata,
  				       uint32_t userdata_size,
--- 24,33 ----
  /*
   * Create CAACodec class
   */
! static codec_data_t *wav_codec_create (const char *compressor, 
! 				       int type, 
! 				       int profile, 
! 				       format_list_t *media_fmt,
  				       audio_info_t *audio,
  				       const uint8_t *userdata,
  				       uint32_t userdata_size,
Index: server/audio/lame/Makefile
===================================================================
RCS file: /vws/pan/mpeg4ip/server/audio/lame/Makefile,v
retrieving revision 1.9
retrieving revision 1.10
diff -c -w -r1.9 -r1.10
*** server/audio/lame/Makefile	2002/06/21 17:59:10	1.9
--- server/audio/lame/Makefile	2002/08/14 01:04:58	1.10
***************
*** 73,80 ****
  ##########################################################################
  ifeq ($(UNAME),Linux)
  #  remove these lines if you dont have GTK, or dont want the GTK frame analyzer
!    GTK = -DHAVEGTK `gtk-config --cflags`
!    GTKLIBS = `gtk-config --libs` 
  # Comment out next 2 lines if you want to remove VBR histogram capability
  #   BRHIST_SWITCH = -DBRHIST
  #   LIBTERMCAP = -lncurses
--- 73,80 ----
  ##########################################################################
  ifeq ($(UNAME),Linux)
  #  remove these lines if you dont have GTK, or dont want the GTK frame analyzer
! #   GTK = -DHAVEGTK `gtk-config --cflags`
! #   GTKLIBS = `gtk-config --libs` 
  # Comment out next 2 lines if you want to remove VBR histogram capability
  #   BRHIST_SWITCH = -DBRHIST
  #   LIBTERMCAP = -lncurses
***************
*** 139,146 ****
  ##########################################################################
  ifeq ($(UNAME),FreeBSD)
  #  remove if you do not have GTK or do not want the GTK frame analyzer
!    GTK = -DHAVEGTK `gtk12-config --cflags`
!    GTKLIBS = `gtk12-config --libs` 
  # Comment out next 2 lines if you want to remove VBR histogram capability
     BRHIST_SWITCH = -DBRHIST
     LIBTERMCAP = -lncurses
--- 139,146 ----
  ##########################################################################
  ifeq ($(UNAME),FreeBSD)
  #  remove if you do not have GTK or do not want the GTK frame analyzer
! #   GTK = -DHAVEGTK `gtk12-config --cflags`
! #   GTKLIBS = `gtk12-config --libs` 
  # Comment out next 2 lines if you want to remove VBR histogram capability
     BRHIST_SWITCH = -DBRHIST
     LIBTERMCAP = -lncurses
Index: server/mp4creator/aac.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4creator/aac.cpp,v
retrieving revision 1.9
retrieving revision 1.10
diff -c -w -r1.9 -r1.10
*** server/mp4creator/aac.cpp	2002/07/01 20:06:37	1.9
--- server/mp4creator/aac.cpp	2002/08/02 17:50:01	1.10
***************
*** 186,192 ****
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid audio\n",
  			 ProgName);
! 		exit(EXIT_AAC_CREATOR);
  	}
  
  	samplesPerSecond = MP4AV_AdtsGetSamplingRate(firstHeader);
--- 186,192 ----
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid audio\n",
  			 ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	samplesPerSecond = MP4AV_AdtsGetSamplingRate(firstHeader);
***************
*** 214,220 ****
  			fprintf(stderr,	
  				"%s: data in file doesn't appear to be valid audio\n",
  				 ProgName);
! 			exit(EXIT_AAC_CREATOR);
  		default:
  			ASSERT(false);
  		}
--- 214,220 ----
  			fprintf(stderr,	
  				"%s: data in file doesn't appear to be valid audio\n",
  				 ProgName);
! 			return MP4_INVALID_TRACK_ID;
  		default:
  			ASSERT(false);
  		}
***************
*** 231,237 ****
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create audio track\n", ProgName);
! 		exit(EXIT_AAC_CREATOR);
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_AUDIO_TRACK_TYPE) == 1) {
--- 231,237 ----
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create audio track\n", ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_AUDIO_TRACK_TYPE) == 1) {
***************
*** 252,258 ****
  	  pConfig, configLength)) {
  		fprintf(stderr,	
  			"%s: can't write audio configuration\n", ProgName);
! 		exit(EXIT_AAC_CREATOR);
  	}
  
  	// parse the ADTS frames, and write the MP4 samples
--- 252,259 ----
  	  pConfig, configLength)) {
  		fprintf(stderr,	
  			"%s: can't write audio configuration\n", ProgName);
! 		MP4DeleteTrack(mp4File, trackId);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	// parse the ADTS frames, and write the MP4 samples
***************
*** 264,270 ****
  		if (!MP4WriteSample(mp4File, trackId, sampleBuffer, sampleSize)) {
  			fprintf(stderr,	
  				"%s: can't write audio frame %u\n", ProgName, sampleId);
! 			exit(EXIT_AAC_CREATOR);
  		}
  		sampleId++;
  		sampleSize = sizeof(sampleBuffer);
--- 265,272 ----
  		if (!MP4WriteSample(mp4File, trackId, sampleBuffer, sampleSize)) {
  			fprintf(stderr,	
  				"%s: can't write audio frame %u\n", ProgName, sampleId);
! 			MP4DeleteTrack(mp4File, trackId);
! 			return MP4_INVALID_TRACK_ID;
  		}
  		sampleId++;
  		sampleSize = sizeof(sampleBuffer);
Index: server/mp4creator/avi.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4creator/avi.cpp,v
retrieving revision 1.12
retrieving revision 1.14
diff -c -w -r1.12 -r1.14
*** server/mp4creator/avi.cpp	2002/07/02 22:44:15	1.12
--- server/mp4creator/avi.cpp	2002/08/02 17:50:01	1.14
***************
*** 37,43 ****
  		fprintf(stderr,	
  			"%s: video compressor %s not recognized\n",
  			 ProgName, videoType);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	double frameRate = AVI_video_frame_rate(aviFile);
--- 37,43 ----
  		fprintf(stderr,	
  			"%s: video compressor %s not recognized\n",
  			 ProgName, videoType);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	double frameRate = AVI_video_frame_rate(aviFile);
***************
*** 45,51 ****
  	if (frameRate == 0) {
  		fprintf(stderr,	
  			"%s: no video frame rate in avi file\n", ProgName);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  #ifdef _WIN32
--- 45,51 ----
  	if (frameRate == 0) {
  		fprintf(stderr,	
  			"%s: no video frame rate in avi file\n", ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  #ifdef _WIN32
***************
*** 57,71 ****
  		(MP4Duration)(Mp4TimeScale / frameRate);
  #endif
  
! 	MP4TrackId trackId = MP4AddVideoTrack(mp4File,
! 		Mp4TimeScale, mp4FrameDuration, 
! 		AVI_video_width(aviFile), AVI_video_height(aviFile), 
  		MP4_MPEG4_VIDEO_TYPE);
  
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create video track\n", ProgName);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	int32_t i;
--- 57,74 ----
  		(MP4Duration)(Mp4TimeScale / frameRate);
  #endif
  
! 	MP4TrackId trackId = MP4AddVideoTrack(
! 		mp4File,
! 		Mp4TimeScale, 
! 		mp4FrameDuration, 
! 		AVI_video_width(aviFile), 
! 		AVI_video_height(aviFile), 
  		MP4_MPEG4_VIDEO_TYPE);
  
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create video track\n", ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	int32_t i;
***************
*** 89,95 ****
  	if (pFrameBuffer == NULL) {
  		fprintf(stderr,	
  			"%s: can't allocate memory\n", ProgName);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	AVI_seek_start(aviFile);
--- 92,99 ----
  	if (pFrameBuffer == NULL) {
  		fprintf(stderr,	
  			"%s: can't allocate memory\n", ProgName);
! 		MP4DeleteTrack(mp4File, trackId);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	AVI_seek_start(aviFile);
***************
*** 101,113 ****
  		fprintf(stderr,	
  			"%s: can't read video frame 1: %s\n",
  			ProgName, AVI_strerror());
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	// find VOP start code in first sample
  	static u_int8_t vopStartCode[4] = { 
  		0x00, 0x00, 0x01, MP4AV_MPEG4_VOP_START 
  	};
  
  	for (i = 0; i < frameSize - 4; i++) {
  		if (!memcmp(&pFrameBuffer[i], vopStartCode, 4)) {
--- 105,119 ----
  		fprintf(stderr,	
  			"%s: can't read video frame 1: %s\n",
  			ProgName, AVI_strerror());
! 		MP4DeleteTrack(mp4File, trackId);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	// find VOP start code in first sample
  	static u_int8_t vopStartCode[4] = { 
  		0x00, 0x00, 0x01, MP4AV_MPEG4_VOP_START 
  	};
+ 	u_int32_t vopStart = 0;
  
  	for (i = 0; i < frameSize - 4; i++) {
  		if (!memcmp(&pFrameBuffer[i], vopStartCode, 4)) {
***************
*** 115,120 ****
--- 121,127 ----
  			// should be configuration info
  			MP4SetTrackESConfiguration(mp4File, trackId,
  				pFrameBuffer, i);
+ 			vopStart = i;
  		}
  	}
  
***************
*** 122,130 ****
  		MP4SetVideoProfileLevel(mp4File, 0x01);
  	}
  
! 	// write out the first frame, including the initial configuration info
! 	MP4WriteSample(mp4File, trackId, 
! 		pFrameBuffer, frameSize, mp4FrameDuration, 0, true);
  
  	// process the rest of the frames
  	for (i = 1; i < numFrames; i++) {
--- 129,143 ----
  		MP4SetVideoProfileLevel(mp4File, 0x01);
  	}
  
! 	// write out the first frame, minus the initial configuration info
! 	MP4WriteSample(
! 		mp4File, 
! 		trackId, 
! 		&pFrameBuffer[vopStart], 
! 		frameSize - vopStart, 
! 		mp4FrameDuration, 
! 		0, 
! 		true);
  
  	// process the rest of the frames
  	for (i = 1; i < numFrames; i++) {
***************
*** 135,141 ****
  			fprintf(stderr,	
  				"%s: can't read video frame %i: %s\n",
  				ProgName, i + 1, AVI_strerror());
! 			exit(EXIT_AVI_CREATOR);
  		}
  
  		// we mark random access points in MP4 files
--- 148,155 ----
  			fprintf(stderr,	
  				"%s: can't read video frame %i: %s\n",
  				ProgName, i + 1, AVI_strerror());
! 			MP4DeleteTrack(mp4File, trackId);
! 			return MP4_INVALID_TRACK_ID;
  		}
  
  		// we mark random access points in MP4 files
***************
*** 165,171 ****
  		fprintf(stderr,	
  			"%s: audio compressor 0x%x not recognized\n",
  			 ProgName, audioType);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	u_int8_t temp[4];
--- 179,185 ----
  		fprintf(stderr,	
  			"%s: audio compressor 0x%x not recognized\n",
  			 ProgName, audioType);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	u_int8_t temp[4];
***************
*** 177,183 ****
  		fprintf(stderr,	
  			"%s: can't read audio frame 0: %s\n",
  			ProgName, AVI_strerror());
! 		exit(EXIT_AVI_CREATOR);
  	}
  	mp3header = BytesToInt32(temp);
  
--- 191,197 ----
  		fprintf(stderr,	
  			"%s: can't read audio frame 0: %s\n",
  			ProgName, AVI_strerror());
! 		return MP4_INVALID_TRACK_ID;
  	}
  	mp3header = BytesToInt32(temp);
  
***************
*** 186,192 ****
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid mp3 audio\n",
  			ProgName);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	u_int16_t samplesPerSecond = 
--- 200,206 ----
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid mp3 audio\n",
  			ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	u_int16_t samplesPerSecond = 
***************
*** 201,207 ****
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid mp3 audio\n",
  			 ProgName);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	MP4TrackId trackId = MP4AddAudioTrack(mp4File, 
--- 215,221 ----
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid mp3 audio\n",
  			 ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	MP4TrackId trackId = MP4AddAudioTrack(mp4File, 
***************
*** 210,216 ****
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create audio track\n", ProgName);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_AUDIO_TRACK_TYPE) == 1) {
--- 224,230 ----
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create audio track\n", ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_AUDIO_TRACK_TYPE) == 1) {
***************
*** 239,245 ****
  	if (pFrameBuffer == NULL) {
  		fprintf(stderr,	
  			"%s: can't allocate memory\n", ProgName);
! 		exit(EXIT_AVI_CREATOR);
  	}
  
  	AVI_seek_start(aviFile);
--- 253,260 ----
  	if (pFrameBuffer == NULL) {
  		fprintf(stderr,	
  			"%s: can't allocate memory\n", ProgName);
! 		MP4DeleteTrack(mp4File, trackId);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	AVI_seek_start(aviFile);
***************
*** 254,273 ****
  		mp3header = BytesToInt32(&pFrameBuffer[0]);
  
  		u_int16_t mp3FrameSize = MP4AV_Mp3GetFrameSize(mp3header);
  
! 		if (AVI_read_audio(aviFile, (char*)&pFrameBuffer[4], mp3FrameSize - 4)
! 		  != mp3FrameSize - 4) {
  			fprintf(stderr,	
! 				"%s: can't read audio frame %u: %s\n",
! 				ProgName, mp3FrameNumber, AVI_strerror());
! 			exit(EXIT_AVI_CREATOR);
  		}
  
  		if (!MP4WriteSample(mp4File, trackId, 
  		  &pFrameBuffer[0], mp3FrameSize)) {
  			fprintf(stderr,	
  				"%s: can't write audio frame %u\n", ProgName, mp3FrameNumber);
! 			exit(EXIT_AVI_CREATOR);
  		}
  	
  		mp3FrameNumber++;
--- 269,291 ----
  		mp3header = BytesToInt32(&pFrameBuffer[0]);
  
  		u_int16_t mp3FrameSize = MP4AV_Mp3GetFrameSize(mp3header);
+ 
+ 		int bytesRead =
+ 			AVI_read_audio(aviFile, (char*)&pFrameBuffer[4], mp3FrameSize - 4);
  
! 		if (bytesRead != mp3FrameSize - 4) {
  			fprintf(stderr,	
! 				"%s: Warning, incomplete audio frame %u, ending audio track\n",
! 				ProgName, mp3FrameNumber);
! 			break;
  		}
  
  		if (!MP4WriteSample(mp4File, trackId, 
  		  &pFrameBuffer[0], mp3FrameSize)) {
  			fprintf(stderr,	
  				"%s: can't write audio frame %u\n", ProgName, mp3FrameNumber);
! 			MP4DeleteTrack(mp4File, trackId);
! 			return MP4_INVALID_TRACK_ID;
  		}
  	
  		mp3FrameNumber++;
***************
*** 286,305 ****
  		fprintf(stderr,	
  			"%s: can't open %s: %s\n",
  			ProgName, aviFileName, AVI_strerror());
- 		exit(EXIT_AVI_CREATOR);
- 	}
  
  	if (AVI_video_frames(aviFile) > 0) {
! 		trackIds[numTracks++] = VideoCreator(mp4File, aviFile);
  	}
  
  	if (AVI_audio_bytes(aviFile) > 0) {
! 		trackIds[numTracks++] = AudioCreator(mp4File, aviFile);
  	}
! 
! 	trackIds[numTracks] = MP4_INVALID_TRACK_ID;
  
  	AVI_close(aviFile);
  
  	return trackIds;
  }
--- 304,329 ----
  		fprintf(stderr,	
  			"%s: can't open %s: %s\n",
  			ProgName, aviFileName, AVI_strerror());
  
+ 	} else {
  		if (AVI_video_frames(aviFile) > 0) {
! 			trackIds[numTracks] = VideoCreator(mp4File, aviFile);
! 			if (trackIds[numTracks] != MP4_INVALID_TRACK_ID) {
! 				numTracks++;
! 			}
  		}
  
  		if (AVI_audio_bytes(aviFile) > 0) {
! 			trackIds[numTracks] = AudioCreator(mp4File, aviFile);
! 			if (trackIds[numTracks] != MP4_INVALID_TRACK_ID) {
! 				numTracks++;
  			}
! 		}
  
  		AVI_close(aviFile);
+ 	}
+ 
+ 	trackIds[numTracks] = MP4_INVALID_TRACK_ID;
  
  	return trackIds;
  }
Index: server/mp4creator/mp3.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4creator/mp3.cpp,v
retrieving revision 1.10
retrieving revision 1.11
diff -c -w -r1.10 -r1.11
*** server/mp4creator/mp3.cpp	2002/04/06 00:08:50	1.10
--- server/mp4creator/mp3.cpp	2002/08/02 17:50:01	1.11
***************
*** 195,207 ****
  	if (!GetMpegLayer(inFile, &mpegLayer)) {
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be MPEG audio\n", ProgName);
! 		exit(EXIT_MP3_CREATOR);
  	}
  	if (mpegLayer == 0) {
  		fprintf(stderr,	
  			"%s: data in file appears to be AAC audio, use .aac extension\n",
  			 ProgName);
! 		exit(EXIT_MP3_CREATOR);
  	}
  
  	u_int16_t samplesPerSecond;
--- 195,207 ----
  	if (!GetMpegLayer(inFile, &mpegLayer)) {
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be MPEG audio\n", ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  	if (mpegLayer == 0) {
  		fprintf(stderr,	
  			"%s: data in file appears to be AAC audio, use .aac extension\n",
  			 ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	u_int16_t samplesPerSecond;
***************
*** 213,219 ****
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid audio\n",
  			 ProgName);
! 		exit(EXIT_MP3_CREATOR);
  	}
  
  	u_int8_t audioType = MP4AV_Mp3ToMp4AudioType(mpegVersion);
--- 213,219 ----
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid audio\n",
  			 ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	u_int8_t audioType = MP4AV_Mp3ToMp4AudioType(mpegVersion);
***************
*** 223,229 ****
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid audio\n",
  			 ProgName);
! 		exit(EXIT_MP3_CREATOR);
  	}
  
  	MP4TrackId trackId = 
--- 223,229 ----
  		fprintf(stderr,	
  			"%s: data in file doesn't appear to be valid audio\n",
  			 ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	MP4TrackId trackId = 
***************
*** 233,239 ****
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create audio track\n", ProgName);
! 		exit(EXIT_MP3_CREATOR);
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_AUDIO_TRACK_TYPE) == 1) {
--- 233,239 ----
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create audio track\n", ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_AUDIO_TRACK_TYPE) == 1) {
***************
*** 248,254 ****
  		if (!MP4WriteSample(mp4File, trackId, sampleBuffer, sampleSize)) {
  			fprintf(stderr,	
  				"%s: can't write audio frame %u\n", ProgName, sampleId);
! 			exit(EXIT_MP3_CREATOR);
  		}
  		sampleId++;
  		sampleSize = sizeof(sampleBuffer);
--- 248,255 ----
  		if (!MP4WriteSample(mp4File, trackId, sampleBuffer, sampleSize)) {
  			fprintf(stderr,	
  				"%s: can't write audio frame %u\n", ProgName, sampleId);
! 			MP4DeleteTrack(mp4File, trackId);
! 			return MP4_INVALID_TRACK_ID;
  		}
  		sampleId++;
  		sampleSize = sizeof(sampleBuffer);
Index: server/mp4creator/mp4creator.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4creator/mp4creator.cpp,v
retrieving revision 1.35
retrieving revision 1.37
diff -c -w -r1.35 -r1.37
*** server/mp4creator/mp4creator.cpp	2002/07/08 19:40:19	1.35
--- server/mp4creator/mp4creator.cpp	2002/08/16 23:48:31	1.37
***************
*** 346,352 ****
  			MP4TrackId* pCreatedTrackIds = 
  				CreateMediaTracks(mp4File, inputFileName);
  
! 			if (pCreatedTrackIds) {
  				// decide if we can raise the ISMA compliance tag in SDP
  				// we do this if audio and/or video are MPEG-4
  				MP4TrackId* pTrackId = pCreatedTrackIds;
--- 346,356 ----
  			MP4TrackId* pCreatedTrackIds = 
  				CreateMediaTracks(mp4File, inputFileName);
  
! 			if (pCreatedTrackIds == NULL) {
! 				MP4Close(mp4File);
! 				exit(EXIT_CREATE_MEDIA);
! 			}
! 
  			// decide if we can raise the ISMA compliance tag in SDP
  			// we do this if audio and/or video are MPEG-4
  			MP4TrackId* pTrackId = pCreatedTrackIds;
***************
*** 367,375 ****
  					}
  					pTrackId++;
  				}
- 			}
  
! 			if (pCreatedTrackIds && doHint) {
  				MP4TrackId* pTrackId = pCreatedTrackIds;
  
  				while (*pTrackId != MP4_INVALID_TRACK_ID) {
--- 371,378 ----
  				}
  				pTrackId++;
  			}
  
! 			if (doHint) {
  				MP4TrackId* pTrackId = pCreatedTrackIds;
  
  				while (*pTrackId != MP4_INVALID_TRACK_ID) {
***************
*** 455,461 ****
  		fprintf(stderr, 
  			"%s: can't open file %s: %s\n",
  			ProgName, inputFileName, strerror(errno));
! 		exit(EXIT_CREATE_MEDIA);
  	}
  
  	struct stat s;
--- 458,464 ----
  		fprintf(stderr, 
  			"%s: can't open file %s: %s\n",
  			ProgName, inputFileName, strerror(errno));
! 		return NULL;
  	}
  
  	struct stat s;
***************
*** 463,483 ****
  		fprintf(stderr, 
  			"%s: can't stat file %s: %s\n",
  			ProgName, inputFileName, strerror(errno));
! 		exit(EXIT_CREATE_MEDIA);
  	}
  
  	if (s.st_size == 0) {
  		fprintf(stderr, 
  			"%s: file %s is empty\n",
  			ProgName, inputFileName);
! 		exit(EXIT_CREATE_MEDIA);
  	}
  
  	const char* extension = strrchr(inputFileName, '.');
  	if (extension == NULL) {
  		fprintf(stderr, 
  			"%s: no file type extension\n", ProgName);
! 		exit(EXIT_CREATE_MEDIA);
  	}
  
  	static MP4TrackId trackIds[2] = {
--- 466,486 ----
  		fprintf(stderr, 
  			"%s: can't stat file %s: %s\n",
  			ProgName, inputFileName, strerror(errno));
! 		return NULL;
  	}
  
  	if (s.st_size == 0) {
  		fprintf(stderr, 
  			"%s: file %s is empty\n",
  			ProgName, inputFileName);
! 		return NULL;
  	}
  
  	const char* extension = strrchr(inputFileName, '.');
  	if (extension == NULL) {
  		fprintf(stderr, 
  			"%s: no file type extension\n", ProgName);
! 		return NULL;
  	}
  
  	static MP4TrackId trackIds[2] = {
***************
*** 509,532 ****
  	} else {
  		fprintf(stderr, 
  			"%s: unknown file type\n", ProgName);
! 		exit(EXIT_CREATE_MEDIA);
  	}
  
  	if (inFile) {
  		fclose(inFile);
  	}
  
  	return pTrackIds;
  }
  
  void CreateHintTrack(MP4FileHandle mp4File, MP4TrackId mediaTrackId,
  	const char* payloadName, bool interleave, u_int16_t maxPayloadSize)
  {
! 	bool rc;
  
  	if (MP4GetTrackNumberOfSamples(mp4File, mediaTrackId) == 0) {
  		fprintf(stderr, 
  			"%s: couldn't create hint track, no media samples\n", ProgName);
  		exit(EXIT_CREATE_HINT);
  	}
  
--- 512,540 ----
  	} else {
  		fprintf(stderr, 
  			"%s: unknown file type\n", ProgName);
! 		return NULL;
  	}
  
  	if (inFile) {
  		fclose(inFile);
  	}
  
+ 	if (pTrackIds[0] == MP4_INVALID_TRACK_ID) {
+ 		return NULL;
+ 	}
+ 
  	return pTrackIds;
  }
  
  void CreateHintTrack(MP4FileHandle mp4File, MP4TrackId mediaTrackId,
  	const char* payloadName, bool interleave, u_int16_t maxPayloadSize)
  {
! 	bool rc = false;
  
  	if (MP4GetTrackNumberOfSamples(mp4File, mediaTrackId) == 0) {
  		fprintf(stderr, 
  			"%s: couldn't create hint track, no media samples\n", ProgName);
+ 		MP4Close(mp4File);
  		exit(EXIT_CREATE_HINT);
  	}
  
***************
*** 559,565 ****
  		default:
  			fprintf(stderr, 
  				"%s: can't hint non-MPEG4/non-MP3 audio type\n", ProgName);
- 			exit(EXIT_CREATE_HINT);
  		}
  	} else if (!strcmp(trackType, MP4_VIDEO_TRACK_TYPE)) {
  		u_int8_t videoType = MP4GetTrackVideoType(mp4File, mediaTrackId);
--- 567,572 ----
***************
*** 569,585 ****
  		} else {
  			fprintf(stderr, 
  				"%s: can't hint non-MPEG4 video type\n", ProgName);
- 			exit(EXIT_CREATE_HINT);
  		}
  	} else {
  		fprintf(stderr, 
  			"%s: can't hint track type %s\n", ProgName, trackType);
- 		exit(EXIT_CREATE_HINT);
  	}
  
  	if (!rc) {
  		fprintf(stderr, 
  			"%s: error hinting track %u\n", ProgName, mediaTrackId);
  		exit(EXIT_CREATE_HINT);
  	}
  }
--- 576,591 ----
  		} else {
  			fprintf(stderr, 
  				"%s: can't hint non-MPEG4 video type\n", ProgName);
  		}
  	} else {
  		fprintf(stderr, 
  			"%s: can't hint track type %s\n", ProgName, trackType);
  	}
  
  	if (!rc) {
  		fprintf(stderr, 
  			"%s: error hinting track %u\n", ProgName, mediaTrackId);
+ 		MP4Close(mp4File);
  		exit(EXIT_CREATE_HINT);
  	}
  }
***************
*** 589,596 ****
  	MP4TrackId trackId, 
  	const char* outputFileName)
  {
! 	int outFd = open(outputFileName, 
! 			O_WRONLY | O_CREAT | O_TRUNC, 0644);
  
  	if (outFd == -1) {
  		fprintf(stderr, "%s: can't open %s: %s\n",
--- 595,607 ----
  	MP4TrackId trackId, 
  	const char* outputFileName)
  {
! 	int openFlags = O_WRONLY | O_CREAT | O_TRUNC;
! 
! #ifdef _WIN32
! 	openFlags |= O_BINARY;
! #endif
! 
! 	int outFd = open(outputFileName, openFlags, 0644);
  
  	if (outFd == -1) {
  		fprintf(stderr, "%s: can't open %s: %s\n",
Index: server/mp4creator/mp4creator.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4creator/mp4creator.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -c -w -r1.13 -r1.14
*** server/mp4creator/mp4creator.h	2002/07/01 21:14:17	1.13
--- server/mp4creator/mp4creator.h	2002/08/02 17:50:01	1.14
***************
*** 39,55 ****
  #define EXIT_CREATE_FILE	2
  #define EXIT_CREATE_MEDIA	3
  #define EXIT_CREATE_HINT	4
! #define EXIT_AAC_CREATOR	5
! #define EXIT_MP3_CREATOR	6
! #define EXIT_MP4V_CREATOR	7
! #define EXIT_AVI_CREATOR	8
! #define EXIT_RFCISMA_HINTER	9
! #define EXIT_RFC2250_HINTER	10
! #define EXIT_RFC3016_HINTER	11
! #define EXIT_RFC3119_HINTER	12
! #define EXIT_OPTIMIZE_FILE	13
! #define EXIT_EXTRACT_TRACK	14
! #define EXIT_INFO			15
  
  // global variables
  #ifdef MP4CREATOR_GLOBALS
--- 39,47 ----
  #define EXIT_CREATE_FILE	2
  #define EXIT_CREATE_MEDIA	3
  #define EXIT_CREATE_HINT	4
! #define EXIT_OPTIMIZE_FILE	5
! #define EXIT_EXTRACT_TRACK	6	
! #define EXIT_INFO			7
  
  // global variables
  #ifdef MP4CREATOR_GLOBALS
Index: server/mp4creator/mp4v.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4creator/mp4v.cpp,v
retrieving revision 1.21
retrieving revision 1.22
diff -c -w -r1.21 -r1.22
*** server/mp4creator/mp4v.cpp	2002/07/02 18:28:10	1.21
--- server/mp4creator/mp4v.cpp	2002/08/02 17:50:01	1.22
***************
*** 210,216 ****
  		if (pObj + objSize >= pCurrentSample + maxSampleSize) {
  			fprintf(stderr,	
  				"%s: buffer overflow, invalid video stream?\n", ProgName);
! 			exit(EXIT_MP4V_CREATOR);
  		}
  
  		if (Verbosity & MP4_DETAILS_SAMPLE) {
--- 210,216 ----
  		if (pObj + objSize >= pCurrentSample + maxSampleSize) {
  			fprintf(stderr,	
  				"%s: buffer overflow, invalid video stream?\n", ProgName);
! 			return MP4_INVALID_TRACK_ID;
  		}
  
  		if (Verbosity & MP4_DETAILS_SAMPLE) {
***************
*** 259,265 ****
  			"%s: variable rate video stream signalled,"
  			" please specify average frame rate with -r option\n",
  			 ProgName);
! 		exit(EXIT_MP4V_CREATOR);
  	}
  
  	// create the new video track
--- 259,265 ----
  			"%s: variable rate video stream signalled,"
  			" please specify average frame rate with -r option\n",
  			 ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	// create the new video track
***************
*** 275,281 ****
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create video track\n", ProgName);
! 		exit(EXIT_MP4V_CREATOR);
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_VIDEO_TRACK_TYPE) == 1) {
--- 275,281 ----
  	if (trackId == MP4_INVALID_TRACK_ID) {
  		fprintf(stderr,	
  			"%s: can't create video track\n", ProgName);
! 		return MP4_INVALID_TRACK_ID;
  	}
  
  	if (MP4GetNumberOfTracks(mp4File, MP4_VIDEO_TRACK_TYPE) == 1) {
***************
*** 310,316 ****
  				fprintf(stderr,	
  					"%s: can't write video frame %u\n",
  					 ProgName, sampleId);
! 				exit(EXIT_MP4V_CREATOR);
  			}
  
  			// deal with rendering time offsets 
--- 310,317 ----
  				fprintf(stderr,	
  					"%s: can't write video frame %u\n",
  					 ProgName, sampleId);
! 				MP4DeleteTrack(mp4File, trackId);
! 				return MP4_INVALID_TRACK_ID;
  			}
  
  			// deal with rendering time offsets 
***************
*** 347,353 ****
  		if (pObj + objSize >= pCurrentSample + maxSampleSize) {
  			fprintf(stderr,	
  				"%s: buffer overflow, invalid video stream?\n", ProgName);
! 			exit(EXIT_MP4V_CREATOR);
  		}
  
  		if (Verbosity & MP4_DETAILS_SAMPLE) {
--- 348,355 ----
  		if (pObj + objSize >= pCurrentSample + maxSampleSize) {
  			fprintf(stderr,	
  				"%s: buffer overflow, invalid video stream?\n", ProgName);
! 			MP4DeleteTrack(mp4File, trackId);
! 			return MP4_INVALID_TRACK_ID;
  		}
  
  		if (Verbosity & MP4_DETAILS_SAMPLE) {
Index: server/mp4live/Makefile.am
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/Makefile.am,v
retrieving revision 1.42
retrieving revision 1.43
diff -c -w -r1.42 -r1.43
*** server/mp4live/Makefile.am	2002/06/06 22:48:26	1.42
--- server/mp4live/Makefile.am	2002/08/14 01:04:58	1.43
***************
*** 79,84 ****
--- 79,85 ----
  	-D_REENTRANT -DNOCONTROLS -fexceptions -Wall
  
  LDADD = \
+ 	@GTK_LIBS@ @GLIB_LIBS@ \
  	$(top_builddir)/server/mp4live/gui/libmp4livegui.la \
  	$(top_builddir)/server/audio/faac/libfaac.la \
  	$(top_builddir)/server/audio/lame/libmp3lame.a \
***************
*** 93,98 ****
  	$(top_builddir)/lib/gnu/libmpeg4ip_gnu.la \
  	-lpthread \
  	@SDL_LIBS@ \
! 	$(top_builddir)/lib/SDL/src/main/libSDLmain.a \
! 	@GTK_LIBS@ @GLIB_LIBS@
  
--- 94,98 ----
  	$(top_builddir)/lib/gnu/libmpeg4ip_gnu.la \
  	-lpthread \
  	@SDL_LIBS@ \
! 	$(top_builddir)/lib/SDL/src/main/libSDLmain.a 
  
Index: server/mp4live/README
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/README,v
retrieving revision 1.11
retrieving revision 1.12
diff -c -w -r1.11 -r1.12
*** server/mp4live/README	2002/07/15 21:28:12	1.11
--- server/mp4live/README	2002/07/29 19:51:27	1.12
***************
*** 1,4 ****
! July 15, 2002 - Dave Mackie
  
  MP4LIVE 
  =======
--- 1,4 ----
! July 29, 2002 - Dave Mackie
  
  MP4LIVE 
  =======
***************
*** 51,56 ****
--- 51,65 ----
  
  	Logitech Quickcam Express Webcam
  
+ Note on multi-processor machines (SMP): mp4live is multithreaded at a coarse
+ level. Specifically the video encoder, audio encoder, file recorder, network
+ transmitter, and user interface each have their own thread. Unfortunately for
+ owners of multiprocessor machines, the video encoder thread dominates the 
+ computational requirements so one CPU will be very busy, and the others will
+ be lightly to moderately loaded. For those looking for a project, a multi-
+ threaded video encoder would certainly provide an interesting challenge.
+ 
+ 
  Software Requirements
  =====================
  Linux with a 2.4 or later kernel
***************
*** 101,106 ****
--- 110,118 ----
  run any programs that make large resource demands (CPU, bus, disk, network)
  while mp4live is running.
  
+ If you're capturing large video image sizes, then you may be able to boost
+ the encoded video frame rate by disabling video preview.
+ 
  The AAC audio encoder is noticeably slower than the MP3 audio encoder so 
  you will see lower video frame rates and greater sensitivity to CPU load 
  if you are using AAC.
***************
*** 275,286 ****
  time. If you use the Hauppage WinTV Go card you need to connect the mini-jack
  on the card to the line-in input on your sound card in order to get the
  audio signal from the TV tuner.
- 
- Reports from those who have tried mp4live on SMP enabled kernels report
- crashes that appear to be related to SDL. Pending a SDL fix to this we don't
- recommend using mp4live with SMP.  However, the code is multi-threaded so
- it should be possible exploit an SMP machine by assigning the video encoding 
- thread to one CPU and let the other threads run on another CPU. 
  
  Note there is currently no support for DV/mini-DV camcorders via FireWire. 
  You can of course still use these via their composite or S-Video outputs.
--- 287,292 ----
Index: server/mp4live/audio_encoder.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/audio_encoder.cpp,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -w -r1.2 -r1.3
*** server/mp4live/audio_encoder.cpp	2002/03/30 09:05:04	1.2
--- server/mp4live/audio_encoder.cpp	2002/07/30 00:09:55	1.3
***************
*** 83,89 ****
  {
  	bool mallocedLeft = false;
  
! 	if (*ppLeftBuffer == NULL) {
  		*ppLeftBuffer = 
  			(u_int16_t*)malloc((srcNumSamples >> 1) * sizeof(u_int16_t));
  		if (*ppLeftBuffer == NULL) {
--- 83,89 ----
  {
  	bool mallocedLeft = false;
  
! 	if (ppLeftBuffer && *ppLeftBuffer == NULL) {
  		*ppLeftBuffer = 
  			(u_int16_t*)malloc((srcNumSamples >> 1) * sizeof(u_int16_t));
  		if (*ppLeftBuffer == NULL) {
***************
*** 92,98 ****
  		mallocedLeft = true;
  	}
  
! 	if (*ppRightBuffer == NULL) {
  		*ppRightBuffer = 
  			(u_int16_t*)malloc((srcNumSamples >> 1) * sizeof(u_int16_t));
  		if (*ppRightBuffer == NULL) {
--- 92,98 ----
  		mallocedLeft = true;
  	}
  
! 	if (ppRightBuffer && *ppRightBuffer == NULL) {
  		*ppRightBuffer = 
  			(u_int16_t*)malloc((srcNumSamples >> 1) * sizeof(u_int16_t));
  		if (*ppRightBuffer == NULL) {
***************
*** 105,112 ****
--- 105,116 ----
  	}
  
  	for (u_int32_t i = 0; i < (srcNumSamples >> 1); i++) {
+ 		if (ppLeftBuffer) {
  			(*ppLeftBuffer)[i] = pSrcBuffer[(i << 1)];
+ 		}
+ 		if (ppRightBuffer) {
  			(*ppRightBuffer)[i] = pSrcBuffer[(i << 1) + 1];
+ 		}
  	}
  
  	return true;
Index: server/mp4live/audio_encoder.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/audio_encoder.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -w -r1.7 -r1.8
*** server/mp4live/audio_encoder.h	2002/04/24 00:20:22	1.7
--- server/mp4live/audio_encoder.h	2002/07/30 00:09:55	1.8
***************
*** 35,41 ****
  
  	virtual bool EncodeSamples(
  		u_int16_t* pBuffer, 
! 		u_int32_t bufferLength) = NULL;
  
  	virtual bool EncodeSamples(
  		u_int16_t* pLeftBuffer, 
--- 35,42 ----
  
  	virtual bool EncodeSamples(
  		u_int16_t* pBuffer, 
! 		u_int32_t bufferLength,
! 		u_int8_t numChannels) = NULL;
  
  	virtual bool EncodeSamples(
  		u_int16_t* pLeftBuffer, 
Index: server/mp4live/audio_faac.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/audio_faac.cpp,v
retrieving revision 1.5
retrieving revision 1.8
diff -c -w -r1.5 -r1.8
*** server/mp4live/audio_faac.cpp	2002/03/30 09:05:04	1.5
--- server/mp4live/audio_faac.cpp	2002/07/30 19:54:39	1.8
***************
*** 69,94 ****
  
  bool CFaacAudioEncoder::EncodeSamples(
  	u_int16_t* pBuffer, 
! 	u_int32_t bufferLength)
  {
  	int rc = 0;
  
! 	// just in case, should be NULL
  	free(m_aacFrameBuffer);
  
  	m_aacFrameBuffer = (u_int8_t*)malloc(m_aacFrameMaxSize);
  
  	if (m_aacFrameBuffer == NULL) {
  		return false;
  	}
  
  	rc = faacEncEncode(
  		m_faacHandle,
! 		(short*)pBuffer,
! 		bufferLength / 2,
  		m_aacFrameBuffer,
  		m_aacFrameMaxSize);
  
  	if (rc < 0) {
  		return false;
  	}
--- 69,144 ----
  
  bool CFaacAudioEncoder::EncodeSamples(
  	u_int16_t* pBuffer, 
! 	u_int32_t bufferLength,
! 	u_int8_t numChannels)
  {
+ 	u_int16_t* pInputBuffer = pBuffer;
+ 	bool inputBufferMalloced = false;
+ 	u_int32_t numInputSamples = bufferLength / sizeof(u_int16_t);
  	int rc = 0;
+ 
+ 	// check for signal to end encoding
+ 	if (pInputBuffer == NULL) {
+ 		// unlike lame, faac doesn't need to finish up anything
+ 		return false;
+ 	}
  
! 	// free old AAC buffer, just in case, should already be NULL
  	free(m_aacFrameBuffer);
  
+ 	// allocate the AAC buffer
  	m_aacFrameBuffer = (u_int8_t*)malloc(m_aacFrameMaxSize);
  
  	if (m_aacFrameBuffer == NULL) {
  		return false;
  	}
  
+ 	// check for channel mismatch between src and dst
+ 	if (numChannels != m_pConfig->GetIntegerValue(CONFIG_AUDIO_CHANNELS)) {
+ 		if (numChannels == 1) {
+ 			// convert mono to stereo
+ 			pInputBuffer = NULL;
+ 			inputBufferMalloced = true;
+ 
+ 			InterleaveStereoSamples(
+ 				pBuffer, 
+ 				pBuffer,
+ 				numInputSamples,
+ 				&pInputBuffer);
+ 
+ 			numInputSamples *= 2;
+ 
+ 		} else if (numChannels == 2) {
+ 			// convert stereo to mono
+ 			pInputBuffer = NULL;
+ 			inputBufferMalloced = true;
+ 
+ 			DeinterleaveStereoSamples(
+ 				pBuffer, 
+ 				numInputSamples,
+ 				&pInputBuffer, 
+ 				NULL);
+ 
+ 			numInputSamples /= 2;
+ 
+ 		} else {
+ 			// invalid numChannels
+ 			return false;
+ 		}
+ 	}
+ 
  	rc = faacEncEncode(
  		m_faacHandle,
! 		(short*)pInputBuffer,
! 		numInputSamples,
  		m_aacFrameBuffer,
  		m_aacFrameMaxSize);
  
+ 	if (inputBufferMalloced) {
+ 		free(pInputBuffer);
+ 		pInputBuffer = NULL;
+ 	}
+ 
  	if (rc < 0) {
  		return false;
  	}
***************
*** 103,109 ****
  	u_int16_t* pRightBuffer, 
  	u_int32_t bufferLength)
  {
! 	if (pRightBuffer) {
  		u_int16_t* pPcmBuffer = NULL;
  
  		InterleaveStereoSamples(
--- 153,160 ----
  	u_int16_t* pRightBuffer, 
  	u_int32_t bufferLength)
  {
! 	if (pRightBuffer 
! 	  && m_pConfig->GetIntegerValue(CONFIG_AUDIO_CHANNELS) == 2) {
  		u_int16_t* pPcmBuffer = NULL;
  
  		InterleaveStereoSamples(
***************
*** 112,125 ****
  			bufferLength / sizeof(u_int16_t),
  			&pPcmBuffer);
  
! 		bool rc = EncodeSamples(pPcmBuffer, bufferLength * 2);
  
  		free(pPcmBuffer);
  
  		return rc;
  	}
  
! 	return EncodeSamples(pLeftBuffer, bufferLength);
  }
  
  bool CFaacAudioEncoder::GetEncodedSamples(
--- 163,176 ----
  			bufferLength / sizeof(u_int16_t),
  			&pPcmBuffer);
  
! 		bool rc = EncodeSamples(pPcmBuffer, bufferLength * 2, 2);
  
  		free(pPcmBuffer);
  
  		return rc;
  	}
  
! 	return EncodeSamples(pLeftBuffer, bufferLength, 1);
  }
  
  bool CFaacAudioEncoder::GetEncodedSamples(
Index: server/mp4live/audio_faac.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/audio_faac.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -w -r1.6 -r1.7
*** server/mp4live/audio_faac.h	2002/04/24 00:20:22	1.6
--- server/mp4live/audio_faac.h	2002/07/30 00:09:55	1.7
***************
*** 40,46 ****
  
  	bool EncodeSamples(
  		u_int16_t* pBuffer, 
! 		u_int32_t bufferLength);
  
  	bool EncodeSamples(
  		u_int16_t* pLeftBuffer,
--- 40,47 ----
  
  	bool EncodeSamples(
  		u_int16_t* pBuffer, 
! 		u_int32_t bufferLength,
! 		u_int8_t numChannels);
  
  	bool EncodeSamples(
  		u_int16_t* pLeftBuffer,
Index: server/mp4live/audio_lame.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/audio_lame.cpp,v
retrieving revision 1.9
retrieving revision 1.10
diff -c -w -r1.9 -r1.10
*** server/mp4live/audio_lame.cpp	2002/06/20 20:36:47	1.9
--- server/mp4live/audio_lame.cpp	2002/07/30 00:09:55	1.10
***************
*** 79,87 ****
  
  bool CLameAudioEncoder::EncodeSamples(
  	u_int16_t* pBuffer, 
! 	u_int32_t bufferLength)
  {
! 	if (m_pConfig->GetIntegerValue(CONFIG_AUDIO_CHANNELS) == 2) {
  		bool rc;
  		u_int16_t* leftBuffer = NULL;
  		u_int16_t* rightBuffer = NULL;
--- 79,91 ----
  
  bool CLameAudioEncoder::EncodeSamples(
  	u_int16_t* pBuffer, 
! 	u_int32_t bufferLength,
! 	u_int8_t numChannels)
  {
! 	if (numChannels == 1) {
! 		return EncodeSamples(pBuffer, pBuffer, bufferLength);
! 
! 	} else if (numChannels == 2) {
  		bool rc;
  		u_int16_t* leftBuffer = NULL;
  		u_int16_t* rightBuffer = NULL;
***************
*** 99,107 ****
  
  		return rc; 
  	} 
! 
! 	// else channels == 1
! 	return EncodeSamples(pBuffer, NULL, bufferLength);
  }
  
  bool CLameAudioEncoder::EncodeSamples(
--- 103,110 ----
  
  		return rc; 
  	} 
! 	// invalid numChannels
! 	return false;	
  }
  
  bool CLameAudioEncoder::EncodeSamples(
***************
*** 112,117 ****
--- 115,124 ----
  	u_int32_t mp3DataLength = 0;
  
  	if (pLeftBuffer) {
+ 		if (m_lameParams.num_channels == 1) {
+ 			pRightBuffer = NULL;
+ 		}
+ 
  		// call lame encoder
  		mp3DataLength = lame_encode_buffer(
  			&m_lameParams,
Index: server/mp4live/audio_lame.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/audio_lame.h,v
retrieving revision 1.7
retrieving revision 1.8
diff -c -w -r1.7 -r1.8
*** server/mp4live/audio_lame.h	2002/04/24 00:20:22	1.7
--- server/mp4live/audio_lame.h	2002/07/30 00:09:55	1.8
***************
*** 41,47 ****
  
  	bool EncodeSamples(
  		u_int16_t* pBuffer, 
! 		u_int32_t bufferLength);
  
  	bool EncodeSamples(
  		u_int16_t* pLeftBuffer,
--- 41,48 ----
  
  	bool EncodeSamples(
  		u_int16_t* pBuffer, 
! 		u_int32_t bufferLength,
! 		u_int8_t numChannels);
  
  	bool EncodeSamples(
  		u_int16_t* pLeftBuffer,
Index: server/mp4live/audio_oss_source.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/audio_oss_source.h,v
retrieving revision 1.6
retrieving revision 1.7
diff -c -w -r1.6 -r1.7
*** server/mp4live/audio_oss_source.h	2002/06/03 18:35:02	1.6
--- server/mp4live/audio_oss_source.h	2002/08/14 01:04:58	1.7
***************
*** 69,75 ****
  
  class CAudioCapabilities {
  public:
! 	CAudioCapabilities(char* deviceName) {
  		m_deviceName = stralloc(deviceName);
  		m_canOpen = false;
  		m_numSamplingRates = 0;
--- 69,75 ----
  
  class CAudioCapabilities {
  public:
! 	CAudioCapabilities(const char* deviceName) {
  		m_deviceName = stralloc(deviceName);
  		m_canOpen = false;
  		m_numSamplingRates = 0;
Index: server/mp4live/config_set.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/config_set.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -w -r1.3 -r1.4
*** server/mp4live/config_set.h	2002/06/05 20:26:33	1.3
--- server/mp4live/config_set.h	2002/08/14 01:04:58	1.4
***************
*** 301,307 ****
  		return m_variables[iName].m_value.m_svalue;
  	}
  
! 	inline void SetStringValue(const config_index_t iName, char* svalue) {
  #if CONFIG_SAFETY
  		CheckIName(iName);
  		CheckStringType(iName);
--- 301,307 ----
  		return m_variables[iName].m_value.m_svalue;
  	}
  
! 	inline void SetStringValue(const config_index_t iName, const char* svalue) {
  #if CONFIG_SAFETY
  		CheckIName(iName);
  		CheckStringType(iName);
Index: server/mp4live/file_mp4_recorder.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/file_mp4_recorder.cpp,v
retrieving revision 1.8
retrieving revision 1.10
diff -c -w -r1.8 -r1.10
*** server/mp4live/file_mp4_recorder.cpp	2002/06/03 18:35:02	1.8
--- server/mp4live/file_mp4_recorder.cpp	2002/08/12 19:06:26	1.10
***************
*** 57,71 ****
  
  void CMp4Recorder::DoStartRecord()
  {
  	if (m_sink) {
  		return;
  	}
  
  	// enable huge file mode in mp4 if estimated size goes over 1 GB
  	bool hugeFile = 
  		m_pConfig->m_recordEstFileSize > 1000000000;
  	u_int32_t verbosity =
! 		MP4_DETAILS_ERROR /* | MP4_DETAILS_WRITE_ALL */;
  
  	if (m_pConfig->GetBoolValue(CONFIG_RECORD_MP4_OVERWRITE)) {
  		m_mp4File = MP4Create(
--- 57,74 ----
  
  void CMp4Recorder::DoStartRecord()
  {
+ 	// already recording
  	if (m_sink) {
  		return;
  	}
  
+ 	// first get the mp4 file setup
+ 
  	// enable huge file mode in mp4 if estimated size goes over 1 GB
  	bool hugeFile = 
  		m_pConfig->m_recordEstFileSize > 1000000000;
  	u_int32_t verbosity =
! 		MP4_DETAILS_ERROR /* DEBUG | MP4_DETAILS_WRITE_ALL */;
  
  	if (m_pConfig->GetBoolValue(CONFIG_RECORD_MP4_OVERWRITE)) {
  		m_mp4File = MP4Create(
***************
*** 85,114 ****
  	m_encodedVideoTrackId = MP4_INVALID_TRACK_ID;
  	m_rawAudioTrackId = MP4_INVALID_TRACK_ID;
  	m_encodedAudioTrackId = MP4_INVALID_TRACK_ID;
- 
- 	m_canRecordAudio = true;
  
! 	m_rawAudioTimeScale = m_encodedAudioTimeScale = 
  		m_pConfig->GetIntegerValue(CONFIG_AUDIO_SAMPLE_RATE);
  
  	if (m_pConfig->GetBoolValue(CONFIG_VIDEO_ENABLE)
  	  && (m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_VIDEO)
  	    || m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO))) {
  		m_movieTimeScale = m_videoTimeScale;
  
! 	} else if (m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_AUDIO)) {
! 		m_movieTimeScale = m_encodedAudioTimeScale;
! 
! 	} else {
! 		m_movieTimeScale = m_rawAudioTimeScale;
  	}
  	MP4SetTimeScale(m_mp4File, m_movieTimeScale);
  
  	if (m_pConfig->GetBoolValue(CONFIG_VIDEO_ENABLE)) {
  
  		if (m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_VIDEO)) {
! 			m_rawVideoFrameNum = 1;
! 			m_canRecordAudio = false;
  
  			m_rawVideoTrackId = MP4AddVideoTrack(
  				m_mp4File,
--- 88,117 ----
  	m_encodedVideoTrackId = MP4_INVALID_TRACK_ID;
  	m_rawAudioTrackId = MP4_INVALID_TRACK_ID;
  	m_encodedAudioTrackId = MP4_INVALID_TRACK_ID;
  
! 	m_audioTimeScale =
  		m_pConfig->GetIntegerValue(CONFIG_AUDIO_SAMPLE_RATE);
  
+ 	// are we recording any video?
  	if (m_pConfig->GetBoolValue(CONFIG_VIDEO_ENABLE)
  	  && (m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_VIDEO)
  	    || m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO))) {
+ 		m_recordVideo = true;
+ 		m_canRecordAudio = false;	// audio must wait for video
  		m_movieTimeScale = m_videoTimeScale;
  
! 	} else { // just audio
! 		m_recordVideo = false;
! 		m_canRecordAudio = true;
! 		m_movieTimeScale = m_audioTimeScale;
  	}
+ 
  	MP4SetTimeScale(m_mp4File, m_movieTimeScale);
  
  	if (m_pConfig->GetBoolValue(CONFIG_VIDEO_ENABLE)) {
  
  		if (m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_VIDEO)) {
! 			m_rawVideoFrameNumber = 1;
  
  			m_rawVideoTrackId = MP4AddVideoTrack(
  				m_mp4File,
***************
*** 127,134 ****
  		}
  
  		if (m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO)) {
! 			m_encodedVideoFrameNum = 1;
! 			m_canRecordAudio = false;
  
  			m_encodedVideoTrackId = MP4AddVideoTrack(
  				m_mp4File,
--- 130,136 ----
  		}
  
  		if (m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO)) {
! 			m_encodedVideoFrameNumber = 1;
  
  			m_encodedVideoTrackId = MP4AddVideoTrack(
  				m_mp4File,
***************
*** 143,167 ****
  				goto start_failure;
  			}
  
! 			MP4SetVideoProfileLevel(m_mp4File, 
  				m_pConfig->GetIntegerValue(CONFIG_VIDEO_PROFILE_ID));
  
! 			MP4SetTrackESConfiguration(m_mp4File, m_encodedVideoTrackId,
  				m_pConfig->m_videoMpeg4Config, 
  				m_pConfig->m_videoMpeg4ConfigLength); 
- 
  		}
  	}
  
  	if (m_pConfig->GetBoolValue(CONFIG_AUDIO_ENABLE)) {
  
  		if (m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_AUDIO)) {
- 			m_rawAudioFrameNum = 1;
- 			m_rawAudioDuration = 0;
  
  			m_rawAudioTrackId = MP4AddAudioTrack(
  				m_mp4File, 
! 				m_rawAudioTimeScale, 
  				0,
  				MP4_PCM16_AUDIO_TYPE);
  
--- 145,174 ----
  				goto start_failure;
  			}
  
! 			MP4SetVideoProfileLevel(
! 				m_mp4File, 
  				m_pConfig->GetIntegerValue(CONFIG_VIDEO_PROFILE_ID));
  
! 			MP4SetTrackESConfiguration(
! 				m_mp4File, 
! 				m_encodedVideoTrackId,
  				m_pConfig->m_videoMpeg4Config, 
  				m_pConfig->m_videoMpeg4ConfigLength); 
  		}
  	}
  
+ 	m_rawAudioFrameNumber = 1;
+ 	m_rawAudioDuration = 0;
+ 	m_encodedAudioFrameNumber = 1;
+ 	m_encodedAudioDuration = 0;
+ 
  	if (m_pConfig->GetBoolValue(CONFIG_AUDIO_ENABLE)) {
  
  		if (m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_AUDIO)) {
  
  			m_rawAudioTrackId = MP4AddAudioTrack(
  				m_mp4File, 
! 				m_audioTimeScale, 
  				0,
  				MP4_PCM16_AUDIO_TYPE);
  
***************
*** 174,181 ****
  		}
  
  		if (m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_AUDIO)) {
- 			m_encodedAudioFrameNum = 1;
- 			m_encodedAudioDuration = 0;
  
  			u_int8_t audioType;
  
--- 181,186 ----
***************
*** 190,196 ****
  
  			m_encodedAudioTrackId = MP4AddAudioTrack(
  				m_mp4File, 
! 				m_encodedAudioTimeScale, 
  				MP4_INVALID_DURATION,
  				audioType);
  
--- 195,201 ----
  
  			m_encodedAudioTrackId = MP4AddAudioTrack(
  				m_mp4File, 
! 				m_audioTimeScale, 
  				MP4_INVALID_DURATION,
  				audioType);
  
***************
*** 231,334 ****
  
  void CMp4Recorder::DoWriteFrame(CMediaFrame* pFrame)
  {
  	if (pFrame == NULL) {
  		return;
  	}
  	if (!m_sink) {
  		delete pFrame;
  		return;
  	}
  
  	if (pFrame->GetType() == CMediaFrame::PcmAudioFrame
  	  && m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_AUDIO)) {
  
! 		if (m_canRecordAudio) {
! 			if (m_rawAudioFrameNum == 1) {
! 				m_rawAudioStartTimestamp = pFrame->GetTimestamp();
! 				m_rawAudioDuration = 0;
  			}
  
! 			// check for audio continuity
! 			Duration skew =
! 				MP4ConvertToTrackDuration(
! 					m_mp4File, 
! 					m_rawAudioTrackId, 
! 					(pFrame->GetTimestamp() - m_rawAudioStartTimestamp)
! 						- m_rawAudioDuration,
! 					TimestampTicks);
  
! 			if (skew > 128) {
! 				// record audio gap
! 				MP4WriteSample(
! 					m_mp4File,
! 					m_rawAudioTrackId,
! 					NULL,
! 					0,
! 					skew);
  			}
- 
- 			MP4WriteSample(
- 				m_mp4File,
- 				m_rawAudioTrackId,
- 				(u_int8_t*)pFrame->GetData(), 
- 				pFrame->GetDataLength(),
- 				pFrame->GetDataLength() 
- 					/ (2 * m_pConfig->GetIntegerValue(CONFIG_AUDIO_CHANNELS)));
  
! 			m_rawAudioFrameNum++;
  
! 			m_rawAudioDuration += 
! 				pFrame->ConvertDuration(TimestampTicks);
  		}
  
! 	} else if ((pFrame->GetType() == CMediaFrame::Mp3AudioFrame
! 	    || pFrame->GetType() == CMediaFrame::AacAudioFrame)
! 	  && m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_AUDIO)) {
  
! 		if (m_canRecordAudio) {
! 			if (m_encodedAudioFrameNum == 1) {
! 				m_encodedAudioStartTimestamp = pFrame->GetTimestamp();
! 				m_encodedAudioDuration = 0;
! 			}
  
! 			// check for audio continuity
! 			Duration skew =
  				MP4ConvertToTrackDuration(
  					m_mp4File, 
! 					m_encodedAudioTrackId, 
! 					(pFrame->GetTimestamp() - m_encodedAudioStartTimestamp)
! 						- m_encodedAudioDuration,
  					TimestampTicks);
  
! 			if (skew > 128) {
! 				// record audio gap
  				MP4WriteSample(
  					m_mp4File,
! 					m_encodedAudioTrackId,
  					NULL,
  					0,
! 					skew);
  			}
  
  			MP4WriteSample(
  				m_mp4File,
! 				m_encodedAudioTrackId,
  				(u_int8_t*)pFrame->GetData(), 
  				pFrame->GetDataLength(),
! 				pFrame->ConvertDuration(m_encodedAudioTimeScale));
! 
! 			m_encodedAudioFrameNum++;
  
  			m_encodedAudioDuration += 
  				pFrame->ConvertDuration(TimestampTicks);
  		}
  
  	} else if (pFrame->GetType() == CMediaFrame::YuvVideoFrame
  	  && m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_VIDEO)) {
  
! 		// let audio record if raw is the only video being recorded
  		if (!m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO)) {
  			m_canRecordAudio = true;
  		}
  
  		MP4WriteSample(
--- 236,380 ----
  
  void CMp4Recorder::DoWriteFrame(CMediaFrame* pFrame)
  {
+ 	// dispose of degenerate cases
  	if (pFrame == NULL) {
  		return;
  	}
+ 
  	if (!m_sink) {
  		delete pFrame;
  		return;
  	}
  
+ 	// check if this is an audio frame that we want to record
+ 	// and if so setup some local variables
+ 
+ 	bool doRawAudioFrame = false;
+ 	bool doEncodedAudioFrame = false;
+ 	MP4TrackId audioTrackId = MP4_INVALID_TRACK_ID;
+ 	u_int32_t audioFrameNumber = 0;
+ 	Duration audioDuration = 0;
+ 
  	if (pFrame->GetType() == CMediaFrame::PcmAudioFrame
  	  && m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_AUDIO)) {
+ 		doRawAudioFrame = true;
+ 		audioTrackId = m_rawAudioTrackId;
+ 		audioFrameNumber = m_rawAudioFrameNumber;
+ 		audioDuration = m_rawAudioDuration;
  
! 	} else if ((pFrame->GetType() == CMediaFrame::Mp3AudioFrame
! 	    || pFrame->GetType() == CMediaFrame::AacAudioFrame)
! 	  && m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_AUDIO)) {
! 		doEncodedAudioFrame = true;
! 		audioTrackId = m_encodedAudioTrackId;
! 		audioFrameNumber = m_encodedAudioFrameNumber;
! 		audioDuration = m_encodedAudioDuration;
  	}
  
! 	// process an audio frame
! 	if ((doRawAudioFrame || doEncodedAudioFrame)) {
! 		// need special processing for very first audio frame
! 		if (audioFrameNumber == 1) {
  
! 			// can't record yet, awaiting first video frame
! 			if (!m_canRecordAudio) {
! 				delete pFrame;
! 				return;
  			}
  
! 			// initialize variables for audio timeline
! 			if (doRawAudioFrame) {
! 				m_rawAudioStartTimestamp = pFrame->GetTimestamp();
! 			} else {
! 				m_encodedAudioStartTimestamp = pFrame->GetTimestamp();
! 			}
  
! 			// if just recording audio
! 			if (!m_recordVideo) {
! 				if (m_rawAudioFrameNumber == 1 
! 				  && m_encodedAudioFrameNumber == 1) {
! 					m_movieStartTimestamp = pFrame->GetTimestamp();
  				}
+ 			} else {
+ 				// drop any errant audio frames that are too early
+ 				if (pFrame->GetTimestamp() < m_movieStartTimestamp) {
+ 					delete pFrame;
+ 					return;
+ 				}
+ 			}
  
! 		} // end of first audio frame processing
  
! 		Duration audioGapInTicks = 
! 			(pFrame->GetTimestamp() - m_movieStartTimestamp) - audioDuration;
  
! 		MP4Duration audioGapInSamples = 0;
! 
! 		if (audioGapInTicks > 0) {
! 			audioGapInSamples =
  				MP4ConvertToTrackDuration(
  					m_mp4File, 
! 					audioTrackId,
! 					audioGapInTicks,
  					TimestampTicks);
+ 		}
  
! 		// if there is an audio gap
! 		if (audioGapInSamples >= m_audioGapThresholdInSamples) {
! 			// write a null audio sample to fill the gap
  			MP4WriteSample(
  				m_mp4File,
! 				audioTrackId,
  				NULL,
  				0,
! 				audioGapInSamples);
! 
! 			if (doRawAudioFrame) {
! 				m_rawAudioDuration += audioGapInTicks;
! 			} else {
! 				m_encodedAudioDuration += audioGapInTicks;
! 			}
  		}
  
+ 		// write the audio frame
  		MP4WriteSample(
  			m_mp4File,
! 			audioTrackId,
  			(u_int8_t*)pFrame->GetData(), 
  			pFrame->GetDataLength(),
! 			pFrame->ConvertDuration(m_audioTimeScale));
  
+ 		if (doRawAudioFrame) {
+ 			m_rawAudioFrameNumber++;
+ 			m_rawAudioDuration += 
+ 				pFrame->ConvertDuration(TimestampTicks);
+ 		} else {
+ 			m_encodedAudioFrameNumber++;
  			m_encodedAudioDuration += 
  				pFrame->ConvertDuration(TimestampTicks);
  		}
  
  	} else if (pFrame->GetType() == CMediaFrame::YuvVideoFrame
  	  && m_pConfig->GetBoolValue(CONFIG_RECORD_RAW_VIDEO)) {
+ 
+ 		if (m_rawVideoFrameNumber == 1) {
+ 			m_rawVideoStartTimestamp = pFrame->GetTimestamp();
  
! 			// if we're just recording raw video
  			if (!m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO)) {
+ 				m_movieStartTimestamp = m_rawVideoStartTimestamp;
+ 				// let audio record now 
  				m_canRecordAudio = true;
+ 
+ 			} else { // also recording encoded video
+ 				// media source will send encoded video frame first
+ 				// so if we haven't gotten an encoded I frame yet
+ 				// don't accept this raw video frame
+ 				if (m_encodedVideoFrameNumber == 1) {
+ 					delete pFrame;
+ 					return;
+ 				}
+ 			}
  		}
  
  		MP4WriteSample(
***************
*** 338,378 ****
  			pFrame->GetDataLength(),
  			pFrame->ConvertDuration(m_videoTimeScale));
  
! 		m_rawVideoFrameNum++;
  
  	} else if (pFrame->GetType() == CMediaFrame::Mpeg4VideoFrame
  	  && m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO)) {
  
- 		u_int8_t* pSample = NULL;
- 		u_int32_t sampleLength = 0;
- 		Duration sampleDuration = 
- 			pFrame->ConvertDuration(m_videoTimeScale);
  		bool isIFrame = (MP4AV_Mpeg4GetVopType(
! 			(u_int8_t*)pFrame->GetData(), pFrame->GetDataLength()) == 'I');
  
! 		if (m_encodedVideoFrameNum > 1 || isIFrame) {
! 			pSample = (u_int8_t*)pFrame->GetData();
! 			sampleLength = pFrame->GetDataLength();
  
  			m_canRecordAudio = true;
  
- 		} // else waiting for I frame at start of recording
- 
- 		if (pSample != NULL) {
  			MP4WriteSample(
  				m_mp4File,
  				m_encodedVideoTrackId,
! 				pSample, 
! 				sampleLength,
! 				sampleDuration,
  				0,
  				isIFrame);
  		
! 			m_encodedVideoFrameNum++;
  		}
- 	}
  
  	delete pFrame;
  }
  
  void CMp4Recorder::DoStopRecord()
--- 384,425 ----
  			pFrame->GetDataLength(),
  			pFrame->ConvertDuration(m_videoTimeScale));
  
! 		m_rawVideoFrameNumber++;
  
  	} else if (pFrame->GetType() == CMediaFrame::Mpeg4VideoFrame
  	  && m_pConfig->GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO)) {
  
  		bool isIFrame = (MP4AV_Mpeg4GetVopType(
! 				(u_int8_t*)pFrame->GetData(), 
! 				pFrame->GetDataLength()) 
! 			== 'I');
  
! 		// ensure we start recording with an I frame
! 		if (m_encodedVideoFrameNumber == 1) {
! 			if (!isIFrame) {
! 				delete pFrame;
! 				return;
! 			}
  
+ 			m_encodedVideoStartTimestamp = pFrame->GetTimestamp();
+ 			m_movieStartTimestamp = m_encodedVideoStartTimestamp;
  			m_canRecordAudio = true;
+ 		}
  
  		MP4WriteSample(
  			m_mp4File,
  			m_encodedVideoTrackId,
! 			(u_int8_t*)pFrame->GetData(),
! 			pFrame->GetDataLength(),
! 			pFrame->ConvertDuration(m_videoTimeScale),
  			0,
  			isIFrame);
  		
! 		m_encodedVideoFrameNumber++;
  	}
  
  	delete pFrame;
+ 	return;
  }
  
  void CMp4Recorder::DoStopRecord()
Index: server/mp4live/file_mp4_recorder.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/file_mp4_recorder.h,v
retrieving revision 1.5
retrieving revision 1.7
diff -c -w -r1.5 -r1.7
*** server/mp4live/file_mp4_recorder.h	2002/06/03 18:35:02	1.5
--- server/mp4live/file_mp4_recorder.h	2002/08/12 19:06:26	1.7
***************
*** 27,34 ****
  #include <mp4av.h>
  #include "media_sink.h"
  
- #define RTP_HEADER_STD_SIZE 12
- 
  class CMp4Recorder : public CMediaSink {
  public:
  	CMp4Recorder() {
--- 27,32 ----
***************
*** 40,45 ****
--- 38,44 ----
  
  		m_videoTimeScale = 90000;
  		m_movieTimeScale = m_videoTimeScale;
+ 		m_audioGapThresholdInSamples = 128;
  	}
  
  protected:
***************
*** 50,55 ****
--- 49,55 ----
  	void DoWriteFrame(CMediaFrame* pFrame);
  
  protected:
+ 	bool			m_recordVideo;
  	bool			m_canRecordAudio;	// used for sync'ed start of A/V
  
  	char*			m_mp4FileName;
***************
*** 57,78 ****
  
  	u_int32_t		m_movieTimeScale;
  	u_int32_t		m_videoTimeScale;
  
  	MP4TrackId		m_rawVideoTrackId;
! 	u_int32_t		m_rawVideoFrameNum;
  
  	MP4TrackId		m_encodedVideoTrackId;
! 	u_int32_t		m_encodedVideoFrameNum;
  
  	MP4TrackId		m_rawAudioTrackId;
! 	u_int32_t		m_rawAudioTimeScale;
! 	u_int32_t		m_rawAudioFrameNum;
  	Timestamp		m_rawAudioStartTimestamp;
  	Duration		m_rawAudioDuration;
  
  	MP4TrackId		m_encodedAudioTrackId;
! 	u_int32_t		m_encodedAudioTimeScale;
! 	u_int32_t		m_encodedAudioFrameNum;
  	Timestamp		m_encodedAudioStartTimestamp;
  	Duration		m_encodedAudioDuration;
  };
--- 57,81 ----
  
  	u_int32_t		m_movieTimeScale;
  	u_int32_t		m_videoTimeScale;
+ 	u_int32_t		m_audioTimeScale;
+ 	Timestamp		m_movieStartTimestamp;
+ 	u_int32_t		m_audioGapThresholdInSamples;
  
  	MP4TrackId		m_rawVideoTrackId;
! 	u_int32_t		m_rawVideoFrameNumber;
! 	Timestamp		m_rawVideoStartTimestamp;
  
  	MP4TrackId		m_encodedVideoTrackId;
! 	u_int32_t		m_encodedVideoFrameNumber;
! 	Timestamp		m_encodedVideoStartTimestamp;
  
  	MP4TrackId		m_rawAudioTrackId;
! 	u_int32_t		m_rawAudioFrameNumber;
  	Timestamp		m_rawAudioStartTimestamp;
  	Duration		m_rawAudioDuration;
  
  	MP4TrackId		m_encodedAudioTrackId;
! 	u_int32_t		m_encodedAudioFrameNumber;
  	Timestamp		m_encodedAudioStartTimestamp;
  	Duration		m_encodedAudioDuration;
  };
Index: server/mp4live/media_source.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/media_source.cpp,v
retrieving revision 1.20
retrieving revision 1.25
diff -c -w -r1.20 -r1.25
*** server/mp4live/media_source.cpp	2002/06/05 23:56:18	1.20
--- server/mp4live/media_source.cpp	2002/08/06 23:43:03	1.25
***************
*** 40,46 ****
  	m_source = false;
  	m_sourceVideo = false;
  	m_sourceAudio = false;
! 	m_maxAheadDuration = TimestampTicks / 2 ;	// 500 msec
  
  	m_videoSource = this;
  	m_videoSrcYImage = NULL;
--- 40,46 ----
  	m_source = false;
  	m_sourceVideo = false;
  	m_sourceAudio = false;
! 	m_maxAheadDuration = TimestampTicks / 20 ;	// 50 msec
  
  	m_videoSource = this;
  	m_videoSrcYImage = NULL;
***************
*** 179,203 ****
  	return 0;
  }
  
- // slow down non-realtime sources, i.e. files
- // if any of the sinks require real-time semantics, i.e. RTP/UDP
- void CMediaSource::PaceSource()
- {
- 	if (m_sourceRealTime || !m_sinkRealTime) {
- 		return;
- 	}
- 
- 	Duration realDuration =
- 		GetTimestamp() - m_startTimestamp;
- 
- 	Duration aheadDuration =
- 		GetElapsedDuration() - realDuration;
- 
- 	if (aheadDuration >= m_maxAheadDuration) {
- 		SDL_Delay((aheadDuration - (m_maxAheadDuration / 2)) / 1000);
- 	}
- }
- 
  void CMediaSource::ForwardFrame(CMediaFrame* pFrame)
  {
  	if (SDL_LockMutex(m_pSinksMutex) == -1) {
--- 179,184 ----
***************
*** 380,391 ****
  	u_int16_t uvStride,
  	Timestamp srcFrameTimestamp)
  {
! 	if (m_videoSrcFrameNumber == 0 && m_audioSrcFrameNumber == 0) {
! 		m_startTimestamp = srcFrameTimestamp;
  	}
  
  	m_videoSrcFrameNumber++;
! 	m_videoSrcElapsedDuration = srcFrameTimestamp - m_startTimestamp;
  
  	// drop src frames as needed to match target frame rate
  	if (m_videoDstElapsedDuration > m_videoSrcElapsedDuration) {
--- 361,375 ----
  	u_int16_t uvStride,
  	Timestamp srcFrameTimestamp)
  {
! 	if (m_videoSrcFrameNumber == 0) {
! 		if (m_audioSrcFrameNumber == 0) {
! 			m_startTimestamp = GetTimestamp();
! 		}
! 		m_videoStartTimestamp = srcFrameTimestamp;
  	}
  
  	m_videoSrcFrameNumber++;
! 	m_videoSrcElapsedDuration = srcFrameTimestamp - m_videoStartTimestamp;
  
  	// drop src frames as needed to match target frame rate
  	if (m_videoDstElapsedDuration > m_videoSrcElapsedDuration) {
***************
*** 491,497 ****
  	}
  
  	Timestamp dstPrevFrameTimestamp =
! 		m_startTimestamp + m_videoDstElapsedDuration;
  
  	// calculate previous frame duration
  	Duration dstPrevFrameDuration = m_videoDstFrameDuration;
--- 475,481 ----
  	}
  
  	Timestamp dstPrevFrameTimestamp =
! 		m_videoStartTimestamp + m_videoDstElapsedDuration;
  
  	// calculate previous frame duration
  	Duration dstPrevFrameDuration = m_videoDstFrameDuration;
***************
*** 769,780 ****
  	Timestamp srcFrameTimestamp,
  	bool resync)
  {
! 	if (m_videoSrcFrameNumber == 0 && m_audioSrcFrameNumber == 0) {
! 		m_startTimestamp = srcFrameTimestamp;
  	}
  
  	m_audioSrcFrameNumber++;
! 	m_audioSrcElapsedDuration = srcFrameTimestamp - m_startTimestamp;
  
  	if (resync) {
  		// flush preEncodingBuffer
--- 753,767 ----
  	Timestamp srcFrameTimestamp,
  	bool resync)
  {
! 	if (m_audioSrcFrameNumber == 0) {
! 		if (m_videoSrcFrameNumber == 0) {
! 			m_startTimestamp = GetTimestamp();
  		}
+ 		m_audioStartTimestamp = srcFrameTimestamp;
+ 	}
  
  	m_audioSrcFrameNumber++;
! 	m_audioSrcElapsedDuration = srcFrameTimestamp - m_audioStartTimestamp;
  
  	if (resync) {
  		// flush preEncodingBuffer
***************
*** 822,828 ****
  
  	if (pcmBuffered) {
  		u_int32_t samplesAvailable =
! 			DstBytesToSamples(m_audioPreEncodingBufferLength);
  
  		// not enough samples collected yet to call encode or forward
  		if (samplesAvailable < m_audioDstSamplesPerFrame) {
--- 809,815 ----
  
  	if (pcmBuffered) {
  		u_int32_t samplesAvailable =
! 			SrcBytesToSamples(m_audioPreEncodingBufferLength);
  
  		// not enough samples collected yet to call encode or forward
  		if (samplesAvailable < m_audioDstSamplesPerFrame) {
***************
*** 833,839 ****
  		pcmData = 
  			&m_audioPreEncodingBuffer[0];
  		pcmDataLength = 
! 			DstSamplesToBytes(m_audioDstSamplesPerFrame);
  	}
  
  	// encode audio frame
--- 820,826 ----
  		pcmData = 
  			&m_audioPreEncodingBuffer[0];
  		pcmDataLength = 
! 			SrcSamplesToBytes(m_audioDstSamplesPerFrame);
  	}
  
  	// encode audio frame
***************
*** 842,848 ****
  		Timestamp encodingStartTimestamp = GetTimestamp();
  
  		bool rc = m_audioEncoder->EncodeSamples(
! 			(u_int16_t*)pcmData, pcmDataLength);
  
  		if (!rc) {
  			debug_message("failed to encode audio");
--- 829,837 ----
  		Timestamp encodingStartTimestamp = GetTimestamp();
  
  		bool rc = m_audioEncoder->EncodeSamples(
! 			(u_int16_t*)pcmData, 
! 			pcmDataLength,
! 			m_audioSrcChannels);
  
  		if (!rc) {
  			debug_message("failed to encode audio");
***************
*** 852,858 ****
  		Duration encodingTime =
  			(GetTimestamp() - encodingStartTimestamp);
  
! 		if (m_sourceRealTime) {
  			Duration drift = encodingTime 
  				- DstSamplesToTicks(DstBytesToSamples(pcmDataLength));
  
--- 841,847 ----
  		Duration encodingTime =
  			(GetTimestamp() - encodingStartTimestamp);
  
! 		if (m_sourceRealTime && m_videoSource) {
  			Duration drift = encodingTime 
  				- DstSamplesToTicks(DstBytesToSamples(pcmDataLength));
  
***************
*** 865,871 ****
  		u_int32_t forwardedFrames;
  
  		ForwardEncodedAudioFrames(
! 			m_startTimestamp 
  				+ DstSamplesToTicks(m_audioDstSampleNumber),
  			&forwardedSamples,
  			&forwardedFrames);
--- 854,860 ----
  		u_int32_t forwardedFrames;
  
  		ForwardEncodedAudioFrames(
! 			m_audioStartTimestamp 
  				+ DstSamplesToTicks(m_audioDstSampleNumber),
  			&forwardedSamples,
  			&forwardedFrames);
***************
*** 893,899 ****
  				CMediaFrame::PcmAudioFrame, 
  				pcmForwardedData, 
  				pcmDataLength,
! 				m_startTimestamp 
  					+ DstSamplesToTicks(m_audioDstRawSampleNumber),
  				DstBytesToSamples(pcmDataLength),
  				m_audioDstSampleRate);
--- 882,888 ----
  				CMediaFrame::PcmAudioFrame, 
  				pcmForwardedData, 
  				pcmDataLength,
! 				m_audioStartTimestamp 
  					+ DstSamplesToTicks(m_audioDstRawSampleNumber),
  				DstBytesToSamples(pcmDataLength),
  				m_audioDstSampleRate);
***************
*** 1091,1103 ****
  		// flush remaining output from audio encoder
  		// and forward it to sinks
  
! 		m_audioEncoder->EncodeSamples(NULL, 0);
  
  		u_int32_t forwardedSamples;
  		u_int32_t forwardedFrames;
  
  		ForwardEncodedAudioFrames(
! 			m_startTimestamp
  				+ DstSamplesToTicks(m_audioDstSampleNumber),
  			&forwardedSamples,
  			&forwardedFrames);
--- 1080,1092 ----
  		// flush remaining output from audio encoder
  		// and forward it to sinks
  
! 		m_audioEncoder->EncodeSamples(NULL, 0, m_audioSrcChannels);
  
  		u_int32_t forwardedSamples;
  		u_int32_t forwardedFrames;
  
  		ForwardEncodedAudioFrames(
! 			m_audioStartTimestamp
  				+ DstSamplesToTicks(m_audioDstSampleNumber),
  			&forwardedSamples,
  			&forwardedFrames);
Index: server/mp4live/media_source.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/media_source.h,v
retrieving revision 1.12
retrieving revision 1.14
diff -c -w -r1.12 -r1.14
*** server/mp4live/media_source.h	2002/06/05 20:56:18	1.12
--- server/mp4live/media_source.h	2002/08/06 23:43:03	1.14
***************
*** 100,107 ****
  		return true;
  	}
  
- 	void PaceSource();
- 
  	void ForwardFrame(CMediaFrame* pFrame);
  
  	void DoStopSource();
--- 100,105 ----
***************
*** 262,267 ****
--- 260,266 ----
  	bool			m_videoWantKeyFrame;
  
  	// video timing info
+ 	Timestamp		m_videoStartTimestamp;
  	u_int32_t		m_videoSkippedFrames;
  	Duration		m_videoEncodingDrift;
  	Duration		m_videoEncodingMaxDrift;
***************
*** 307,312 ****
--- 306,312 ----
  	CAudioEncoder*	m_audioEncoder;
  
  	// audio timing info
+ 	Timestamp		m_audioStartTimestamp;
  	Duration		m_audioSrcElapsedDuration;
  	Duration		m_audioDstElapsedDuration;
  };
Index: server/mp4live/mp4live_config.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/mp4live_config.cpp,v
retrieving revision 1.11
retrieving revision 1.14
diff -c -w -r1.11 -r1.14
*** server/mp4live/mp4live_config.cpp	2002/06/03 18:35:02	1.11
--- server/mp4live/mp4live_config.cpp	2002/08/14 01:04:58	1.14
***************
*** 59,65 ****
  	UpdateRecord();
  }
  
! void CLiveConfig::UpdateFileHistory(char* fileName)
  {
  	u_int8_t i;
  	u_int8_t end = NUM_FILE_HISTORY - 1;
--- 59,65 ----
  	UpdateRecord();
  }
  
! void CLiveConfig::UpdateFileHistory(const char* fileName)
  {
  	u_int8_t i;
  	u_int8_t end = NUM_FILE_HISTORY - 1;
***************
*** 89,98 ****
  		|| (GetBoolValue(CONFIG_RECORD_ENABLE)
  			&& GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO));
  
! 	CalculateVideoFrameSize(this);
  	GenerateMpeg4VideoConfig(this);
  }
  
  void CLiveConfig::UpdateAudio() 
  {
  	m_audioEncode =
--- 89,134 ----
  		|| (GetBoolValue(CONFIG_RECORD_ENABLE)
  			&& GetBoolValue(CONFIG_RECORD_ENCODED_VIDEO));
  
! 	CalculateVideoFrameSize();
! 
  	GenerateMpeg4VideoConfig(this);
  }
  
+ void CLiveConfig::CalculateVideoFrameSize()
+ {
+ 	u_int16_t frameHeight;
+ 	float aspectRatio = GetFloatValue(CONFIG_VIDEO_ASPECT_RATIO);
+ 
+ 	// crop video to appropriate aspect ratio modulo 16 pixels
+ 	if ((aspectRatio - VIDEO_STD_ASPECT_RATIO) < 0.1) {
+ 		frameHeight = GetIntegerValue(CONFIG_VIDEO_RAW_HEIGHT);
+ 	} else {
+ 		frameHeight = (u_int16_t)(
+ 			(float)GetIntegerValue(CONFIG_VIDEO_RAW_WIDTH) 
+ 			/ aspectRatio);
+ 
+ 		if ((frameHeight % 16) != 0) {
+ 			frameHeight += 16 - (frameHeight % 16);
+ 		}
+ 
+ 		if (frameHeight > GetIntegerValue(CONFIG_VIDEO_RAW_HEIGHT)) {
+ 			// OPTION might be better to insert black lines 
+ 			// to pad image but for now we crop down
+ 			frameHeight = GetIntegerValue(CONFIG_VIDEO_RAW_HEIGHT);
+ 			if ((frameHeight % 16) != 0) {
+ 				frameHeight -= (frameHeight % 16);
+ 			}
+ 		}
+ 	}
+ 
+ 	m_videoWidth = GetIntegerValue(CONFIG_VIDEO_RAW_WIDTH);
+ 	m_videoHeight = frameHeight;
+ 
+ 	m_ySize = m_videoWidth * m_videoHeight;
+ 	m_uvSize = m_ySize / 4;
+ 	m_yuvSize = (m_ySize * 3) / 2;
+ }
+ 
  void CLiveConfig::UpdateAudio() 
  {
  	m_audioEncode =
***************
*** 170,174 ****
--- 206,226 ----
  		GetStringValue(CONFIG_AUDIO_SOURCE_TYPE);
  
  	return !strcasecmp(sourceType, AUDIO_SOURCE_OSS);
+ }
+ 
+ bool CLiveConfig::IsFileVideoSource()
+ {
+ 	const char *sourceType =
+ 		GetStringValue(CONFIG_VIDEO_SOURCE_TYPE);
+ 
+ 	return !strcasecmp(sourceType, FILE_SOURCE);
+ }
+ 
+ bool CLiveConfig::IsFileAudioSource()
+ {
+ 	const char *sourceType =
+ 		GetStringValue(CONFIG_AUDIO_SOURCE_TYPE);
+ 
+ 	return !strcasecmp(sourceType, FILE_SOURCE);
  }
  
Index: server/mp4live/mp4live_config.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/mp4live_config.h,v
retrieving revision 1.27
retrieving revision 1.30
diff -c -w -r1.27 -r1.30
*** server/mp4live/mp4live_config.h	2002/07/15 18:01:52	1.27
--- server/mp4live/mp4live_config.h	2002/08/14 01:04:58	1.30
***************
*** 79,85 ****
  class CLiveConfig;
  
  // some configuration utility routines
- void CalculateVideoFrameSize(CLiveConfig* pConfig);
  void GenerateMpeg4VideoConfig(CLiveConfig* pConfig);
  bool GenerateSdpFile(CLiveConfig* pConfig);
  
--- 79,84 ----
***************
*** 407,420 ****
  
  	// recalculate derived values
  	void Update();
! 	void UpdateFileHistory(char* fileName);
  	void UpdateVideo();
  	void UpdateAudio();
  	void UpdateRecord();
  
  	bool IsOneSource();
  	bool IsCaptureVideoSource();
  	bool IsCaptureAudioSource();
  
  	bool SourceRawVideo() {
  		return (GetBoolValue(CONFIG_VIDEO_RAW_PREVIEW)
--- 406,422 ----
  
  	// recalculate derived values
  	void Update();
! 	void UpdateFileHistory(const char* fileName);
  	void UpdateVideo();
+ 	void CalculateVideoFrameSize();
  	void UpdateAudio();
  	void UpdateRecord();
  
  	bool IsOneSource();
  	bool IsCaptureVideoSource();
  	bool IsCaptureAudioSource();
+ 	bool IsFileVideoSource();
+ 	bool IsFileAudioSource();
  
  	bool SourceRawVideo() {
  		return (GetBoolValue(CONFIG_VIDEO_RAW_PREVIEW)
Index: server/mp4live/video_v4l_source.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/video_v4l_source.cpp,v
retrieving revision 1.10
retrieving revision 1.11
diff -c -w -r1.10 -r1.11
*** server/mp4live/video_v4l_source.cpp	2002/06/05 22:38:40	1.10
--- server/mp4live/video_v4l_source.cpp	2002/07/16 23:45:33	1.11
***************
*** 115,121 ****
  		return false;
  	}
  
! 	CalculateVideoFrameSize(m_pConfig);
  
  	InitVideo(
  		(m_pConfig->m_videoNeedRgbToYuv ?
--- 115,121 ----
  		return false;
  	}
  
! 	m_pConfig->CalculateVideoFrameSize();
  
  	InitVideo(
  		(m_pConfig->m_videoNeedRgbToYuv ?
***************
*** 341,381 ****
  				m_pConfig->m_videoCapabilities->m_deviceName);
  		}
  	}
- }
- 
- void CalculateVideoFrameSize(CLiveConfig* pConfig)
- {
- 	u_int16_t frameHeight;
- 	float aspectRatio = pConfig->GetFloatValue(CONFIG_VIDEO_ASPECT_RATIO);
- 
- 	// crop video to appropriate aspect ratio modulo 16 pixels
- 	if ((aspectRatio - VIDEO_STD_ASPECT_RATIO) < 0.1) {
- 		frameHeight = pConfig->GetIntegerValue(CONFIG_VIDEO_RAW_HEIGHT);
- 	} else {
- 		frameHeight = (u_int16_t)(
- 			(float)pConfig->GetIntegerValue(CONFIG_VIDEO_RAW_WIDTH) 
- 			/ aspectRatio);
- 
- 		if ((frameHeight % 16) != 0) {
- 			frameHeight += 16 - (frameHeight % 16);
- 		}
- 
- 		if (frameHeight > pConfig->GetIntegerValue(CONFIG_VIDEO_RAW_HEIGHT)) {
- 			// OPTION might be better to insert black lines 
- 			// to pad image but for now we crop down
- 			frameHeight = pConfig->GetIntegerValue(CONFIG_VIDEO_RAW_HEIGHT);
- 			if ((frameHeight % 16) != 0) {
- 				frameHeight -= (frameHeight % 16);
- 			}
- 		}
- 	}
- 
- 	pConfig->m_videoWidth = pConfig->GetIntegerValue(CONFIG_VIDEO_RAW_WIDTH);
- 	pConfig->m_videoHeight = frameHeight;
- 
- 	pConfig->m_ySize = pConfig->m_videoWidth * pConfig->m_videoHeight;
- 	pConfig->m_uvSize = pConfig->m_ySize / 4;
- 	pConfig->m_yuvSize = (pConfig->m_ySize * 3) / 2;
  }
  
  int8_t CV4LVideoSource::AcquireFrame(void)
--- 341,346 ----
Index: server/mp4live/video_v4l_source.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/video_v4l_source.h,v
retrieving revision 1.7
retrieving revision 1.9
diff -c -w -r1.7 -r1.9
*** server/mp4live/video_v4l_source.h	2002/06/03 18:35:02	1.7
--- server/mp4live/video_v4l_source.h	2002/08/14 01:04:58	1.9
***************
*** 30,37 ****
  #include "media_source.h"
  #include "video_encoder.h"
  
- void CalculateVideoFrameSize(CLiveConfig* pConfig);
- 
  class CV4LVideoSource : public CMediaSource {
  public:
  	CV4LVideoSource() : CMediaSource() {
--- 30,35 ----
***************
*** 86,92 ****
  
  class CVideoCapabilities {
  public:
! 	CVideoCapabilities(char* deviceName) {
  		m_deviceName = stralloc(deviceName);
  		m_canOpen = false;
  		m_canCapture = false;
--- 84,90 ----
  
  class CVideoCapabilities {
  public:
! 	CVideoCapabilities(const char* deviceName) {
  		m_deviceName = stralloc(deviceName);
  		m_canOpen = false;
  		m_canCapture = false;
Index: server/mp4live/video_xvid.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/video_xvid.cpp,v
retrieving revision 1.11
retrieving revision 1.12
diff -c -w -r1.11 -r1.12
*** server/mp4live/video_xvid.cpp	2002/06/03 18:35:02	1.11
--- server/mp4live/video_xvid.cpp	2002/07/23 18:50:07	1.12
***************
*** 48,56 ****
  
  	xvidEncParams.width = m_pConfig->m_videoWidth;
  	xvidEncParams.height = m_pConfig->m_videoHeight;
! 	xvidEncParams.fincr = 1001;
  	xvidEncParams.fbase = 
! 		(int)(1001 * m_pConfig->GetFloatValue(CONFIG_VIDEO_FRAME_RATE) + 0.5);
  	xvidEncParams.bitrate = 
  		m_pConfig->GetIntegerValue(CONFIG_VIDEO_BIT_RATE) * 1000;
  	xvidEncParams.rc_buffersize = 16;
--- 48,56 ----
  
  	xvidEncParams.width = m_pConfig->m_videoWidth;
  	xvidEncParams.height = m_pConfig->m_videoHeight;
! 	xvidEncParams.fincr = 1;
  	xvidEncParams.fbase = 
! 		(int)(m_pConfig->GetFloatValue(CONFIG_VIDEO_FRAME_RATE) + 0.5);
  	xvidEncParams.bitrate = 
  		m_pConfig->GetIntegerValue(CONFIG_VIDEO_BIT_RATE) * 1000;
  	xvidEncParams.rc_buffersize = 16;
Index: server/mp4live/gui/audio_dialog.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/gui/audio_dialog.cpp,v
retrieving revision 1.16
retrieving revision 1.17
diff -c -w -r1.16 -r1.17
*** server/mp4live/gui/audio_dialog.cpp	2002/06/03 18:35:02	1.16
--- server/mp4live/gui/audio_dialog.cpp	2002/08/14 01:04:58	1.17
***************
*** 135,141 ****
  
  static void SourceOssDevice()
  {
! 	char *newSourceName =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	// don't probe the already open device!
--- 135,141 ----
  
  static void SourceOssDevice()
  {
! 	const gchar *newSourceName =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	// don't probe the already open device!
***************
*** 170,176 ****
  
  static void ChangeSource()
  {
! 	char* new_source_name =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	if (!strcmp(new_source_name, source_name)) {
--- 170,176 ----
  
  static void ChangeSource()
  {
! 	const gchar* new_source_name =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	if (!strcmp(new_source_name, source_name)) {
Index: server/mp4live/gui/file_utils.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/gui/file_utils.cpp,v
retrieving revision 1.5
retrieving revision 1.7
diff -c -w -r1.5 -r1.7
*** server/mp4live/gui/file_utils.cpp	2002/06/03 18:35:02	1.5
--- server/mp4live/gui/file_utils.cpp	2002/08/14 01:04:58	1.7
***************
*** 137,143 ****
  		|| !strcmp(ext3, ".vob");
  }
  
! int32_t Mp4FileDefaultAudio(char* fileName)
  {
  	MP4FileHandle mp4File = MP4Read(fileName);
  
--- 137,143 ----
  		|| !strcmp(ext3, ".vob");
  }
  
! int32_t Mp4FileDefaultAudio(const char* fileName)
  {
  	MP4FileHandle mp4File = MP4Read(fileName);
  
***************
*** 156,162 ****
  	return trackId;
  }
  
! int32_t Mpeg2FileDefaultAudio(char* fileName)
  {
  	mpeg3_t* mpeg2File = mpeg3_open(fileName);
  
--- 156,162 ----
  	return trackId;
  }
  
! int32_t Mpeg2FileDefaultAudio(const char* fileName)
  {
  	mpeg3_t* mpeg2File = mpeg3_open(fileName);
  
***************
*** 174,180 ****
  	return 0; 
  }
  
! int32_t FileDefaultAudio(char* fileName)
  {
  	if (IsMp4File(fileName)) {
  		return Mp4FileDefaultAudio(fileName);
--- 174,180 ----
  	return 0; 
  }
  
! int32_t FileDefaultAudio(const char* fileName)
  {
  	if (IsMp4File(fileName)) {
  		return Mp4FileDefaultAudio(fileName);
***************
*** 196,202 ****
  static GtkWidget* CreateNullTrackMenu(
  	GtkWidget* menu,
  	char type,
! 	char* source,
  	u_int32_t* pIndex,
  	u_int32_t* pNumber,
  	u_int32_t** ppValues)
--- 196,202 ----
  static GtkWidget* CreateNullTrackMenu(
  	GtkWidget* menu,
  	char type,
! 	const char* source,
  	u_int32_t* pIndex,
  	u_int32_t* pNumber,
  	u_int32_t** ppValues)
***************
*** 235,241 ****
  static GtkWidget* CreateMp4TrackMenu(
  	GtkWidget* menu,
  	char type,
! 	char* source,
  	u_int32_t* pIndex,
  	u_int32_t* pNumber,
  	u_int32_t** ppValues)
--- 235,241 ----
  static GtkWidget* CreateMp4TrackMenu(
  	GtkWidget* menu,
  	char type,
! 	const char* source,
  	u_int32_t* pIndex,
  	u_int32_t* pNumber,
  	u_int32_t** ppValues)
***************
*** 297,305 ****
  				case MP4_YUV12_VIDEO_TYPE:
  					trackName = "YUV12";
  					break;
! 				case MP4_H26L_VIDEO_TYPE:
! 					trackName = "H26L";
  					break;
  				}
  			
  				snprintf(buf, sizeof(buf), 
--- 297,311 ----
  				case MP4_YUV12_VIDEO_TYPE:
  					trackName = "YUV12";
  					break;
! 				case MP4_H264_VIDEO_TYPE:
! 					trackName = "H264";
  					break;
+ 				case MP4_H263_VIDEO_TYPE:
+ 					trackName = "H263";
+ 					break;
+ 				case MP4_H261_VIDEO_TYPE:
+ 					trackName = "H261";
+ 					break;
  				}
  			
  				snprintf(buf, sizeof(buf), 
***************
*** 335,340 ****
--- 341,352 ----
  				case MP4_VORBIS_AUDIO_TYPE:
  					trackName = "Ogg Vorbis";
  					break;
+ 				case MP4_ALAW_AUDIO_TYPE:
+ 					trackName = "G711 aLaw";
+ 					break;
+ 				case MP4_ULAW_AUDIO_TYPE:
+ 					trackName = "G711 uLaw";
+ 					break;
  				}
  
  				snprintf(buf, sizeof(buf), 
***************
*** 376,382 ****
  static GtkWidget* CreateMpeg2TrackMenu(
  	GtkWidget* menu,
  	char type,
! 	char* source,
  	u_int32_t* pIndex,
  	u_int32_t* pNumber,
  	u_int32_t** ppValues)
--- 388,394 ----
  static GtkWidget* CreateMpeg2TrackMenu(
  	GtkWidget* menu,
  	char type,
! 	const char* source,
  	u_int32_t* pIndex,
  	u_int32_t* pNumber,
  	u_int32_t** ppValues)
***************
*** 461,467 ****
  GtkWidget* CreateTrackMenu(
  	GtkWidget* menu,
  	char type, 
! 	char* source,
  	u_int32_t* pMenuIndex,
  	u_int32_t* pMenuNumber,
  	u_int32_t** ppMenuValues)
--- 473,479 ----
  GtkWidget* CreateTrackMenu(
  	GtkWidget* menu,
  	char type, 
! 	const char* source,
  	u_int32_t* pMenuIndex,
  	u_int32_t* pMenuNumber,
  	u_int32_t** ppMenuValues)
Index: server/mp4live/gui/file_utils.h
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/gui/file_utils.h,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -w -r1.3 -r1.4
*** server/mp4live/gui/file_utils.h	2002/06/03 18:35:02	1.3
--- server/mp4live/gui/file_utils.h	2002/08/14 01:04:58	1.4
***************
*** 32,38 ****
  GtkWidget* CreateTrackMenu(
  	GtkWidget* menu,
  	char type, 
! 	char* source,
  	u_int32_t* pMenuIndex,
  	u_int32_t* pMenuNumber,
  	u_int32_t** ppMenuValues);
--- 32,38 ----
  GtkWidget* CreateTrackMenu(
  	GtkWidget* menu,
  	char type, 
! 	const char* source,
  	u_int32_t* pMenuIndex,
  	u_int32_t* pMenuNumber,
  	u_int32_t** ppMenuValues);
***************
*** 42,47 ****
  bool IsMp4File(const char* name);
  bool IsMpeg2File(const char* name);
  
! int32_t FileDefaultAudio(char* fileName);
  
  #endif /* __FILE_UTILS_INCLUDED__ */
--- 42,47 ----
  bool IsMp4File(const char* name);
  bool IsMpeg2File(const char* name);
  
! int32_t FileDefaultAudio(const char* fileName);
  
  #endif /* __FILE_UTILS_INCLUDED__ */
Index: server/mp4live/gui/gui_main.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/gui/gui_main.cpp,v
retrieving revision 1.30
retrieving revision 1.33
diff -c -w -r1.30 -r1.33
*** server/mp4live/gui/gui_main.cpp	2002/06/03 22:06:42	1.30
--- server/mp4live/gui/gui_main.cpp	2002/09/03 20:51:20	1.33
***************
*** 75,84 ****
  static GtkWidget *save_config_button;
  
  static u_int16_t durationUnitsValues[] = {
! 	1, 60, 3600
  };
  static char* durationUnitsNames[] = {
! 	"Seconds", "Minutes", "Hours"
  };
  static u_int8_t durationUnitsIndex = 1;
  
--- 75,84 ----
  static GtkWidget *save_config_button;
  
  static u_int16_t durationUnitsValues[] = {
! 	1, 60, 3600, 3600*24, 3600*24*365
  };
  static char* durationUnitsNames[] = {
! 	"Seconds", "Minutes", "Hours", "Days", "Years"
  };
  static u_int8_t durationUnitsIndex = 1;
  
***************
*** 613,619 ****
  		gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(duration_spinner))
  		* durationUnitsValues[durationUnitsIndex] * TimestampTicks;
  
! 	if (!MyConfig->IsCaptureVideoSource() && !MyConfig->IsCaptureAudioSource()
  	  && !MyConfig->GetBoolValue(CONFIG_RTP_ENABLE)) {
  		// no real time constraints
  		StopTime = 0;
--- 613,619 ----
  		gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(duration_spinner))
  		* durationUnitsValues[durationUnitsIndex] * TimestampTicks;
  
! 	if (MyConfig->IsFileVideoSource() && MyConfig->IsFileAudioSource()
  	  && !MyConfig->GetBoolValue(CONFIG_RTP_ENABLE)) {
  		// no real time constraints
  		StopTime = 0;
***************
*** 691,697 ****
  {
  	AVFlow->StopVideoPreview();
  
! 	char* configFileName =
  		gtk_entry_get_text(GTK_ENTRY(config_file_entry));
  
  	MyConfig->ReadFromFile(configFileName);
--- 691,697 ----
  {
  	AVFlow->StopVideoPreview();
  
! 	const gchar* configFileName =
  		gtk_entry_get_text(GTK_ENTRY(config_file_entry));
  
  	MyConfig->ReadFromFile(configFileName);
***************
*** 715,721 ****
  
  static void on_save_config_button (GtkWidget *widget, gpointer *data)
  {
! 	char* configFileName =
  		gtk_entry_get_text(GTK_ENTRY(config_file_entry));
  
  	MyConfig->WriteToFile(configFileName);
--- 715,721 ----
  
  static void on_save_config_button (GtkWidget *widget, gpointer *data)
  {
! 	const gchar* configFileName =
  		gtk_entry_get_text(GTK_ENTRY(config_file_entry));
  
  	MyConfig->WriteToFile(configFileName);
Index: server/mp4live/gui/gui_utils.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/gui/gui_utils.cpp,v
retrieving revision 1.3
retrieving revision 1.4
diff -c -w -r1.3 -r1.4
*** server/mp4live/gui/gui_utils.cpp	2002/03/22 18:26:50	1.3
--- server/mp4live/gui/gui_utils.cpp	2002/08/14 01:04:58	1.4
***************
*** 129,135 ****
  				  "activate", 
  				  accel_group,
  				  key, 
! 				  modifier,
  				  GTK_ACCEL_VISIBLE);
      }
  
--- 129,135 ----
  				  "activate", 
  				  accel_group,
  				  key, 
! 				  (GdkModifierType)modifier,
  				  GTK_ACCEL_VISIBLE);
      }
  
Index: server/mp4live/gui/video_dialog.cpp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/mp4live/gui/video_dialog.cpp,v
retrieving revision 1.21
retrieving revision 1.22
diff -c -w -r1.21 -r1.22
*** server/mp4live/gui/video_dialog.cpp	2002/06/03 18:35:02	1.21
--- server/mp4live/gui/video_dialog.cpp	2002/08/14 01:04:58	1.22
***************
*** 216,222 ****
  
  static void SourceV4LDevice()
  {
! 	char *newSourceName =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	// don't probe the already open device!
--- 216,222 ----
  
  static void SourceV4LDevice()
  {
! 	const gchar *newSourceName =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	// don't probe the already open device!
***************
*** 268,274 ****
  
  static void ChangeSource()
  {
! 	char* new_source_name =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	if (!strcmp(new_source_name, source_name)) {
--- 268,274 ----
  
  static void ChangeSource()
  {
! 	const gchar* new_source_name =
  		gtk_entry_get_text(GTK_ENTRY(source_entry));
  
  	if (!strcmp(new_source_name, source_name)) {
***************
*** 592,598 ****
  
  	// extract channel index out of combo (not so simple)
  	GtkWidget* entry = GTK_COMBO(channel_combo)->entry;
! 	char* channelName = gtk_entry_get_text(GTK_ENTRY(entry));
  	struct CHANNEL_LIST* pChannelList =
  		ListOfChannelLists[signalIndex];
  	for (int i = 0; i < pChannelList[channelListIndex].count; i++) {
--- 592,598 ----
  
  	// extract channel index out of combo (not so simple)
  	GtkWidget* entry = GTK_COMBO(channel_combo)->entry;
! 	const gchar* channelName = gtk_entry_get_text(GTK_ENTRY(entry));
  	struct CHANNEL_LIST* pChannelList =
  		ListOfChannelLists[signalIndex];
  	for (int i = 0; i < pChannelList[channelListIndex].count; i++) {
Index: server/util/avidump/avidump.c
===================================================================
RCS file: /vws/pan/mpeg4ip/server/util/avidump/avidump.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
*** server/util/avidump/avidump.c	2001/12/28 19:05:15	1.1
--- server/util/avidump/avidump.c	2002/07/19 18:50:12	1.2
***************
*** 45,50 ****
--- 45,51 ----
    {"YAMAHA_ADPCM", 0x0020},
    {"DSP_TRUESPEECH", 0x0022},
    {"GSM610", 0x0031},
+   {"MP3", 0x0055},
    {"IBMMULAW", 0x0101},
    {"IBMALAW", 0x0102},
    {"IBMADPCM", 0x0103},
Index: server/util/xvidenc/xvidenc.c
===================================================================
RCS file: /vws/pan/mpeg4ip/server/util/xvidenc/xvidenc.c,v
retrieving revision 1.2
retrieving revision 1.4
diff -c -w -r1.2 -r1.4
*** server/util/xvidenc/xvidenc.c	2002/06/18 21:33:01	1.2
--- server/util/xvidenc/xvidenc.c	2002/09/03 20:48:51	1.4
***************
*** 52,57 ****
--- 52,58 ----
  	u_int frameHeight = 240;		/* --height=<uint> */
  	float frameRate = 30.0;			/* --rate=<float> */
  	u_int iFrameFrequency = 30;		/* --ifrequency=<uint> */
+ 	int short_headers = 0;                  /* --shortheaders */
  
  	/* internal variables */
  	char* rawFileName = NULL;
***************
*** 78,87 ****
  			{ "ifrequency", 1, 0, 'i' },
  			{ "rate", 1, 0, 'r' },
  			{ "width", 1, 0, 'w' },
  			{ NULL, 0, 0, 0 }
  		};
  
! 		c = getopt_long_only(argc, argv, "b:h:i:r:w:",
  			long_options, &option_index);
  
  		if (c == -1)
--- 79,89 ----
  			{ "ifrequency", 1, 0, 'i' },
  			{ "rate", 1, 0, 'r' },
  			{ "width", 1, 0, 'w' },
+ 			{ "shortheaders", 0, 0, 's' },
  			{ NULL, 0, 0, 0 }
  		};
  
! 		c = getopt_long_only(argc, argv, "b:h:i:r:w:s",
  			long_options, &option_index);
  
  		if (c == -1)
***************
*** 154,159 ****
--- 156,164 ----
  			}
  			break;
  		}
+ 		case 's':
+ 		  short_headers = 1;
+ 		  break;
  		case '?':
  			break;
  		default:
***************
*** 162,167 ****
--- 167,209 ----
  		}
  	}
  
+ 	if (short_headers) {
+ 	  switch (frameWidth) {
+ 	  case 128:
+ 	    if (frameHeight != 96) {
+ 	      fprintf(stderr, "Illegal height %d with width of 128 - must be 96\n", frameHeight);
+ 	      exit(-1);
+ 	    }
+ 	    break;
+ 	  case 176:
+ 	    if (frameHeight != 144) {
+ 	      fprintf(stderr, "Illegal height %d with width of 176 - must be 144\n", frameHeight);
+ 	      exit(-1);
+ 	    }
+ 	    break;
+ 	  case 352:
+ 	    if (frameHeight != 288) {
+ 	      fprintf(stderr, "Illegal height %d with width of 352 - must be 288\n", frameHeight);
+ 	      exit(-1);
+ 	    }
+ 	    break;
+ 	  case 704:
+ 	    if (frameHeight != 576) {
+ 	      fprintf(stderr, "Illegal height %d with width of 704 - must be 576\n", frameHeight);
+ 	      exit(-1);
+ 	    }
+ 	    break;
+ 	  case 1408:
+ 	    if (frameHeight != 1152) {
+ 	      fprintf(stderr, "Illegal height %d with width of 1408 - must be 1152\n", frameHeight);
+ 	      exit(-1);
+ 	    }
+ 	    break;
+ 	  default:
+ 	    fprintf(stderr, "Must have legal height/width for short headers\n");
+ 	    exit(-1);
+ 	  }
+ 	}
  	/* check that we have at least two non-option arguments */
  	if ((argc - optind) < 2) {
  		fprintf(stderr, 
***************
*** 235,241 ****
  	encFrame.quant = 0;
  	encFrame.intra = -1;
  	encFrame.mvs = NULL;
! 
  	startTime = time(0);
  
  	while (!feof(rawFile)) {
--- 277,286 ----
  	encFrame.quant = 0;
  	encFrame.intra = -1;
  	encFrame.mvs = NULL;
! 	encFrame.general = 0;
! 	if (short_headers) {
! 	  encFrame.general |= DEC_SHORT_HEADERS;
! 	}
  	startTime = time(0);
  
  	while (!feof(rawFile)) {
***************
*** 245,257 ****
  
  		/* read yuv data */
  		rc = fread(encFrame.image, sizeof(u_int8_t), yuvSize, rawFile);
  		if (rc == 0) {
  			break;
  		}
! 		if (rc != yuvSize) {
  			fprintf(stderr, 
  				"%s: read error %s on frame %d: %s\n",
  				progName, rawFileName, frameNumber, strerror(errno));
  			break;
  		}
  
--- 290,309 ----
  
  		/* read yuv data */
  		rc = fread(encFrame.image, sizeof(u_int8_t), yuvSize, rawFile);
+ 
  		if (rc == 0) {
  			break;
  		}
! 		if (rc == -1) {
  			fprintf(stderr, 
  				"%s: read error %s on frame %d: %s\n",
  				progName, rawFileName, frameNumber, strerror(errno));
+ 			break;
+ 		}
+ 		if (rc != yuvSize) {
+ 			fprintf(stderr, 
+ 				"%s: read error %s on frame %d: too few bytes, expected %d, got %d\n",
+ 				progName, rawFileName, frameNumber, yuvSize, rc);
  			break;
  		}
  
Index: server/util/xvidenc/xvidenc.dsp
===================================================================
RCS file: /vws/pan/mpeg4ip/server/util/xvidenc/xvidenc.dsp,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -w -r1.1 -r1.2
*** server/util/xvidenc/xvidenc.dsp	2002/05/01 21:42:44	1.1
--- server/util/xvidenc/xvidenc.dsp	2002/08/19 18:22:34	1.2
***************
*** 41,47 ****
  # PROP Intermediate_Dir "Release"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
! # ADD CPP /nologo /W3 /GX /O2 /I "..\..\..\include" /I "..\..\..\lib\xvid" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
  # ADD BASE RSC /l 0x409 /d "NDEBUG"
  # ADD RSC /l 0x409 /d "NDEBUG"
  BSC32=bscmake.exe
--- 41,47 ----
  # PROP Intermediate_Dir "Release"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
! # ADD CPP /nologo /W3 /GX /O2 /I "..\..\..\include" /I "..\..\..\lib\xvid" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "MPEG4IP" /YX /FD /c
  # ADD BASE RSC /l 0x409 /d "NDEBUG"
  # ADD RSC /l 0x409 /d "NDEBUG"
  BSC32=bscmake.exe
***************
*** 64,70 ****
  # PROP Intermediate_Dir "Debug"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
! # ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\..\..\include" /I "..\..\..\lib\xvid" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
  # ADD BASE RSC /l 0x409 /d "_DEBUG"
  # ADD RSC /l 0x409 /d "_DEBUG"
  BSC32=bscmake.exe
--- 64,70 ----
  # PROP Intermediate_Dir "Debug"
  # PROP Target_Dir ""
  # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
! # ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\..\..\include" /I "..\..\..\lib\xvid" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "MPEG4IP" /YX /FD /GZ /c
  # ADD BASE RSC /l 0x409 /d "_DEBUG"
  # ADD RSC /l 0x409 /d "_DEBUG"
  BSC32=bscmake.exe
