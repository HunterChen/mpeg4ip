.\" Automatically generated by Pod::Man version 1.02
.\" Fri Mar 23 14:57:33 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` `
.    ds C' '
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
.    .
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "SSLeay 3"
.TH SSLeay 3 "perl v5.6.0" "2001-03-20" "User Contributed Perl Documentation"
.UC
.SH "NAME"
Net::SSLeay \- Perl extension for using OpenSSL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::SSLeay, qw(get_https post_https sslcat make_headers make_form);
.Ve
.Vb 1
\&  ($page) = get_https('www.bacus.pt', 443, '/');                 # 1
.Ve
.Vb 6
\&  ($page, $response, %reply_headers)
\&         = get_https('www.bacus.pt', 443, '/',                   # 2
\&                make_headers(
\&                        'User-Agent' => 'Cryptozilla/5.0b1',
\&                        'Referer'    => 'https://www.bacus.pt'
\&                ));
.Ve
.Vb 5
\&  ($page, $result, %headers) =                                   # 2b
\&         = get_https('www.bacus.pt', 443, '/protected.html',
\&              make_headers('Authorization' =>
\&                           'Basic ' . MIME::Base64::encode("$user:$pass"))
\&              );
.Ve
.Vb 6
\&  ($page, $response, %reply_headers)
\&         = post_https('www.bacus.pt', 443, '/foo.cgi', '',       # 3
\&                make_form(
\&                        'OK'   => '1',
\&                        'name' => 'Sampo'
\&                ));
.Ve
.Vb 1
\&  $reply = sslcat($host, $port, $request);                       # 4
.Ve
.Vb 1
\&  $Net::SSLeay::trace = 2;  # 0=no debugging, 1=ciphers, 2=trace, 3=dump data
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers some high level convinience functions for accessing
web pages on \s-1SSL\s0 servers, a \fIsslcat()\fR function for writing your own
clients, and finally access to the \s-1SSL\s0 api of SSLeay package so you
can write servers or clients for more complicated applications.
.PP
For high level functions it is most convinient to import them to your
main namespace as indicated in the synopsis. Case 1 demonstrates
typical invocation of \fIget_https()\fR to fetch an \s-1HTML\s0 page from secure
server. The first argument provides host name or ip in dotted decimal
notation of the remote server to contact. Second argument is the \s-1TCP\s0
port at the remote end (your own port is picked arbitrarily from high
numbered ports as usual for \s-1TCP\s0). The third argument is the \s-1URL\s0 of the
page without the host name part. If in doubt consult \s-1HTTP\s0
specifications at <http://www.w3c.org>
.PP
Case 2 demonstrates full fledged use of get_https. As can be seen,
get_https parses the response and response headers and returns them as
a list, which can be captured in a hash for later reference. Also a
fourth argument to get_https is used to insert some additional headers
in the request. make_headers is a function that will convert a list or
hash to such headers. By default get_https supplies Host (make virtual
hosting easy) and Accept (reportedly needed by \s-1IIS\s0) headers.
.PP
Case 2b demonstrates how to get password protected page. Refer to
\&\s-1HTTP\s0 protocol specifications for further details (e.g. \s-1RFC2617\s0).
.PP
Case 3 invokes post_https to submit a \s-1HTML/CGI\s0 form to secure
server. First four arguments are equal to get_https (note that empty
string ('') is passed as header argument). The fifth argument is the
contents of the form formatted according to \s-1CGI\s0 specification. In this
case the helper function \fImake_https()\fR is used to do the formatting,
but you could pass any string. The \fIpost_https()\fR automatically adds
Content-Type and Content-Length headers to the request.
.PP
Case 4 shows the fundamental \fIsslcat()\fR function (inspired in spirit by
netcat utility :\-). Its your swiss army knife that allows you to
easily contact servers, send some data, and then get the response. You
are responsible for formatting the data and parsing the response \-
\&\fIsslcat()\fR is just a transport.
.PP
The \f(CW$trace\fR global variable can be used to control the verbosity of high
level functions. Level 0 guarantees silence, level 1 (the default)
only emits error messages.
.Sh "Convenience routines"
.IX Subsection "Convenience routines"
To be used with Low level \s-1API\s0
.PP
.Vb 5
\&    Net::SSLeay::randomize($rn_seed_file,$additional_seed);
\&    Net::SSLeay::set_server_cert_and_key($ctx, $cert_path, $key_path);
\&    $cert = Net::SSLeay::dump_peer_certificate($ssl);
\&    Net::SSLeay::ssl_write_all($ssl, $message) or die "ssl write failure";
\&    $got = Net::SSLeay::ssl_read_all($ssl) or die "ssl read failure";
.Ve
.Vb 3
\&    $got = Net::SSLeay::ssl_read_CRLF($ssl [, $max_length]);
\&    $got = Net::SSLeay::ssl_read_until($ssl [, $delimit [, $max_length]]);
\&    Net::SSLeay::ssl_write_CRLF($ssl, $message);
.Ve
\&\fIrandomize()\fR seeds the eay \s-1PRNG\s0 with /dev/urandom (see top of SSLeay.pm
for how to change or configure this) and optionally with user provided
data. It is very important to properly seed your random numbers, so
do not forget to call this. The high level \s-1API\s0 functions automatically
call \fIrandomize()\fR so it is not needed with them.
.PP
\&\fIset_server_cert_and_key()\fR takes two file names as arguments and sets
the server certificate and private key to those.
.PP
\&\fIdump_peer_certificate()\fR allows you to get plaintext description of the
certificate the peer (usually server) presented to us.
.PP
\&\fIssl_read_all()\fR and \fIssl_write_all()\fR provide true blocking semantics for
these operations (see limitation, below, for explanation). These are
much preferred to the low level \s-1API\s0 equivalents (which implement \s-1BSD\s0
blocking semantics). The message argument to \fIssl_write_all()\fR can be
reference. This is helpful to avoid unnecessary copy when writing
something big, e.g:
.PP
.Vb 2
\&    $data = 'A' x 1000000000;
\&    Net::SSLeay::ssl_write_all($ssl, \e$data) or die "ssl write failed";
.Ve
\&\fIssl_read_CRLF()\fR uses \fIssl_read_all()\fR to read in a line terminated with a
carriage return followed by a linefeed (\s-1CRLF\s0).  The \s-1CRLF\s0 is included in
the returned scalar.
.PP
\&\fIssl_read_until()\fR uses \fIssl_read_all()\fR to read from the \s-1SSL\s0 input
stream until it encounters a programmer specified delimiter.
If the delimiter is undefined, $/ is used.  If $/ is undefined,
\&\en is used.  One can optionally set a maximum length of bytes to read
from the \s-1SSL\s0 input stream.
.PP
\&\fIssl_write_CRLF()\fR writes \f(CW$message\fR and appends \s-1CRLF\s0 to the \s-1SSL\s0 output stream.
.Sh "Low level \s-1API\s0"
.IX Subsection "Low level API"
In addition to the high level functions outlined above, this module
contains straight forward access to \s-1SSL\s0 part of OpenSSL C api. Only the \s-1SSL\s0
subpart of OpenSSL is implemented (if anyone wants to implement other
parts, feel free to submit patches).
.PP
See ssl.h header from OpenSSL C distribution for list of low lever
SSLeay functions to call (to check if some function has been
implemented see directly in SSLeay.xs). The module strips SSLeay names
of the initial \*(L"\s-1SSL_\s0\*(R", generally you should use Net::SSLeay:: in
place. For example:
.PP
In C:
.PP
.Vb 1
\&        #include <ssl.h>
.Ve
.Vb 2
\&        err = SSL_set_verify (ssl, SSL_VERIFY_CLIENT_ONCE,
\&                                   &your_call_back_here);
.Ve
In perl:
.PP
.Vb 1
\&        use Net::SSLeay;
.Ve
.Vb 3
\&        $err = Net::SSLeay::set_verify ($ssl,
\&                                        &Net::SSLeay::VERIFY_CLIENT_ONCE,
\&                                        \e&your_call_back_here);
.Ve
If the function does not start by \s-1SSL_\s0 you should use the full
function name, e.g.:
.PP
.Vb 1
\&        $err = &Net::SSLeay::ERR_get_error;
.Ve
Following new functions behave in perlish way:
.PP
.Vb 4
\&        $got = Net::SSLeay::read($ssl);
\&                                    # Performs SSL_read, but returns $got
\&                                    # resized according to data received.
\&                                    # Returns undef on failure.
.Ve
.Vb 3
\&        Net::SSLeay::write($ssl, $foo) || die;
\&                                    # Performs SSL_write, but automatically
\&                                    # figures out the size of $foo
.Ve
In order to use the low level \s-1API\s0 you should start your programs with
the following encantation:
.PP
.Vb 4
\&        use Net::SSLeay qw(die_now die_if_ssl_error);
\&        Net::SSLeay::load_error_strings();
\&        Net::SSLeay::SSLeay_add_ssl_algorithms();   # Important!
\&        Net::SSLeay::randomize();
.Ve
\&\fIdie_now()\fR and \fIdie_if_ssl_error()\fR are used to conveniently print SSLeay error
stack when something goes wrong, thusly:
.PP
.Vb 2
\&        Net::SSLeay:connect($ssl) or die_now("Failed SSL connect ($!)");
\&        Net::SSLeay::write($ssl, "foo") or die_if_ssl_error("SSL write ($!)");
.Ve
You can also use \fINet::SSLeay::print_errs()\fR to dump the error stack without
exiting the program. As can be seen, your code becomes much more readable
if you import the error reporting functions to your main name space.
.PP
I can not emphasize enough the need to check error returns. Use these
functions even in most simple programs, they will reduce debugging
time greatly. Do not ask questions in mailing list without having
first sprinkled these in your code.
.Sh "Sockets"
.IX Subsection "Sockets"
Perl uses file handles for all I/O. While SSLeay has quite flexible \s-1BIO\s0
mechanism and perl has evolved PerlIO mechanism, this module still
sticks to using file descriptors. Thus to attach SSLeay to socket you
should use \fIfileno()\fR to extract the underlying file descriptor:
.PP
.Vb 1
\&    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno
.Ve
You should also use \*(L"$|=1;\*(R" to eliminate \s-1STDIO\s0 buffering so you do not
get confused if you use perl I/O functions to manipulate your socket
handle.
.PP
If you need to \fIselect\fR\|(2) on the socket, go right ahead, but be warned
that SSLeay does some internal buffering so SSL_read does not always
return data even if socket selected for reading (just keep on
selecting and trying to read). Net::SSLeay.pm is no different from the
C language OpenSSL in this respect.
.Sh "Callbacks"
.IX Subsection "Callbacks"
\&\s-1WARNING:\s0 as of 1.04 the callbacks have changed and have not been tested.
.PP
At this moment the implementation of verify_callback is crippeled in
the sense that at any given time there can be only one call back which
is shared by all \s-1SSL\s0 contexts, sessions and connections. This is
due to having to keep the reference to the perl call back in a
static variable so that the callback C glue can find it. To remove
this restriction would require either a more complex data structure
(like a hash?) in \s-1XSUB\s0 to map the call backs to their owners or,
cleaner, adding a context pointer in the \s-1SSL\s0 structure. This context would
then be passed to the C callback, which in our case would be the glue
to look up the proper Perl function from the context and call it.
.PP
\&\-\-\-\- inaccurate \-\-\-\-
The verify call back looks like this in C:
.PP
.Vb 2
\&        int (*callback)(int ok,X509 *subj_cert,X509 *issuer_cert,
\&                        int depth,int errorcode,char *arg,STACK *cert_chain)
.Ve
The corresponding Perl function should be something like this:
.PP
.Vb 7
\&        sub verify {
\&            my ($ok, $subj_cert, $issuer_cert, $depth, $errorcode,
\&                $arg, $chain) = @_;
\&            print "Verifying certificate...\en";
\&                ...
\&            return $ok;
\&        }
.Ve
It is used like this:
.PP
.Vb 1
\&        Net::SSLeay::set_verify ($ssl, Net::SSLeay::VERIFY_PEER, \e&verify);
.Ve
No other callbacks are implemented. You do not need to use any
callback for simple (i.e. normal) cases where the SSLeay built-in
verify mechanism satisfies your needs.
\&\-\-\-\- end inaccurate \-\-\-\-
.PP
If you want to use callback stuff, see examples/callback.pl! Its the
only one I am able to make work reliably.
.Sh "X509 and \s-1RAND\s0 stuff"
.IX Subsection "X509 and RAND stuff"
This module largely lacks interface to the X509 and \s-1RAND\s0 routines, but
as I was lazy and needed them, the following kludges are implemented:
.PP
.Vb 7
\&    $x509_name = Net::SSLeay::X509_get_subject_name($x509_cert);
\&    $x509_name = Net::SSLeay::X509_get_issuer_name($x509_cert);
\&    print Net::SSLeay::X509_NAME_oneline($x509_name);
\&    Net::SSLeay::RAND_seed($buf);   # Perlishly figures out buf size
\&    Net::SSLeay::RAND_cleanup();
\&    Net::SSLeay::RAND_load_file($file_name, $how_many_bytes);
\&    Net::SSLeay::RAND_write_file($file_name);
.Ve
Actually you should consider using the following helper functions:
.PP
.Vb 2
\&    print Net::SSLeay::dump_peer_certificate($ssl);
\&    Net::SSLeay::randomize();
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
One very good example is to look at the implementation of \fIsslcat()\fR in the
SSLeay.pm file.
.PP
Following is a simple SSLeay client (with too little error checking :\-(
.PP
.Vb 6
\&    #!/usr/local/bin/perl
\&    use Socket;
\&    use Net::SSLeay qw(die_now die_if_ssl_error) ;
\&    Net::SSLeay::load_error_strings();
\&    Net::SSLeay::SSLeay_add_ssl_algorithms();
\&    Net::SSLeay::randomize();
.Ve
.Vb 4
\&    ($dest_serv, $port, $msg) = @ARGV;      # Read command line
\&    $port = getservbyname ($port, 'tcp') unless $port =~ /^\ed+$/;
\&    $dest_ip = gethostbyname ($dest_serv);
\&    $dest_serv_params  = sockaddr_in($port, $dest_ip);
.Ve
.Vb 3
\&    socket  (S, &AF_INET, &SOCK_STREAM, 0)  or die "socket: $!";
\&    connect (S, $dest_serv_params)          or die "connect: $!";
\&    select  (S); $| = 1; select (STDOUT);   # Eliminate STDIO buffering
.Ve
.Vb 1
\&    # The network connection is now open, lets fire up SSL
.Ve
.Vb 7
\&    $ctx = Net::SSLeay::CTX_new() or die_now("Failed to create SSL_CTX $!");
\&    Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL)
\&         and die_if_ssl_error("ssl ctx set options");
\&    $ssl = Net::SSLeay::new($ctx) or die_now("Failed to create SSL $!");
\&    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno
\&    $res = Net::SSLeay::connect($ssl) and die_if_ssl_error("ssl connect");
\&    print "Cipher `" . Net::SSLeay::get_cipher($ssl) . "'\en";
.Ve
.Vb 1
\&    # Exchange data
.Ve
.Vb 6
\&    $res = Net::SSLeay::write($ssl, $msg);  # Perl knows how long $msg is
\&    die_if_ssl_error("ssl write");
\&    shutdown S, 1;  # Half close --> No more output, sends EOF to server
\&    $got = Net::SSLeay::read($ssl);         # Perl returns undef on failure
\&    die_if_ssl_error("ssl read");
\&    print $got;
.Ve
.Vb 3
\&    Net::SSLeay::free ($ssl);               # Tear down connection
\&    Net::SSLeay::CTX_free ($ctx);
\&    close S;
.Ve
Following is a simple SSLeay echo server (non forking):
.PP
.Vb 6
\&    #!/usr/local/bin/perl -w
\&    use Socket;
\&    use Net::SSLeay qw(die_now die_if_ssl_error);
\&    Net::SSLeay::load_error_strings();
\&    Net::SSLeay::SSLeay_add_ssl_algorithms();
\&    Net::SSLeay::randomize();
.Ve
.Vb 4
\&    $our_ip = "\e0\e0\e0\e0"; # Bind to all interfaces
\&    $port = 1235;                                                        
\&    $sockaddr_template = 'S n a4 x8';
\&    $our_serv_params = pack ($sockaddr_template, &AF_INET, $port, $our_ip);
.Ve
.Vb 6
\&    socket (S, &AF_INET, &SOCK_STREAM, 0)  or die "socket: $!";
\&    bind (S, $our_serv_params)             or die "bind:   $!";
\&    listen (S, 5)                          or die "listen: $!";
\&    $ctx = Net::SSLeay::CTX_new ()         or die_now("CTX_new ($ctx): $!");
\&    Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL)
\&         and die_if_ssl_error("ssl ctx set options");
.Ve
.Vb 7
\&    # Following will ask password unless private key is not encrypted
\&    Net::SSLeay::CTX_use_RSAPrivateKey_file ($ctx, 'plain-rsa.pem',
\&                                             &Net::SSLeay::FILETYPE_PEM);
\&    die_if_ssl_error("private key");
\&    Net::SSLeay::CTX_use_certificate_file ($ctx, 'plain-cert.pem',
\&                                           &Net::SSLeay::FILETYPE_PEM);
\&    die_if_ssl_error("certificate");
.Ve
.Vb 4
\&    while (1) {    
\&        print "Accepting connections...\en";
\&        ($addr = accept (NS, S))           or die "accept: $!";
\&        select (NS); $| = 1; select (STDOUT);  # Piping hot!
.Ve
.Vb 4
\&        ($af,$client_port,$client_ip) = unpack($sockaddr_template,$addr);
\&        @inetaddr = unpack('C4',$client_ip);
\&        print "$af connection from " .
\&            join ('.', @inetaddr) . ":$client_port\en";
.Ve
.Vb 1
\&        # We now have a network connection, lets fire up SSLeay...
.Ve
.Vb 2
\&        $ssl = Net::SSLeay::new($ctx)      or die_now("SSL_new ($ssl): $!");
\&        Net::SSLeay::set_fd($ssl, fileno(NS));
.Ve
.Vb 2
\&        $err = Net::SSLeay::accept($ssl) and die_if_ssl_error('ssl accept');
\&        print "Cipher `" . Net::SSLeay::get_cipher($ssl) . "'\en";
.Ve
.Vb 1
\&        # Connected. Exchange some data.
.Ve
.Vb 3
\&        $got = Net::SSLeay::read($ssl);     # Returns undef on fail
\&        die_if_ssl_error("ssl read");
\&        print "Got `$got' (" . length ($got) . " chars)\en";
.Ve
.Vb 2
\&        Net::SSLeay::write ($ssl, uc ($got)) or die "write: $!";
\&        die_if_ssl_error("ssl write");
.Ve
.Vb 3
\&        Net::SSLeay::free ($ssl);           # Tear down connection
\&        close NS;
\&    }
.Ve
Yet another echo server. This one runs from /etc/inetd.conf so it avoids
all the socket code overhead. Only caveat is opening rsa key file \-
it had better be without any encryption or else it will not know where
to ask for the password. Note how \s-1STDIN\s0 and \s-1STDOUT\s0 are wired to \s-1SSL\s0.
.PP
.Vb 5
\&    #!/usr/local/bin/perl
\&    # /etc/inetd.conf
\&    #    ssltst stream tcp nowait root /path/to/server.pl server.pl
\&    # /etc/services
\&    #    ssltst         1234/tcp
.Ve
.Vb 4
\&    use Net::SSLeay qw(die_now die_if_ssl_error);
\&    Net::SSLeay::load_error_strings();
\&    Net::SSLeay::SSLeay_add_ssl_algorithms();
\&    Net::SSLeay::randomize();
.Ve
.Vb 4
\&    chdir '/key/dir' or die "chdir: $!";
\&    $| = 1;  # Piping hot!
\&    open LOG, ">>/dev/console" or die "Can't open log file $!";
\&    select LOG; print "server.pl started\en";
.Ve
.Vb 4
\&    $ctx = Net::SSLeay::CTX_new()     or die_now "CTX_new ($ctx) ($!)";
\&    $ssl = Net::SSLeay::new($ctx)     or die_now "new ($ssl) ($!)";
\&    Net::SSLeay::set_options($ssl, &Net::SSLeay::OP_ALL)
\&         and die_if_ssl_error("ssl set options");
.Ve
.Vb 4
\&    # We get already open network connection from inetd, now we just
\&    # need to attach SSLeay to STDIN and STDOUT
\&    Net::SSLeay::set_rfd($ssl, fileno(STDIN));
\&    Net::SSLeay::set_wfd($ssl, fileno(STDOUT));
.Ve
.Vb 6
\&    Net::SSLeay::use_RSAPrivateKey_file ($ssl, 'plain-rsa.pem',
\&                                         &Net::SSLeay::FILETYPE_PEM);
\&    die_if_ssl_error("private key");
\&    Net::SSLeay::use_certificate_file ($ssl, 'plain-cert.pem',
\&                                       &Net::SSLeay::FILETYPE_PEM);
\&    die_if_ssl_error("certificate");
.Ve
.Vb 2
\&    Net::SSLeay::accept($ssl) and die_if_ssl_err("ssl accept: $!");
\&    print "Cipher `" . Net::SSLeay::get_cipher($ssl) . "'\en";
.Ve
.Vb 3
\&    $got = Net::SSLeay::read($ssl);
\&    die_if_ssl_error("ssl read");
\&    print "Got `$got' (" . length ($got) . " chars)\en";
.Ve
.Vb 2
\&    Net::SSLeay::write ($ssl, uc($got)) or die "write: $!";
\&    die_if_ssl_error("ssl write");
.Ve
.Vb 3
\&    Net::SSLeay::free ($ssl);         # Tear down the connection
\&    Net::SSLeay::CTX_free ($ctx);
\&    close LOG;
.Ve
There are also a number of example/test programs in the examples directory:
.PP
.Vb 11
\&    sslecho.pl   -  A simple server, not unlike the one above
\&    minicli.pl   -  Implements a client using low level SSLeay routines
\&    sslcat.pl    -  Demonstrates using high level sslcat utility function
\&    get_page.pl  -  Is a utility for getting html pages from secure servers
\&    callback.pl  -  Demonstrates certificate verification and callback usage
\&    stdio_bulk.pl       - Does SSL over Unix pipes
\&    ssl-inetd-serv.pl   - SSL server that can be invoked from inetd.conf
\&    httpd-proxy-snif.pl - Utility that allows you to see how a browser
\&                          sends https request to given server and what reply
\&                          it gets back (very educative :-)
\&    makecert.pl  -  Creates a self signed cert (does not use this module)
.Ve
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Net::SSLeay::read uses internal buffer of 32KB, thus no single read
will return more. In practice one read returns much less, usually
as much as fits in one network packet. To work around this,
you should use a loop like this:
.PP
.Vb 6
\&    $reply = '';
\&    do {
\&        $got = Net::SSLeay::read($ssl);
\&        last if print_errs('SSL_read');
\&        $reply .= $got;
\&    } while ($got);
.Ve
Although there is no built in limit in Net::SSLeay::write, the network
packet size limitation applies here as well, thus use:
.PP
.Vb 5
\&    $written = 0;
\&    do {
\&        $written .= Net::SSLeay::write($ssl, substr($message, $written));
\&        last if print_errs('SSL_write');
\&    } while ($written < length($message));
.Ve
Or alternatively you can just use the following convinence functions:
.PP
.Vb 2
\&    Net::SSLeay::ssl_write_all($ssl, $message) or die "ssl write failure";
\&    $got = Net::SSLeay::ssl_read_all($ssl) or die "ssl read failure";
.Ve
.SH "KNOWN BUGS AND CAVEATS"
.IX Header "KNOWN BUGS AND CAVEATS"
Autoloader emits
.PP
.Vb 1
\&    Argument "xxx" isn't numeric in entersub at blib/lib/Net/SSLeay.pm'
.Ve
warning if die_if_ssl_error is made autoloadable. If you figure out why,
drop me a line.
.PP
Callback set using \fISSL_set_verify()\fR does not appear to work. This may
well be eay problem (e.g. see ssl/ssl_lib.c line 1029). Try using
\&\fISSL_CTX_set_verify()\fR instead and do not be surprised if even this stops
working in future versions.
.PP
Callback and certificate verification stuff is generally too little tested.
.PP
Random numbers are not initialized randomly enough, especially if you
do not have /dev/random and/or /dev/urandom.
.PP
If you are using the low level \s-1API\s0 functions to communicate with other
\&\s-1SSL\s0 implementations, you would do well to call
.PP
.Vb 2
\&    Net::SSLeay::CTX_set_options($ctx, &Net::SSLeay::OP_ALL)
\&         and die_if_ssl_error("ssl ctx set options");
.Ve
to cope with some well know bugs in some other \s-1SSL\s0
implementations. The high level \s-1API\s0 functions always set all known
compatibility options.
.PP
Sometimes sslcat (and the high level https functions that build on it)
is too fast in signaling the \s-1EOF\s0 to legacy https servers. This causes
the server to return empty page. To work around this problem you can
set global variable
.PP
.Vb 1
\&    $Net::SSLeay::slowly = 1;   # Add sleep so broken servers can keep up
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
\&\*(L"Random number generator not seeded!!!\*(R"
  This warning indicates that \fIrandomize()\fR was not able to read
  /dev/random or /dev/urandom, possibly because your system does not
  have them or they are differently named. You can still use \s-1SSL\s0, but
  the encryption will not be as strong.
.PP
\&\*(L"open_tcp_connection: destination host not found:`server' (port 123) ($!)\*(R"
  Name lookup for host named `server' failed.
.PP
\&\*(L"open_tcp_connection: failed `server', 123 ($!)\*(R"
  The name was resolved, but establising the \s-1TCP\s0 connection failed.
.PP
\&\*(L"msg 123: 1 \- error:140770F8:SSL routines:SSL23_GET_SERVER_HELLO:unknown proto\*(R"
  SSLeay error string. First (123) number is \s-1PID\s0, second number (1) indicates
  the position of the error message in SSLeay error stack. You often see
  a pile of these messages as errors cascade.
.PP
\&\*(L"msg 123: 1 \- \fIerror:02001002::lib\fR\|(2) :\fIfunc\fR\|(1) :\fIreason\fR\|(2)\*(R"
  The same as above, but you didn't call \fIload_error_strings()\fR so SSLeay
  couldn't verbosely explain the error. You can still find out what it
  means with this command:
.PP
.Vb 1
\&     /usr/local/ssl/bin/ssleay errstr 02001002
.Ve
.SH "VERSION"
.IX Header "VERSION"
This man page documents version 1.04, released on 31.7.1999. This version
had some \s-1API\s0 changes over 1.03 but is still provisory. Expect to see
version 1.05 to get up to full speed of OpenSSL-0.9.3a and beyound.
.PP
There are currently two perl modules for using OpenSSL C
library: Net::SSLeay (maintaned by me) and SSLeay (maintained by OpenSSL
team). This module is the Net::SSLeay variant.
.PP
At the time of making this release, Eric's module was still quite
scetchy and could not be used for real work, thus I felt motivated to
make this maintenance release. This module is not planned to evolve to
contain any further functionality, i.e. I will concentrate on just
making a simple \s-1SSL\s0 connection over \s-1TCP\s0 socket. Presumably Eric's own
module will offer full SSLeay \s-1API\s0 one day.
.PP
This module uses OpenSSL-0.9.3a. It does not work with any earlier version
and there is no guarantee that it will work with later versions either,
though as long as C \s-1API\s0 does not change, it should. This module
requires perl5.005 (or better?) though I believe it would build with
any perl5.002 or newer.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sampo Kellomaki <sampo@iki.fi>
.PP
Please send bug reports to the above address. General questions should be
sent either to me or to the mailing list (subscribe by sending mail
to openssl-users-request@openssl.org or using web interface at
http://www.openssl.org/support/).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1996\-1999 Sampo Kellomaki <sampo@iki.fi>, All Rights Reserved.
.PP
Distribution and use of this module is under the same terms as the
OpenSSL package itself (i.e. free, but mandatory attribution; \s-1NO\s0
\&\s-1WARRANTY\s0). Please consult \s-1COPYRIGHT\s0 file in the root of the SSLeay
distribution.
.PP
While the source distribution of this perl module does not contain
Eric's or OpenSSL's code, if you use this module you will use OpenSSL
library. Please give Eric and OpenSSL team credit (as required by
their licenses).
.PP
And remember, you, and nobody else but you, are responsible for
auditing this module and OpenSSL library for security problems,
backdoors, and general suitability for your application.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 7
\&  Net_SSLeay/examples                      - Example servers and a clients
\&  <http://www.bacus.pt/Net_SSLeay/index.html>  - Net::SSLeay.pm home
\&  <http://www.openssl.org/>                - OpenSSL source, documentation, etc
\&  openssl-users-request@openssl.org        - General OpenSSL mailing list
\&  <http://home.netscape.com/newsref/std/SSL.html>  - SSL Draft specification
\&  <http://www.w3c.org>                     - HTTP specifications
\&  <http://www.ietf.org/rfc/rfc2617.txt>    - How to send password
.Ve
